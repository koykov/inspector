# Inspector

`Inspector` это кодогенерирующий фреймворк типов-обёрток для получения/записи/итерирования данных в произвольных
<sup>1</sup> типах и структурах данных без использования рефлексии и с нулевым или минимальным количеством аллокаций.

Каждый тип-обёртка (далее "инспектор" или "тип-инспектор") имеет название оригинального типа с суффиксом `Inspector` и
реализует интерфейс [Inspector](https://github.com/koykov/inspector/blob/master/inspector.go#L4) (см. описание методов).

## Введение

Для чего это всё надо: при наличии сложного многоуровневого типа можно, в общем виде, пройти внутрь объекста по какому-то
пути и получить данные из поля (или записать, проитерировать и тд.). В частности такая проблема всплыла при проектировании
библиотеки [dyntpl](https://github.com/koykov/dyntpl) и многих последующих. Обычно такую проблему решают с помощью
рефлексии, но этот способ является экстремально медленным, плодит огромное количество аллокаций и не подходит для хайлоад
проектов. Библиотека [reflect2](https://github.com/modern-go/reflect2) является намного более подходящим выбором,
но даже она не обеспечивает нужную скорость и экономию аллокаций. Идеальным кандидатом по скорости/аллокам является
`type assertion` в комбинации с хардкод обработкой полей, но он не обеспечивает уже "динамичность", т.е. при использовании
такого подхода код будет очень быстрым, но совершенно негибким. Эту проблему лучше рассмотреть на конкретном примере:

Пусть мы имеем многоуровневый тип [`T`](https://github.com/koykov/versus/blob/master/inspector2/types/types.go#L3) и,
в зависимости от условий, необходимо получить значения переменных по произвольным путям, например:
* `obj.L1.L2.L3.S`
* `obj.L1.L2.L3.F`

Причём принципиальным требованием является именно динамичность путей - при одном запуске может потребоваться значение
одного поля, при следующем - другого.

В уже упомянутом выше [тестовом стенде](https://github.com/koykov/versus/tree/master/inspector2) потестируем возможные
варианты:  

### reflect

При использовании рефлексии мы получим примерно такой [код](https://github.com/koykov/versus/blob/master/inspector2/reflect.go#L8).
Это полностью динамическое решение, которое [решает свою задачу](https://github.com/koykov/versus/blob/master/inspector2/reflect_test.go#L7),
но при запуске [бенчмарка](https://github.com/koykov/versus/blob/master/inspector2/reflect_test.go#L11) оно выглядит ужасно:
```
BenchmarkReflect/obj.L1.L2.L3.S-8         	 3119121	       375.6 ns/op	      64 B/op	       5 allocs/op
```
Столь маленькая скорость является следствием большого количества аллоков и при использовании в хайлоад проекте неизбежно
приведёт к проблемам со сборщиком мусора.

### reflect2

Воспользуемся [reflect2](https://github.com/modern-go/reflect2) и напишем такой [код](https://github.com/koykov/versus/blob/master/inspector2/reflect2.go#L12)
обхода структуры. Это также полностью динамическое решение и оно должно решить проблему с аллоком на каждом использовании
типа `reflect.Value`. Это действительно так, но при запуске [бенчмарка](https://github.com/koykov/versus/blob/master/inspector2/reflect2_test.go#L11)
мы видим:
```
BenchmarkReflect2/obj.L1.L2.L3.S-8         	 2973918	       391.3 ns/op	       0 B/op	       0 allocs/op
```
Очень хороший показатель по аллокам, но ужасный по скорости, хуже даже чем нативная рефлексия. Это связано с внутренней
реализацией `reflect2.frozenConfig` типа (он использует `sync.Map` и приходится платить за блокировки).

### inspector

Начнём сразу с [бенчмарка](https://github.com/koykov/versus/blob/master/inspector2/inspector_test.go#L17):
```
BenchmarkInspector/obj.L1.L2.L3.S-8         	159301698	         7.596 ns/op	       0 B/op	       0 allocs/op
```
Цифры приемлемые - ноль аллоков и на два порядка выше скорость. В следующей главе будет объяснение как это было
достигнуто.

## Принцип работы инспекторов

Как уже упоминалось выше, идеальным вариантом для решения задачи является `type assertion` и хардкод обработка полей,
то есть полный отказ от рефлексии в любом виде. Обеспечить "динамичность"<sup>2</sup> обращений при этом возможно только
посредством хардкода всех возможных комбинаций полей типа. Так, упомянутый тип [`T`](https://github.com/koykov/versus/blob/master/inspector2/types/types.go#L3) позволяет следующие комбинации
полей:
* `obj.L1.L2.L3.S`
* `obj.L1.L2.L3.I`
* `obj.L1.L2.L3.F`
* `obj.L1.L2.L3`
* `obj.L1.L2`
* `obj.L1`

Этот тип довольно простой, поэтому комбинаций настолько мало. Код, обеспечивающий чтение значений из объекта типа `T`
по произвольному пути, выглядит вот [так](https://github.com/koykov/versus/blob/master/inspector2/inspector2_ins/t_ins.go#L31).
Максимально примитивно и поэтому настолько быстро. Хоть и громоздко.

Также легко представить себе дерево типов, у которого количество комбинаций будет превышать сотни, если не тысячи,
вариантов. Писать для каждого нужного типа аналогичный код, учитывающий все возможные комбинации полей, будет
чрезвычайно утомительно. Плюс этим же придётся заниматься при каждом изменении типа (добавление/изменение/удаление
полей), что также будет весьма трудоёмко. Поэтому логичным шагом будет автоматизировать эту задачу и написать
[кодогенератор](https://github.com/koykov/inspector/tree/master/inspc). 

## Дополнительные возможности

Кроме рассмотренной уже возможности получать значения полей в сложных структурах, типы-инспекторы также позволяют:
* [записывать значения в поля](https://github.com/koykov/inspector/blob/master/inspector.go#L12)
* [сравнивать значения полей](https://github.com/koykov/inspector/blob/master/inspector.go#L17)
* [итерировать поля в структурах](https://github.com/koykov/inspector/blob/master/inspector.go#L19) по заданному пути
* [сравнивать структуры (или подструктуры/отдельные поля)](https://github.com/koykov/inspector/blob/master/inspector.go#L21) по заданному пути
* [копировать структуры](https://github.com/koykov/inspector/blob/master/inspector.go#L27)
* [очищать структуры](https://github.com/koykov/inspector/blob/master/inspector.go#L35)

Эти методы также используют комбинацию `type assertion` с хардкодом и [работают быстрее](https://github.com/koykov/inspector/blob/master/test/inspector_test.go)
рефлексии в любом виде.

## Инспекторы базовых типов

### static

Для работы базовых типов (int, uint, float64, ...) был разработан специальный инспектор [static](https://github.com/koykov/inspector/blob/master/static.go).
Он широко применяется в библиотеках [dyntpl](https://github.com/koykov/dyntpl) и [decoder](https://github.com/koykov/decoder)
при работе с примитивными типами.

### strings

Для работы с типами `string` и `[][]byte` разработан инспектор [strings](https://github.com/koykov/inspector/blob/master/strings.go).
См. [тестовые сценарии](https://github.com/koykov/inspector/blob/master/test/strings_test.go).

### map[string]any

Специально для классических сценариев работы с `encoding/json` был разработан инспектор для типа [map\[string\]any](https://github.com/koykov/inspector/blob/master/stranymap.go).
См. [тестовые сценарии](https://github.com/koykov/inspector/blob/master/test/stranymap_test.go).

## Примечания 

<sup>1</sup> На самом деле "произвольный" это лукавство, правильнее будет сформулировать "произвольный тип или структура
данных среди известных, для которых были сгенерированы или написаны руками типы-инспекторы".

<sup>2</sup> Назвать это динамичностью конечно не вполне справедливо, но достигнутый результат позволяет достигнуть цели
так, как если бы решение было динамическим (как у `reflect`/`reflect2`).
