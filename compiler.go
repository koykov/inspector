package inspector

import (
	"go/types"
	"strconv"
	"strings"

	"golang.org/x/tools/go/loader"
)

type typ int

const (
	typeStruct typ = iota
	typeMap
	typeSlice
	typeBasic
)

type ByteStringWriter interface {
	Write(p []byte) (n int, err error)
	WriteByte(c byte) error
	WriteString(s string) (n int, err error)
}

type Compiler struct {
	pkg     string
	pkgDot  string
	pkgName string
	outDir  string
	uniq    map[string]bool
	nodes   []*node
	w       ByteStringWriter
}

type node struct {
	typ  typ
	typn string
	name string
	ptr  bool
	chld []*node
	mapk *node
	mapv *node
	slct *node
}

func NewCompiler(pkg, outDir string, w ByteStringWriter) *Compiler {
	c := Compiler{
		pkg:    pkg,
		pkgDot: pkg + ".",
		outDir: outDir,
		uniq:   make(map[string]bool),
		w:      w,
	}
	return &c
}

func (c *Compiler) String() string {
	return ""
}

func (c *Compiler) Compile() error {
	var conf loader.Config
	conf.Import(c.pkg)
	prog, err := conf.Load()
	if err != nil {
		return err
	}

	pkg := prog.Package(c.pkg)
	c.pkgName = pkg.Pkg.Name()
	err = c.parsePkg(pkg)
	if err != nil {
		return err
	}

	err = c.write()
	if err != nil {
		return err
	}

	return nil
}

func (c *Compiler) parsePkg(pkg *loader.PackageInfo) error {
	for _, scope := range pkg.Info.Scopes {
		if parent := scope.Parent(); parent != nil {
			for _, name := range parent.Names() {
				o := parent.Lookup(name)
				t := o.Type()
				node, err := c.parseType(t)
				if err != nil {
					return err
				}
				node.name = o.Name()
				c.nodes = append(c.nodes, node)
			}
		}
	}

	return nil
}

func (c *Compiler) parseType(t types.Type) (*node, error) {
	node := &node{
		typ:  typeBasic,
		typn: strings.Replace(t.String(), c.pkgDot, "", 1),
		ptr:  false,
	}

	u := t.Underlying()
	if p, ok := u.(*types.Pointer); ok {
		u = p.Elem().Underlying()
		node, err := c.parseType(u)
		if err != nil {
			return node, err
		}
		node.ptr = true
		return node, err
	}

	if s, ok := u.(*types.Struct); ok {
		node.typ = typeStruct
		for i := 0; i < s.NumFields(); i++ {
			f := s.Field(i)
			ch, err := c.parseType(f.Type())
			if err != nil {
				return node, err
			}
			ch.name = f.Name()
			if ch.ptr {
				ch.typn = "*" + ch.name
			}
			node.chld = append(node.chld, ch)
		}
		return node, nil
	}

	if m, ok := u.(*types.Map); ok {
		var err error
		node.typ = typeMap
		node.mapk, err = c.parseType(m.Key())
		node.mapv, err = c.parseType(m.Elem())
		return node, err
	}

	if s, ok := u.(*types.Slice); ok {
		var err error
		node.typ = typeSlice
		node.slct, err = c.parseType(s.Elem())
		return node, err
	}

	return node, nil
}

func (c *Compiler) write() error {
	_, _ = c.w.WriteString("// Code generated by inspectc. DO NOT EDIT.\n")
	_, _ = c.w.WriteString("// source: ")
	_, _ = c.w.WriteString(c.pkg)
	_, _ = c.w.WriteString("\n\n")

	_, _ = c.w.WriteString("package ")
	_, _ = c.w.WriteString(c.pkgName + "_ins\n\n")

	_, _ = c.w.WriteString("import (\n")
	_, _ = c.w.WriteString("\t" + c.pkg + "\n")
	_, _ = c.w.WriteString(")\n\n")

	for i, node := range c.nodes {
		err := c.writeRootNode(node, i)
		if err != nil {
			return err
		}
	}

	return nil
}

func (c *Compiler) writeRootNode(node *node, idx int) error {
	inst := node.name + "Inspector"
	recv := "i" + strconv.Itoa(idx)
	pname := c.pkgName + "." + node.typn

	_, _ = c.w.WriteString("type " + inst + " struct {}\n\n")

	// Getter method.
	_, _ = c.w.WriteString("func (" + recv + " *" + inst + ") Get(src interface{}, path ...string) interface{} {\n")
	_, _ = c.w.WriteString("\tif len(path) == 0 { return nil }\n")
	_, _ = c.w.WriteString("\tif src == nil { return nil }\n")
	_, _ = c.w.WriteString("\tvar x *" + pname + "\n")
	_, _ = c.w.WriteString("\tif p, ok := src.(*" + pname + "); ok { x = p } else if v, ok := src.(" + pname + "); ok { x = &v } else { return nil }\n\n")

	err := c.writeNode(node, "x", 0, 0)
	if err != nil {
		return err
	}

	_, _ = c.w.WriteString("\treturn nil\n}\n\n")

	// Setter method.
	_, _ = c.w.WriteString("func (" + recv + " *" + inst + ") Set(dst, value interface{}, path ...string) {\n")
	_, _ = c.w.WriteString("}\n\n")
	return nil
}

func (c *Compiler) writeNode(node *node, v string, depth, idntc int) error {
	idnt := strings.Repeat("\t", idntc+1)
	idnt1 := idnt + "\t"
	idnt2 := idnt1 + "\t"
	depths := strconv.Itoa(depth)

	_, _ = c.w.WriteString(idnt + "if len(path) > " + depths + " {\n")
	if node.ptr {
		_, _ = c.w.WriteString(idnt1 + "if " + v + " == nil { return nil }\n")
	}
	switch node.typ {
	case typeStruct:
		for _, ch := range node.chld {
			_, _ = c.w.WriteString(idnt1 + "if path[" + depths + "] == " + `"` + ch.name + `" {` + "\n")
			if ch.typ == typeBasic || (ch.typ == typeSlice && ch.typn == "[]byte") {
				_, _ = c.w.WriteString(idnt2 + "return " + v + "." + ch.name + "\n")
			} else {
				nv := "x" + strconv.Itoa(depth)
				_, _ = c.w.WriteString(idnt2 + nv + " := " + v + "." + ch.name + "\n")
				_, _ = c.w.WriteString(idnt2 + "_ = " + nv + "\n")
				err := c.writeNode(ch, nv, depth+1, idntc+2)
				if err != nil {
					return err
				}
			}
			_, _ = c.w.WriteString(idnt1 + "}\n")
		}
	case typeMap:
	//
	case typeSlice:
	//
	case typeBasic:
		//
	}
	_, _ = c.w.WriteString(idnt + "}\n")
	return nil
}
