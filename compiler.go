package inspector

import (
	"go/types"
	"strconv"
	"strings"

	"golang.org/x/tools/go/loader"
)

type typ int

const (
	typeStruct typ = iota
	typeMap
	typeSlice
	typeBasic
)

type ByteStringWriter interface {
	Write(p []byte) (n int, err error)
	WriteByte(c byte) error
	WriteString(s string) (n int, err error)
}

type Compiler struct {
	pkg     string
	pkgDot  string
	pkgName string
	outDir  string
	uniq    map[string]bool
	nodes   []*node
	wr      ByteStringWriter
	err     error
}

type node struct {
	typ  typ
	typn string
	name string
	ptr  bool
	chld []*node
	mapk *node
	mapv *node
	slct *node
}

func NewCompiler(pkg, outDir string, w ByteStringWriter) *Compiler {
	c := Compiler{
		pkg:    pkg,
		pkgDot: pkg + ".",
		outDir: outDir,
		uniq:   make(map[string]bool),
		wr:     w,
	}
	return &c
}

func (c *Compiler) String() string {
	return ""
}

func (c *Compiler) Compile() error {
	var conf loader.Config
	conf.Import(c.pkg)
	prog, err := conf.Load()
	if err != nil {
		return err
	}

	pkg := prog.Package(c.pkg)
	c.pkgName = pkg.Pkg.Name()
	err = c.parsePkg(pkg)
	if err != nil {
		return err
	}

	err = c.write()
	if err != nil {
		return err
	}

	return nil
}

func (c *Compiler) parsePkg(pkg *loader.PackageInfo) error {
	for _, scope := range pkg.Info.Scopes {
		if parent := scope.Parent(); parent != nil {
			for _, name := range parent.Names() {
				o := parent.Lookup(name)
				t := o.Type()
				node, err := c.parseType(t)
				if err != nil {
					return err
				}
				node.name = o.Name()
				c.nodes = append(c.nodes, node)
			}
		}
	}

	return nil
}

func (c *Compiler) parseType(t types.Type) (*node, error) {
	node := &node{
		typ:  typeBasic,
		typn: strings.Replace(t.String(), c.pkgDot, "", 1),
		ptr:  false,
	}

	u := t.Underlying()
	if p, ok := u.(*types.Pointer); ok {
		u = p.Elem().Underlying()
		node, err := c.parseType(u)
		if err != nil {
			return node, err
		}
		node.ptr = true
		return node, err
	}

	if s, ok := u.(*types.Struct); ok {
		node.typ = typeStruct
		for i := 0; i < s.NumFields(); i++ {
			f := s.Field(i)
			ch, err := c.parseType(f.Type())
			if err != nil {
				return node, err
			}
			ch.name = f.Name()
			if ch.ptr {
				ch.typn = strings.Replace(f.Type().String(), c.pkgDot, "", 1)
			}
			node.chld = append(node.chld, ch)
		}
		return node, nil
	}

	if m, ok := u.(*types.Map); ok {
		var err error
		node.typ = typeMap
		node.mapk, err = c.parseType(m.Key())
		node.mapv, err = c.parseType(m.Elem())
		return node, err
	}

	if s, ok := u.(*types.Slice); ok {
		var err error
		node.typ = typeSlice
		node.slct, err = c.parseType(s.Elem())
		return node, err
	}

	return node, nil
}

func (c *Compiler) write() error {
	c.wl("// Code generated by inspectc. DO NOT EDIT.")
	c.wdl("// source: ", c.pkg)

	c.wdl("package ", c.pkgName, "_ins")
	c.wdl("import (\n\t", `"github.com/koykov/inspector"`, "\n\t", `"`, c.pkg, `"`, "\n)")

	for i, node := range c.nodes {
		err := c.writeRootNode(node, i)
		if err != nil {
			return err
		}
	}

	return nil
}

func (c *Compiler) writeRootNode(node *node, idx int) error {
	inst := node.name + "Inspector"
	recv := "i" + strconv.Itoa(idx)
	pname := c.pkgName + "." + node.typn

	c.wdl("type ", inst, " struct {\n\tinspector.BaseInspector\n}")

	// Getter method.
	c.wl("func (", recv, " *", inst, ") Get(src interface{}, path ...string) interface{} {")
	c.wl("\tif len(path) == 0 { return nil }")
	c.wl("\tif src == nil { return nil }")
	c.wl("\tvar x *", pname)
	c.wdl("\tif p, ok := src.(*", pname, "); ok { x = p } else if v, ok := src.(", pname, "); ok { x = &v } else { return nil }")

	err := c.writeNode(node, recv, "x", 0, 0)
	if err != nil {
		return err
	}

	c.wdl("\treturn nil\n}")

	// Setter method.
	c.wl("func (", recv, " *", inst, ") Set(dst, value interface{}, path ...string) {")
	// ...
	c.wdl("}")

	return c.err
}

func (c *Compiler) writeNode(node *node, recv, v string, depth, idntc int) error {
	idnt := strings.Repeat("\t", idntc+1)
	idnt1 := idnt + "\t"
	idnt2 := idnt1 + "\t"
	depths := strconv.Itoa(depth)

	if node.typ != typeBasic {
		c.wl(idnt, "if len(path) > ", depths, " {")
	}
	if node.ptr {
		c.wl(idnt1, "if ", v, " == nil { return nil }")
	}
	switch node.typ {
	case typeStruct:
		for _, ch := range node.chld {
			c.wl(idnt1, "if path[", depths, "] == ", `"`, ch.name, `" {`)
			if ch.typ == typeBasic || (ch.typ == typeSlice && ch.typn == "[]byte") {
				c.wl(idnt2, "return ", v, ".", ch.name)
			} else {
				nv := "x" + strconv.Itoa(depth)
				c.wl(idnt2, nv, " := ", v, ".", ch.name)
				c.wl(idnt2, "_ = ", nv)
				err := c.writeNode(ch, recv, nv, depth+1, idntc+2)
				if err != nil {
					return err
				}
			}
			c.wl(idnt1, "}")
		}
	case typeMap:
		nv := "x" + strconv.Itoa(depth)
		if node.mapk.typn == "string" {
			c.wl(idnt1, "if ", nv, ", ok := ", c.fmtV(node, v), "[path[", depths, "]]; ok {")
			c.wl(idnt2, "_ = ", nv)
			err := c.writeNode(node.mapv, recv, nv, depth+1, idntc+2)
			if err != nil {
				return err
			}
			c.wl(idnt1, "}")
		} else {
			c.wl(idnt1, "if k, err := ", recv, ".StrTo(path[", depths, "], \"", node.mapk.typn, "\"); err == nil {")
			c.wl(idnt2, nv, " := ", c.fmtV(node, v), "[k.(", node.mapk.typn, ")]")
			c.wl(idnt2, "_ = ", nv)
			err := c.writeNode(node.mapv, recv, nv, depth+1, idntc+2)
			if err != nil {
				return err
			}
			c.wl(idnt1, "}")
		}
	case typeSlice:
		if node.typn == "[]byte" {
			c.wl(idnt, "return ", v)
		}
		nv := "x" + strconv.Itoa(depth)
		c.wl(idnt, "if k, err := ", recv, ".StrTo(path[", depths, "], \"int\"); err == nil {")
		c.wl(idnt1, "i := k.(int)")
		c.wl(idnt1, "if len(", v, ") > i {")
		c.wl(idnt2, nv, " := ", v, "[i]")
		c.wl(idnt2, "_ = ", nv)
		err := c.writeNode(node.slct, recv, nv, depth+1, idntc+2)
		if err != nil {
			return err
		}
		c.wl(idnt1, "}")
		c.wl(idnt, "}")
	case typeBasic:
		c.wl(idnt, "return ", v)
	}
	if node.typ != typeBasic {
		c.wl(idnt, "}")
	}

	return c.err
}

func (c *Compiler) fmtV(node *node, v string) string {
	if node.ptr {
		return "(*" + v + ")"
	}
	return "(" + v + ")"
}

func (c *Compiler) w(s ...string) {
	_, err := c.wr.WriteString(strings.Join(s, ""))
	if err != nil && c.err == nil {
		c.err = err
	}
}

func (c *Compiler) wl(s ...string) {
	s = append(s, "\n")
	c.w(s...)
}

func (c *Compiler) wdl(s ...string) {
	s = append(s, "\n\n")
	c.w(s...)
}
