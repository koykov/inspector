// Code generated by inspc. DO NOT EDIT.
// source: github.com/koykov/inspector/testobj

package testobj_ins

import (
	"bytes"
	"encoding/json"
	"github.com/koykov/byteconv"
	"github.com/koykov/inspector"
	"github.com/koykov/inspector/testobj"
	"strconv"
)

func init() {
	inspector.RegisterInspector("TestObject1", TestObject1Inspector{})
}

type TestObject1Inspector struct {
	inspector.BaseInspector
}

func (i6 TestObject1Inspector) TypeName() string {
	return "TestObject1"
}

func (i6 TestObject1Inspector) Instance(ptr bool) any {
	if ptr {
		return &testobj.TestObject1{}
	}
	return testobj.TestObject1{}
}

func (i6 TestObject1Inspector) Get(src any, path ...string) (any, error) {
	var buf any
	err := i6.GetTo(src, &buf, path...)
	return buf, err
}

func (i6 TestObject1Inspector) GetTo(src any, buf *any, path ...string) (err error) {
	if src == nil {
		return
	}
	var x *testobj.TestObject1
	_ = x
	if p, ok := src.(**testobj.TestObject1); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestObject1); ok {
		x = p
	} else if v, ok := src.(testobj.TestObject1); ok {
		x = &v
	} else {
		return
	}
	if len(path) == 0 {
		*buf = &(*x)
		return
	}

	if len(path) > 0 {
		if path[0] == "IntSlice" {
			x0 := x.IntSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t53, err53 := strconv.ParseInt(path[1], 0, 0)
				if err53 != nil {
					return err53
				}
				i = int(t53)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.IntSlice
			return
		}
		if path[0] == "IntPtrSlice" {
			x0 := x.IntPtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t54, err54 := strconv.ParseInt(path[1], 0, 0)
				if err54 != nil {
					return err54
				}
				i = int(t54)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.IntPtrSlice
			return
		}
		if path[0] == "IntSlicePtr" {
			x0 := x.IntSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t55, err55 := strconv.ParseInt(path[1], 0, 0)
				if err55 != nil {
					return err55
				}
				i = int(t55)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.IntSlicePtr
			return
		}
		if path[0] == "IntPtrSlicePtr" {
			x0 := x.IntPtrSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t56, err56 := strconv.ParseInt(path[1], 0, 0)
				if err56 != nil {
					return err56
				}
				i = int(t56)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.IntPtrSlicePtr
			return
		}
		if path[0] == "ByteSlice" {
			*buf = &x.ByteSlice
			return
		}
		if path[0] == "BytePtrSlice" {
			x0 := x.BytePtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t57, err57 := strconv.ParseInt(path[1], 0, 0)
				if err57 != nil {
					return err57
				}
				i = int(t57)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.BytePtrSlice
			return
		}
		if path[0] == "ByteSlicePtr" {
			*buf = &x.ByteSlicePtr
			return
		}
		if path[0] == "BytePtrSlicePtr" {
			x0 := x.BytePtrSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t58, err58 := strconv.ParseInt(path[1], 0, 0)
				if err58 != nil {
					return err58
				}
				i = int(t58)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.BytePtrSlicePtr
			return
		}
		if path[0] == "FloatSlice" {
			x0 := x.FloatSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t59, err59 := strconv.ParseInt(path[1], 0, 0)
				if err59 != nil {
					return err59
				}
				i = int(t59)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.FloatSlice
			return
		}
		if path[0] == "FloatPtrSlice" {
			x0 := x.FloatPtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t60, err60 := strconv.ParseInt(path[1], 0, 0)
				if err60 != nil {
					return err60
				}
				i = int(t60)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.FloatPtrSlice
			return
		}
		if path[0] == "FloatSlicePtr" {
			x0 := x.FloatSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t61, err61 := strconv.ParseInt(path[1], 0, 0)
				if err61 != nil {
					return err61
				}
				i = int(t61)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.FloatSlicePtr
			return
		}
		if path[0] == "FloatPtrSlicePtr" {
			x0 := x.FloatPtrSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t62, err62 := strconv.ParseInt(path[1], 0, 0)
				if err62 != nil {
					return err62
				}
				i = int(t62)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.FloatPtrSlicePtr
			return
		}
		if path[0] == "StructSlice" {
			x0 := x.StructSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t63, err63 := strconv.ParseInt(path[1], 0, 0)
				if err63 != nil {
					return err63
				}
				i = int(t63)
				if len(x0) > i {
					x1 := &(x0)[i]
					_ = x1
					if len(path) > 2 {
						if path[2] == "A" {
							*buf = &x1.A
							return
						}
						if path[2] == "S" {
							*buf = &x1.S
							return
						}
						if path[2] == "B" {
							*buf = &x1.B
							return
						}
						if path[2] == "I" {
							*buf = &x1.I
							return
						}
						if path[2] == "I8" {
							*buf = &x1.I8
							return
						}
						if path[2] == "I16" {
							*buf = &x1.I16
							return
						}
						if path[2] == "I32" {
							*buf = &x1.I32
							return
						}
						if path[2] == "I64" {
							*buf = &x1.I64
							return
						}
						if path[2] == "U" {
							*buf = &x1.U
							return
						}
						if path[2] == "U8" {
							*buf = &x1.U8
							return
						}
						if path[2] == "U16" {
							*buf = &x1.U16
							return
						}
						if path[2] == "U32" {
							*buf = &x1.U32
							return
						}
						if path[2] == "U64" {
							*buf = &x1.U64
							return
						}
						if path[2] == "F" {
							*buf = &x1.F
							return
						}
						if path[2] == "D" {
							*buf = &x1.D
							return
						}
					}
					*buf = x1
				}
			}
			*buf = &x.StructSlice
			return
		}
		if path[0] == "StructPtrSlice" {
			x0 := x.StructPtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t64, err64 := strconv.ParseInt(path[1], 0, 0)
				if err64 != nil {
					return err64
				}
				i = int(t64)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return
						}
						if path[2] == "A" {
							*buf = &x1.A
							return
						}
						if path[2] == "S" {
							*buf = &x1.S
							return
						}
						if path[2] == "B" {
							*buf = &x1.B
							return
						}
						if path[2] == "I" {
							*buf = &x1.I
							return
						}
						if path[2] == "I8" {
							*buf = &x1.I8
							return
						}
						if path[2] == "I16" {
							*buf = &x1.I16
							return
						}
						if path[2] == "I32" {
							*buf = &x1.I32
							return
						}
						if path[2] == "I64" {
							*buf = &x1.I64
							return
						}
						if path[2] == "U" {
							*buf = &x1.U
							return
						}
						if path[2] == "U8" {
							*buf = &x1.U8
							return
						}
						if path[2] == "U16" {
							*buf = &x1.U16
							return
						}
						if path[2] == "U32" {
							*buf = &x1.U32
							return
						}
						if path[2] == "U64" {
							*buf = &x1.U64
							return
						}
						if path[2] == "F" {
							*buf = &x1.F
							return
						}
						if path[2] == "D" {
							*buf = &x1.D
							return
						}
					}
					*buf = x1
				}
			}
			*buf = &x.StructPtrSlice
			return
		}
		if path[0] == "StructSlicePtr" {
			x0 := x.StructSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t65, err65 := strconv.ParseInt(path[1], 0, 0)
				if err65 != nil {
					return err65
				}
				i = int(t65)
				if len(*x0) > i {
					x1 := &(*x0)[i]
					_ = x1
					if len(path) > 2 {
						if path[2] == "A" {
							*buf = &x1.A
							return
						}
						if path[2] == "S" {
							*buf = &x1.S
							return
						}
						if path[2] == "B" {
							*buf = &x1.B
							return
						}
						if path[2] == "I" {
							*buf = &x1.I
							return
						}
						if path[2] == "I8" {
							*buf = &x1.I8
							return
						}
						if path[2] == "I16" {
							*buf = &x1.I16
							return
						}
						if path[2] == "I32" {
							*buf = &x1.I32
							return
						}
						if path[2] == "I64" {
							*buf = &x1.I64
							return
						}
						if path[2] == "U" {
							*buf = &x1.U
							return
						}
						if path[2] == "U8" {
							*buf = &x1.U8
							return
						}
						if path[2] == "U16" {
							*buf = &x1.U16
							return
						}
						if path[2] == "U32" {
							*buf = &x1.U32
							return
						}
						if path[2] == "U64" {
							*buf = &x1.U64
							return
						}
						if path[2] == "F" {
							*buf = &x1.F
							return
						}
						if path[2] == "D" {
							*buf = &x1.D
							return
						}
					}
					*buf = x1
				}
			}
			*buf = &x.StructSlicePtr
			return
		}
		if path[0] == "StructPtrSlicePtr" {
			x0 := x.StructPtrSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t66, err66 := strconv.ParseInt(path[1], 0, 0)
				if err66 != nil {
					return err66
				}
				i = int(t66)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return
						}
						if path[2] == "A" {
							*buf = &x1.A
							return
						}
						if path[2] == "S" {
							*buf = &x1.S
							return
						}
						if path[2] == "B" {
							*buf = &x1.B
							return
						}
						if path[2] == "I" {
							*buf = &x1.I
							return
						}
						if path[2] == "I8" {
							*buf = &x1.I8
							return
						}
						if path[2] == "I16" {
							*buf = &x1.I16
							return
						}
						if path[2] == "I32" {
							*buf = &x1.I32
							return
						}
						if path[2] == "I64" {
							*buf = &x1.I64
							return
						}
						if path[2] == "U" {
							*buf = &x1.U
							return
						}
						if path[2] == "U8" {
							*buf = &x1.U8
							return
						}
						if path[2] == "U16" {
							*buf = &x1.U16
							return
						}
						if path[2] == "U32" {
							*buf = &x1.U32
							return
						}
						if path[2] == "U64" {
							*buf = &x1.U64
							return
						}
						if path[2] == "F" {
							*buf = &x1.F
							return
						}
						if path[2] == "D" {
							*buf = &x1.D
							return
						}
					}
					*buf = x1
				}
			}
			*buf = &x.StructPtrSlicePtr
			return
		}
		if path[0] == "StructSliceLiteral" {
			x0 := x.StructSliceLiteral
			_ = x0
			if len(path) > 1 {
				var i int
				t67, err67 := strconv.ParseInt(path[1], 0, 0)
				if err67 != nil {
					return err67
				}
				i = int(t67)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return
						}
						if path[2] == "A" {
							*buf = &x1.A
							return
						}
						if path[2] == "S" {
							*buf = &x1.S
							return
						}
						if path[2] == "B" {
							*buf = &x1.B
							return
						}
						if path[2] == "I" {
							*buf = &x1.I
							return
						}
						if path[2] == "I8" {
							*buf = &x1.I8
							return
						}
						if path[2] == "I16" {
							*buf = &x1.I16
							return
						}
						if path[2] == "I32" {
							*buf = &x1.I32
							return
						}
						if path[2] == "I64" {
							*buf = &x1.I64
							return
						}
						if path[2] == "U" {
							*buf = &x1.U
							return
						}
						if path[2] == "U8" {
							*buf = &x1.U8
							return
						}
						if path[2] == "U16" {
							*buf = &x1.U16
							return
						}
						if path[2] == "U32" {
							*buf = &x1.U32
							return
						}
						if path[2] == "U64" {
							*buf = &x1.U64
							return
						}
						if path[2] == "F" {
							*buf = &x1.F
							return
						}
						if path[2] == "D" {
							*buf = &x1.D
							return
						}
					}
					*buf = x1
				}
			}
			*buf = &x.StructSliceLiteral
			return
		}
		if path[0] == "IntStringMap" {
			x0 := x.IntStringMap
			_ = x0
			if len(path) > 1 {
				var k int
				t68, err68 := strconv.ParseInt(path[1], 0, 0)
				if err68 != nil {
					return err68
				}
				k = int(t68)
				x1 := (x0)[k]
				_ = x1
				*buf = &x1
				return
			}
			*buf = &x.IntStringMap
			return
		}
		if path[0] == "IntStringPtrMap" {
			x0 := x.IntStringPtrMap
			_ = x0
			if len(path) > 1 {
				var k int
				t69, err69 := strconv.ParseInt(path[1], 0, 0)
				if err69 != nil {
					return err69
				}
				k = int(t69)
				x1 := (x0)[k]
				_ = x1
				if x1 == nil {
					return
				}
				*buf = &x1
				return
			}
			*buf = &x.IntStringPtrMap
			return
		}
		if path[0] == "IntStringMapPtr" {
			x0 := x.IntStringMapPtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var k int
				t70, err70 := strconv.ParseInt(path[1], 0, 0)
				if err70 != nil {
					return err70
				}
				k = int(t70)
				x1 := (*x0)[k]
				_ = x1
				*buf = &x1
				return
			}
			*buf = &x.IntStringMapPtr
			return
		}
		if path[0] == "IntStringPtrMapPtr" {
			x0 := x.IntStringPtrMapPtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var k int
				t71, err71 := strconv.ParseInt(path[1], 0, 0)
				if err71 != nil {
					return err71
				}
				k = int(t71)
				x1 := (*x0)[k]
				_ = x1
				if x1 == nil {
					return
				}
				*buf = &x1
				return
			}
			*buf = &x.IntStringPtrMapPtr
			return
		}
		if path[0] == "IntPtrStringPtrMapPtr" {
			x0 := x.IntPtrStringPtrMapPtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var k int
				t72, err72 := strconv.ParseInt(path[1], 0, 0)
				if err72 != nil {
					return err72
				}
				k = int(t72)
				x1 := (*x0)[&k]
				_ = x1
				if x1 == nil {
					return
				}
				*buf = &x1
				return
			}
			*buf = &x.IntPtrStringPtrMapPtr
			return
		}
		if path[0] == "IntIntMapMap" {
			x0 := x.IntIntMapMap
			_ = x0
			if len(path) > 1 {
				var k int32
				t73, err73 := strconv.ParseInt(path[1], 0, 0)
				if err73 != nil {
					return err73
				}
				k = int32(t73)
				x1 := (x0)[k]
				_ = x1
				if len(path) > 2 {
					var k int32
					t74, err74 := strconv.ParseInt(path[2], 0, 0)
					if err74 != nil {
						return err74
					}
					k = int32(t74)
					x2 := (x1)[k]
					_ = x2
					*buf = &x2
					return
				}
				*buf = &x1
			}
			*buf = &x.IntIntMapMap
			return
		}
		if path[0] == "StringFloatMap" {
			x0 := x.StringFloatMap
			_ = x0
			if len(path) > 1 {
				if x1, ok := (x0)[path[1]]; ok {
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.StringFloatMap
			return
		}
		if path[0] == "StringFloatPtrMap" {
			x0 := x.StringFloatPtrMap
			_ = x0
			if len(path) > 1 {
				if x1, ok := (x0)[path[1]]; ok {
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.StringFloatPtrMap
			return
		}
		if path[0] == "StringFloatMapPtr" {
			x0 := x.StringFloatMapPtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if x1, ok := (*x0)[path[1]]; ok {
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.StringFloatMapPtr
			return
		}
		if path[0] == "StringFloatPtrMapPtr" {
			x0 := x.StringFloatPtrMapPtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if x1, ok := (*x0)[path[1]]; ok {
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.StringFloatPtrMapPtr
			return
		}
		if path[0] == "StringPtrFloatPtrMapPtr" {
			x0 := x.StringPtrFloatPtrMapPtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if x1, ok := (*x0)[&path[1]]; ok {
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.StringPtrFloatPtrMapPtr
			return
		}
		if path[0] == "FloatStructMap" {
			x0 := x.FloatStructMap
			_ = x0
			if len(path) > 1 {
				var k float64
				t75, err75 := strconv.ParseFloat(path[1], 0)
				if err75 != nil {
					return err75
				}
				k = float64(t75)
				x1 := (x0)[k]
				_ = x1
				if len(path) > 2 {
					if path[2] == "A" {
						*buf = &x1.A
						return
					}
					if path[2] == "S" {
						*buf = &x1.S
						return
					}
					if path[2] == "B" {
						*buf = &x1.B
						return
					}
					if path[2] == "I" {
						*buf = &x1.I
						return
					}
					if path[2] == "I8" {
						*buf = &x1.I8
						return
					}
					if path[2] == "I16" {
						*buf = &x1.I16
						return
					}
					if path[2] == "I32" {
						*buf = &x1.I32
						return
					}
					if path[2] == "I64" {
						*buf = &x1.I64
						return
					}
					if path[2] == "U" {
						*buf = &x1.U
						return
					}
					if path[2] == "U8" {
						*buf = &x1.U8
						return
					}
					if path[2] == "U16" {
						*buf = &x1.U16
						return
					}
					if path[2] == "U32" {
						*buf = &x1.U32
						return
					}
					if path[2] == "U64" {
						*buf = &x1.U64
						return
					}
					if path[2] == "F" {
						*buf = &x1.F
						return
					}
					if path[2] == "D" {
						*buf = &x1.D
						return
					}
				}
				*buf = &x1
			}
			*buf = &x.FloatStructMap
			return
		}
		if path[0] == "FloatStructPtrMap" {
			x0 := x.FloatStructPtrMap
			_ = x0
			if len(path) > 1 {
				var k float64
				t76, err76 := strconv.ParseFloat(path[1], 0)
				if err76 != nil {
					return err76
				}
				k = float64(t76)
				x1 := (x0)[k]
				_ = x1
				if len(path) > 2 {
					if x1 == nil {
						return
					}
					if path[2] == "A" {
						*buf = &x1.A
						return
					}
					if path[2] == "S" {
						*buf = &x1.S
						return
					}
					if path[2] == "B" {
						*buf = &x1.B
						return
					}
					if path[2] == "I" {
						*buf = &x1.I
						return
					}
					if path[2] == "I8" {
						*buf = &x1.I8
						return
					}
					if path[2] == "I16" {
						*buf = &x1.I16
						return
					}
					if path[2] == "I32" {
						*buf = &x1.I32
						return
					}
					if path[2] == "I64" {
						*buf = &x1.I64
						return
					}
					if path[2] == "U" {
						*buf = &x1.U
						return
					}
					if path[2] == "U8" {
						*buf = &x1.U8
						return
					}
					if path[2] == "U16" {
						*buf = &x1.U16
						return
					}
					if path[2] == "U32" {
						*buf = &x1.U32
						return
					}
					if path[2] == "U64" {
						*buf = &x1.U64
						return
					}
					if path[2] == "F" {
						*buf = &x1.F
						return
					}
					if path[2] == "D" {
						*buf = &x1.D
						return
					}
				}
				*buf = &x1
			}
			*buf = &x.FloatStructPtrMap
			return
		}
		if path[0] == "FloatPtrStructMap" {
			x0 := x.FloatPtrStructMap
			_ = x0
			if len(path) > 1 {
				var k float64
				t77, err77 := strconv.ParseFloat(path[1], 0)
				if err77 != nil {
					return err77
				}
				k = float64(t77)
				x1 := (x0)[&k]
				_ = x1
				if len(path) > 2 {
					if path[2] == "A" {
						*buf = &x1.A
						return
					}
					if path[2] == "S" {
						*buf = &x1.S
						return
					}
					if path[2] == "B" {
						*buf = &x1.B
						return
					}
					if path[2] == "I" {
						*buf = &x1.I
						return
					}
					if path[2] == "I8" {
						*buf = &x1.I8
						return
					}
					if path[2] == "I16" {
						*buf = &x1.I16
						return
					}
					if path[2] == "I32" {
						*buf = &x1.I32
						return
					}
					if path[2] == "I64" {
						*buf = &x1.I64
						return
					}
					if path[2] == "U" {
						*buf = &x1.U
						return
					}
					if path[2] == "U8" {
						*buf = &x1.U8
						return
					}
					if path[2] == "U16" {
						*buf = &x1.U16
						return
					}
					if path[2] == "U32" {
						*buf = &x1.U32
						return
					}
					if path[2] == "U64" {
						*buf = &x1.U64
						return
					}
					if path[2] == "F" {
						*buf = &x1.F
						return
					}
					if path[2] == "D" {
						*buf = &x1.D
						return
					}
				}
				*buf = &x1
			}
			*buf = &x.FloatPtrStructMap
			return
		}
		if path[0] == "FloatPtrStructPtrMap" {
			x0 := x.FloatPtrStructPtrMap
			_ = x0
			if len(path) > 1 {
				var k float64
				t78, err78 := strconv.ParseFloat(path[1], 0)
				if err78 != nil {
					return err78
				}
				k = float64(t78)
				x1 := (x0)[&k]
				_ = x1
				if len(path) > 2 {
					if x1 == nil {
						return
					}
					if path[2] == "A" {
						*buf = &x1.A
						return
					}
					if path[2] == "S" {
						*buf = &x1.S
						return
					}
					if path[2] == "B" {
						*buf = &x1.B
						return
					}
					if path[2] == "I" {
						*buf = &x1.I
						return
					}
					if path[2] == "I8" {
						*buf = &x1.I8
						return
					}
					if path[2] == "I16" {
						*buf = &x1.I16
						return
					}
					if path[2] == "I32" {
						*buf = &x1.I32
						return
					}
					if path[2] == "I64" {
						*buf = &x1.I64
						return
					}
					if path[2] == "U" {
						*buf = &x1.U
						return
					}
					if path[2] == "U8" {
						*buf = &x1.U8
						return
					}
					if path[2] == "U16" {
						*buf = &x1.U16
						return
					}
					if path[2] == "U32" {
						*buf = &x1.U32
						return
					}
					if path[2] == "U64" {
						*buf = &x1.U64
						return
					}
					if path[2] == "F" {
						*buf = &x1.F
						return
					}
					if path[2] == "D" {
						*buf = &x1.D
						return
					}
				}
				*buf = &x1
			}
			*buf = &x.FloatPtrStructPtrMap
			return
		}
		if path[0] == "FloatPtrStructPtrMapPtr" {
			x0 := x.FloatPtrStructPtrMapPtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var k float64
				t79, err79 := strconv.ParseFloat(path[1], 0)
				if err79 != nil {
					return err79
				}
				k = float64(t79)
				x1 := (*x0)[&k]
				_ = x1
				if len(path) > 2 {
					if x1 == nil {
						return
					}
					if path[2] == "A" {
						*buf = &x1.A
						return
					}
					if path[2] == "S" {
						*buf = &x1.S
						return
					}
					if path[2] == "B" {
						*buf = &x1.B
						return
					}
					if path[2] == "I" {
						*buf = &x1.I
						return
					}
					if path[2] == "I8" {
						*buf = &x1.I8
						return
					}
					if path[2] == "I16" {
						*buf = &x1.I16
						return
					}
					if path[2] == "I32" {
						*buf = &x1.I32
						return
					}
					if path[2] == "I64" {
						*buf = &x1.I64
						return
					}
					if path[2] == "U" {
						*buf = &x1.U
						return
					}
					if path[2] == "U8" {
						*buf = &x1.U8
						return
					}
					if path[2] == "U16" {
						*buf = &x1.U16
						return
					}
					if path[2] == "U32" {
						*buf = &x1.U32
						return
					}
					if path[2] == "U64" {
						*buf = &x1.U64
						return
					}
					if path[2] == "F" {
						*buf = &x1.F
						return
					}
					if path[2] == "D" {
						*buf = &x1.D
						return
					}
				}
				*buf = &x1
			}
			*buf = &x.FloatPtrStructPtrMapPtr
			return
		}
		if path[0] == "NestedStruct" {
			x0 := &x.NestedStruct
			_ = x0
			if len(path) > 1 {
				if path[1] == "A" {
					*buf = &x0.A
					return
				}
				if path[1] == "S" {
					*buf = &x0.S
					return
				}
				if path[1] == "B" {
					*buf = &x0.B
					return
				}
				if path[1] == "I" {
					*buf = &x0.I
					return
				}
				if path[1] == "I8" {
					*buf = &x0.I8
					return
				}
				if path[1] == "I16" {
					*buf = &x0.I16
					return
				}
				if path[1] == "I32" {
					*buf = &x0.I32
					return
				}
				if path[1] == "I64" {
					*buf = &x0.I64
					return
				}
				if path[1] == "U" {
					*buf = &x0.U
					return
				}
				if path[1] == "U8" {
					*buf = &x0.U8
					return
				}
				if path[1] == "U16" {
					*buf = &x0.U16
					return
				}
				if path[1] == "U32" {
					*buf = &x0.U32
					return
				}
				if path[1] == "U64" {
					*buf = &x0.U64
					return
				}
				if path[1] == "F" {
					*buf = &x0.F
					return
				}
				if path[1] == "D" {
					*buf = &x0.D
					return
				}
			}
			*buf = &x.NestedStruct
			return
		}
		if path[0] == "NestedStructPtr" {
			x0 := x.NestedStructPtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if path[1] == "A" {
					*buf = &x0.A
					return
				}
				if path[1] == "S" {
					*buf = &x0.S
					return
				}
				if path[1] == "B" {
					*buf = &x0.B
					return
				}
				if path[1] == "I" {
					*buf = &x0.I
					return
				}
				if path[1] == "I8" {
					*buf = &x0.I8
					return
				}
				if path[1] == "I16" {
					*buf = &x0.I16
					return
				}
				if path[1] == "I32" {
					*buf = &x0.I32
					return
				}
				if path[1] == "I64" {
					*buf = &x0.I64
					return
				}
				if path[1] == "U" {
					*buf = &x0.U
					return
				}
				if path[1] == "U8" {
					*buf = &x0.U8
					return
				}
				if path[1] == "U16" {
					*buf = &x0.U16
					return
				}
				if path[1] == "U32" {
					*buf = &x0.U32
					return
				}
				if path[1] == "U64" {
					*buf = &x0.U64
					return
				}
				if path[1] == "F" {
					*buf = &x0.F
					return
				}
				if path[1] == "D" {
					*buf = &x0.D
					return
				}
			}
			*buf = &x.NestedStructPtr
			return
		}
	}
	return
}

func (i6 TestObject1Inspector) Compare(src any, cond inspector.Op, right string, result *bool, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *testobj.TestObject1
	_ = x
	if p, ok := src.(**testobj.TestObject1); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestObject1); ok {
		x = p
	} else if v, ok := src.(testobj.TestObject1); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
		if path[0] == "IntSlice" {
			x0 := x.IntSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t80, err80 := strconv.ParseInt(path[1], 0, 0)
				if err80 != nil {
					return err80
				}
				i = int(t80)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					var rightExact int32
					t81, err81 := strconv.ParseInt(right, 0, 0)
					if err81 != nil {
						return err81
					}
					rightExact = int32(t81)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "IntPtrSlice" {
			x0 := x.IntPtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t82, err82 := strconv.ParseInt(path[1], 0, 0)
				if err82 != nil {
					return err82
				}
				i = int(t82)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "IntSlicePtr" {
			x0 := x.IntSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t83, err83 := strconv.ParseInt(path[1], 0, 0)
				if err83 != nil {
					return err83
				}
				i = int(t83)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					var rightExact int32
					t84, err84 := strconv.ParseInt(right, 0, 0)
					if err84 != nil {
						return err84
					}
					rightExact = int32(t84)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "IntPtrSlicePtr" {
			x0 := x.IntPtrSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t85, err85 := strconv.ParseInt(path[1], 0, 0)
				if err85 != nil {
					return err85
				}
				i = int(t85)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "ByteSlice" {
			var rightExact []byte
			rightExact = byteconv.S2B(right)

			if cond == inspector.OpEq {
				*result = bytes.Equal(x.ByteSlice, rightExact)
			} else {
				*result = !bytes.Equal(x.ByteSlice, rightExact)
			}
			return
		}
		if path[0] == "BytePtrSlice" {
			x0 := x.BytePtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t87, err87 := strconv.ParseInt(path[1], 0, 0)
				if err87 != nil {
					return err87
				}
				i = int(t87)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "ByteSlicePtr" {
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x.ByteSlicePtr == nil
				} else {
					*result = x.ByteSlicePtr != nil
				}
				return
			}
			return
		}
		if path[0] == "BytePtrSlicePtr" {
			x0 := x.BytePtrSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t88, err88 := strconv.ParseInt(path[1], 0, 0)
				if err88 != nil {
					return err88
				}
				i = int(t88)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "FloatSlice" {
			x0 := x.FloatSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t89, err89 := strconv.ParseInt(path[1], 0, 0)
				if err89 != nil {
					return err89
				}
				i = int(t89)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					var rightExact float32
					t90, err90 := strconv.ParseFloat(right, 0)
					if err90 != nil {
						return err90
					}
					rightExact = float32(t90)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "FloatPtrSlice" {
			x0 := x.FloatPtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t91, err91 := strconv.ParseInt(path[1], 0, 0)
				if err91 != nil {
					return err91
				}
				i = int(t91)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "FloatSlicePtr" {
			x0 := x.FloatSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t92, err92 := strconv.ParseInt(path[1], 0, 0)
				if err92 != nil {
					return err92
				}
				i = int(t92)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					var rightExact float32
					t93, err93 := strconv.ParseFloat(right, 0)
					if err93 != nil {
						return err93
					}
					rightExact = float32(t93)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "FloatPtrSlicePtr" {
			x0 := x.FloatPtrSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t94, err94 := strconv.ParseInt(path[1], 0, 0)
				if err94 != nil {
					return err94
				}
				i = int(t94)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "StructSlice" {
			x0 := x.StructSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t95, err95 := strconv.ParseInt(path[1], 0, 0)
				if err95 != nil {
					return err95
				}
				i = int(t95)
				if len(x0) > i {
					x1 := &(x0)[i]
					_ = x1
					if len(path) > 2 {
						if path[2] == "A" {
							var rightExact byte
							t96 := byteconv.S2B(right)
							if len(t96) > 0 {
								rightExact = t96[0]
							}

							switch cond {
							case inspector.OpEq:
								*result = x1.A == rightExact
							case inspector.OpNq:
								*result = x1.A != rightExact
							case inspector.OpGt:
								*result = x1.A > rightExact
							case inspector.OpGtq:
								*result = x1.A >= rightExact
							case inspector.OpLt:
								*result = x1.A < rightExact
							case inspector.OpLtq:
								*result = x1.A <= rightExact
							}
							return
						}
						if path[2] == "S" {
							var rightExact string
							rightExact = right

							switch cond {
							case inspector.OpEq:
								*result = x1.S == rightExact
							case inspector.OpNq:
								*result = x1.S != rightExact
							case inspector.OpGt:
								*result = x1.S > rightExact
							case inspector.OpGtq:
								*result = x1.S >= rightExact
							case inspector.OpLt:
								*result = x1.S < rightExact
							case inspector.OpLtq:
								*result = x1.S <= rightExact
							}
							return
						}
						if path[2] == "B" {
							var rightExact []byte
							rightExact = byteconv.S2B(right)

							if cond == inspector.OpEq {
								*result = bytes.Equal(x1.B, rightExact)
							} else {
								*result = !bytes.Equal(x1.B, rightExact)
							}
							return
						}
						if path[2] == "I" {
							var rightExact int
							t99, err99 := strconv.ParseInt(right, 0, 0)
							if err99 != nil {
								return err99
							}
							rightExact = int(t99)
							switch cond {
							case inspector.OpEq:
								*result = x1.I == rightExact
							case inspector.OpNq:
								*result = x1.I != rightExact
							case inspector.OpGt:
								*result = x1.I > rightExact
							case inspector.OpGtq:
								*result = x1.I >= rightExact
							case inspector.OpLt:
								*result = x1.I < rightExact
							case inspector.OpLtq:
								*result = x1.I <= rightExact
							}
							return
						}
						if path[2] == "I8" {
							var rightExact int8
							t100, err100 := strconv.ParseInt(right, 0, 0)
							if err100 != nil {
								return err100
							}
							rightExact = int8(t100)
							switch cond {
							case inspector.OpEq:
								*result = x1.I8 == rightExact
							case inspector.OpNq:
								*result = x1.I8 != rightExact
							case inspector.OpGt:
								*result = x1.I8 > rightExact
							case inspector.OpGtq:
								*result = x1.I8 >= rightExact
							case inspector.OpLt:
								*result = x1.I8 < rightExact
							case inspector.OpLtq:
								*result = x1.I8 <= rightExact
							}
							return
						}
						if path[2] == "I16" {
							var rightExact int16
							t101, err101 := strconv.ParseInt(right, 0, 0)
							if err101 != nil {
								return err101
							}
							rightExact = int16(t101)
							switch cond {
							case inspector.OpEq:
								*result = x1.I16 == rightExact
							case inspector.OpNq:
								*result = x1.I16 != rightExact
							case inspector.OpGt:
								*result = x1.I16 > rightExact
							case inspector.OpGtq:
								*result = x1.I16 >= rightExact
							case inspector.OpLt:
								*result = x1.I16 < rightExact
							case inspector.OpLtq:
								*result = x1.I16 <= rightExact
							}
							return
						}
						if path[2] == "I32" {
							var rightExact int32
							t102, err102 := strconv.ParseInt(right, 0, 0)
							if err102 != nil {
								return err102
							}
							rightExact = int32(t102)
							switch cond {
							case inspector.OpEq:
								*result = x1.I32 == rightExact
							case inspector.OpNq:
								*result = x1.I32 != rightExact
							case inspector.OpGt:
								*result = x1.I32 > rightExact
							case inspector.OpGtq:
								*result = x1.I32 >= rightExact
							case inspector.OpLt:
								*result = x1.I32 < rightExact
							case inspector.OpLtq:
								*result = x1.I32 <= rightExact
							}
							return
						}
						if path[2] == "I64" {
							var rightExact int64
							t103, err103 := strconv.ParseInt(right, 0, 0)
							if err103 != nil {
								return err103
							}
							rightExact = int64(t103)
							switch cond {
							case inspector.OpEq:
								*result = x1.I64 == rightExact
							case inspector.OpNq:
								*result = x1.I64 != rightExact
							case inspector.OpGt:
								*result = x1.I64 > rightExact
							case inspector.OpGtq:
								*result = x1.I64 >= rightExact
							case inspector.OpLt:
								*result = x1.I64 < rightExact
							case inspector.OpLtq:
								*result = x1.I64 <= rightExact
							}
							return
						}
						if path[2] == "U" {
							var rightExact uint
							t104, err104 := strconv.ParseUint(right, 0, 0)
							if err104 != nil {
								return err104
							}
							rightExact = uint(t104)
							switch cond {
							case inspector.OpEq:
								*result = x1.U == rightExact
							case inspector.OpNq:
								*result = x1.U != rightExact
							case inspector.OpGt:
								*result = x1.U > rightExact
							case inspector.OpGtq:
								*result = x1.U >= rightExact
							case inspector.OpLt:
								*result = x1.U < rightExact
							case inspector.OpLtq:
								*result = x1.U <= rightExact
							}
							return
						}
						if path[2] == "U8" {
							var rightExact uint8
							t105, err105 := strconv.ParseUint(right, 0, 0)
							if err105 != nil {
								return err105
							}
							rightExact = uint8(t105)
							switch cond {
							case inspector.OpEq:
								*result = x1.U8 == rightExact
							case inspector.OpNq:
								*result = x1.U8 != rightExact
							case inspector.OpGt:
								*result = x1.U8 > rightExact
							case inspector.OpGtq:
								*result = x1.U8 >= rightExact
							case inspector.OpLt:
								*result = x1.U8 < rightExact
							case inspector.OpLtq:
								*result = x1.U8 <= rightExact
							}
							return
						}
						if path[2] == "U16" {
							var rightExact uint16
							t106, err106 := strconv.ParseUint(right, 0, 0)
							if err106 != nil {
								return err106
							}
							rightExact = uint16(t106)
							switch cond {
							case inspector.OpEq:
								*result = x1.U16 == rightExact
							case inspector.OpNq:
								*result = x1.U16 != rightExact
							case inspector.OpGt:
								*result = x1.U16 > rightExact
							case inspector.OpGtq:
								*result = x1.U16 >= rightExact
							case inspector.OpLt:
								*result = x1.U16 < rightExact
							case inspector.OpLtq:
								*result = x1.U16 <= rightExact
							}
							return
						}
						if path[2] == "U32" {
							var rightExact uint32
							t107, err107 := strconv.ParseUint(right, 0, 0)
							if err107 != nil {
								return err107
							}
							rightExact = uint32(t107)
							switch cond {
							case inspector.OpEq:
								*result = x1.U32 == rightExact
							case inspector.OpNq:
								*result = x1.U32 != rightExact
							case inspector.OpGt:
								*result = x1.U32 > rightExact
							case inspector.OpGtq:
								*result = x1.U32 >= rightExact
							case inspector.OpLt:
								*result = x1.U32 < rightExact
							case inspector.OpLtq:
								*result = x1.U32 <= rightExact
							}
							return
						}
						if path[2] == "U64" {
							var rightExact uint64
							t108, err108 := strconv.ParseUint(right, 0, 0)
							if err108 != nil {
								return err108
							}
							rightExact = uint64(t108)
							switch cond {
							case inspector.OpEq:
								*result = x1.U64 == rightExact
							case inspector.OpNq:
								*result = x1.U64 != rightExact
							case inspector.OpGt:
								*result = x1.U64 > rightExact
							case inspector.OpGtq:
								*result = x1.U64 >= rightExact
							case inspector.OpLt:
								*result = x1.U64 < rightExact
							case inspector.OpLtq:
								*result = x1.U64 <= rightExact
							}
							return
						}
						if path[2] == "F" {
							var rightExact float32
							t109, err109 := strconv.ParseFloat(right, 0)
							if err109 != nil {
								return err109
							}
							rightExact = float32(t109)
							switch cond {
							case inspector.OpEq:
								*result = x1.F == rightExact
							case inspector.OpNq:
								*result = x1.F != rightExact
							case inspector.OpGt:
								*result = x1.F > rightExact
							case inspector.OpGtq:
								*result = x1.F >= rightExact
							case inspector.OpLt:
								*result = x1.F < rightExact
							case inspector.OpLtq:
								*result = x1.F <= rightExact
							}
							return
						}
						if path[2] == "D" {
							var rightExact float64
							t110, err110 := strconv.ParseFloat(right, 0)
							if err110 != nil {
								return err110
							}
							rightExact = float64(t110)
							switch cond {
							case inspector.OpEq:
								*result = x1.D == rightExact
							case inspector.OpNq:
								*result = x1.D != rightExact
							case inspector.OpGt:
								*result = x1.D > rightExact
							case inspector.OpGtq:
								*result = x1.D >= rightExact
							case inspector.OpLt:
								*result = x1.D < rightExact
							case inspector.OpLtq:
								*result = x1.D <= rightExact
							}
							return
						}
					}
				}
			}
		}
		if path[0] == "StructPtrSlice" {
			x0 := x.StructPtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t111, err111 := strconv.ParseInt(path[1], 0, 0)
				if err111 != nil {
					return err111
				}
				i = int(t111)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return
						}
						if path[2] == "A" {
							var rightExact byte
							t112 := byteconv.S2B(right)
							if len(t112) > 0 {
								rightExact = t112[0]
							}

							switch cond {
							case inspector.OpEq:
								*result = x1.A == rightExact
							case inspector.OpNq:
								*result = x1.A != rightExact
							case inspector.OpGt:
								*result = x1.A > rightExact
							case inspector.OpGtq:
								*result = x1.A >= rightExact
							case inspector.OpLt:
								*result = x1.A < rightExact
							case inspector.OpLtq:
								*result = x1.A <= rightExact
							}
							return
						}
						if path[2] == "S" {
							var rightExact string
							rightExact = right

							switch cond {
							case inspector.OpEq:
								*result = x1.S == rightExact
							case inspector.OpNq:
								*result = x1.S != rightExact
							case inspector.OpGt:
								*result = x1.S > rightExact
							case inspector.OpGtq:
								*result = x1.S >= rightExact
							case inspector.OpLt:
								*result = x1.S < rightExact
							case inspector.OpLtq:
								*result = x1.S <= rightExact
							}
							return
						}
						if path[2] == "B" {
							var rightExact []byte
							rightExact = byteconv.S2B(right)

							if cond == inspector.OpEq {
								*result = bytes.Equal(x1.B, rightExact)
							} else {
								*result = !bytes.Equal(x1.B, rightExact)
							}
							return
						}
						if path[2] == "I" {
							var rightExact int
							t115, err115 := strconv.ParseInt(right, 0, 0)
							if err115 != nil {
								return err115
							}
							rightExact = int(t115)
							switch cond {
							case inspector.OpEq:
								*result = x1.I == rightExact
							case inspector.OpNq:
								*result = x1.I != rightExact
							case inspector.OpGt:
								*result = x1.I > rightExact
							case inspector.OpGtq:
								*result = x1.I >= rightExact
							case inspector.OpLt:
								*result = x1.I < rightExact
							case inspector.OpLtq:
								*result = x1.I <= rightExact
							}
							return
						}
						if path[2] == "I8" {
							var rightExact int8
							t116, err116 := strconv.ParseInt(right, 0, 0)
							if err116 != nil {
								return err116
							}
							rightExact = int8(t116)
							switch cond {
							case inspector.OpEq:
								*result = x1.I8 == rightExact
							case inspector.OpNq:
								*result = x1.I8 != rightExact
							case inspector.OpGt:
								*result = x1.I8 > rightExact
							case inspector.OpGtq:
								*result = x1.I8 >= rightExact
							case inspector.OpLt:
								*result = x1.I8 < rightExact
							case inspector.OpLtq:
								*result = x1.I8 <= rightExact
							}
							return
						}
						if path[2] == "I16" {
							var rightExact int16
							t117, err117 := strconv.ParseInt(right, 0, 0)
							if err117 != nil {
								return err117
							}
							rightExact = int16(t117)
							switch cond {
							case inspector.OpEq:
								*result = x1.I16 == rightExact
							case inspector.OpNq:
								*result = x1.I16 != rightExact
							case inspector.OpGt:
								*result = x1.I16 > rightExact
							case inspector.OpGtq:
								*result = x1.I16 >= rightExact
							case inspector.OpLt:
								*result = x1.I16 < rightExact
							case inspector.OpLtq:
								*result = x1.I16 <= rightExact
							}
							return
						}
						if path[2] == "I32" {
							var rightExact int32
							t118, err118 := strconv.ParseInt(right, 0, 0)
							if err118 != nil {
								return err118
							}
							rightExact = int32(t118)
							switch cond {
							case inspector.OpEq:
								*result = x1.I32 == rightExact
							case inspector.OpNq:
								*result = x1.I32 != rightExact
							case inspector.OpGt:
								*result = x1.I32 > rightExact
							case inspector.OpGtq:
								*result = x1.I32 >= rightExact
							case inspector.OpLt:
								*result = x1.I32 < rightExact
							case inspector.OpLtq:
								*result = x1.I32 <= rightExact
							}
							return
						}
						if path[2] == "I64" {
							var rightExact int64
							t119, err119 := strconv.ParseInt(right, 0, 0)
							if err119 != nil {
								return err119
							}
							rightExact = int64(t119)
							switch cond {
							case inspector.OpEq:
								*result = x1.I64 == rightExact
							case inspector.OpNq:
								*result = x1.I64 != rightExact
							case inspector.OpGt:
								*result = x1.I64 > rightExact
							case inspector.OpGtq:
								*result = x1.I64 >= rightExact
							case inspector.OpLt:
								*result = x1.I64 < rightExact
							case inspector.OpLtq:
								*result = x1.I64 <= rightExact
							}
							return
						}
						if path[2] == "U" {
							var rightExact uint
							t120, err120 := strconv.ParseUint(right, 0, 0)
							if err120 != nil {
								return err120
							}
							rightExact = uint(t120)
							switch cond {
							case inspector.OpEq:
								*result = x1.U == rightExact
							case inspector.OpNq:
								*result = x1.U != rightExact
							case inspector.OpGt:
								*result = x1.U > rightExact
							case inspector.OpGtq:
								*result = x1.U >= rightExact
							case inspector.OpLt:
								*result = x1.U < rightExact
							case inspector.OpLtq:
								*result = x1.U <= rightExact
							}
							return
						}
						if path[2] == "U8" {
							var rightExact uint8
							t121, err121 := strconv.ParseUint(right, 0, 0)
							if err121 != nil {
								return err121
							}
							rightExact = uint8(t121)
							switch cond {
							case inspector.OpEq:
								*result = x1.U8 == rightExact
							case inspector.OpNq:
								*result = x1.U8 != rightExact
							case inspector.OpGt:
								*result = x1.U8 > rightExact
							case inspector.OpGtq:
								*result = x1.U8 >= rightExact
							case inspector.OpLt:
								*result = x1.U8 < rightExact
							case inspector.OpLtq:
								*result = x1.U8 <= rightExact
							}
							return
						}
						if path[2] == "U16" {
							var rightExact uint16
							t122, err122 := strconv.ParseUint(right, 0, 0)
							if err122 != nil {
								return err122
							}
							rightExact = uint16(t122)
							switch cond {
							case inspector.OpEq:
								*result = x1.U16 == rightExact
							case inspector.OpNq:
								*result = x1.U16 != rightExact
							case inspector.OpGt:
								*result = x1.U16 > rightExact
							case inspector.OpGtq:
								*result = x1.U16 >= rightExact
							case inspector.OpLt:
								*result = x1.U16 < rightExact
							case inspector.OpLtq:
								*result = x1.U16 <= rightExact
							}
							return
						}
						if path[2] == "U32" {
							var rightExact uint32
							t123, err123 := strconv.ParseUint(right, 0, 0)
							if err123 != nil {
								return err123
							}
							rightExact = uint32(t123)
							switch cond {
							case inspector.OpEq:
								*result = x1.U32 == rightExact
							case inspector.OpNq:
								*result = x1.U32 != rightExact
							case inspector.OpGt:
								*result = x1.U32 > rightExact
							case inspector.OpGtq:
								*result = x1.U32 >= rightExact
							case inspector.OpLt:
								*result = x1.U32 < rightExact
							case inspector.OpLtq:
								*result = x1.U32 <= rightExact
							}
							return
						}
						if path[2] == "U64" {
							var rightExact uint64
							t124, err124 := strconv.ParseUint(right, 0, 0)
							if err124 != nil {
								return err124
							}
							rightExact = uint64(t124)
							switch cond {
							case inspector.OpEq:
								*result = x1.U64 == rightExact
							case inspector.OpNq:
								*result = x1.U64 != rightExact
							case inspector.OpGt:
								*result = x1.U64 > rightExact
							case inspector.OpGtq:
								*result = x1.U64 >= rightExact
							case inspector.OpLt:
								*result = x1.U64 < rightExact
							case inspector.OpLtq:
								*result = x1.U64 <= rightExact
							}
							return
						}
						if path[2] == "F" {
							var rightExact float32
							t125, err125 := strconv.ParseFloat(right, 0)
							if err125 != nil {
								return err125
							}
							rightExact = float32(t125)
							switch cond {
							case inspector.OpEq:
								*result = x1.F == rightExact
							case inspector.OpNq:
								*result = x1.F != rightExact
							case inspector.OpGt:
								*result = x1.F > rightExact
							case inspector.OpGtq:
								*result = x1.F >= rightExact
							case inspector.OpLt:
								*result = x1.F < rightExact
							case inspector.OpLtq:
								*result = x1.F <= rightExact
							}
							return
						}
						if path[2] == "D" {
							var rightExact float64
							t126, err126 := strconv.ParseFloat(right, 0)
							if err126 != nil {
								return err126
							}
							rightExact = float64(t126)
							switch cond {
							case inspector.OpEq:
								*result = x1.D == rightExact
							case inspector.OpNq:
								*result = x1.D != rightExact
							case inspector.OpGt:
								*result = x1.D > rightExact
							case inspector.OpGtq:
								*result = x1.D >= rightExact
							case inspector.OpLt:
								*result = x1.D < rightExact
							case inspector.OpLtq:
								*result = x1.D <= rightExact
							}
							return
						}
					}
				}
			}
		}
		if path[0] == "StructSlicePtr" {
			x0 := x.StructSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t127, err127 := strconv.ParseInt(path[1], 0, 0)
				if err127 != nil {
					return err127
				}
				i = int(t127)
				if len(*x0) > i {
					x1 := &(*x0)[i]
					_ = x1
					if len(path) > 2 {
						if path[2] == "A" {
							var rightExact byte
							t128 := byteconv.S2B(right)
							if len(t128) > 0 {
								rightExact = t128[0]
							}

							switch cond {
							case inspector.OpEq:
								*result = x1.A == rightExact
							case inspector.OpNq:
								*result = x1.A != rightExact
							case inspector.OpGt:
								*result = x1.A > rightExact
							case inspector.OpGtq:
								*result = x1.A >= rightExact
							case inspector.OpLt:
								*result = x1.A < rightExact
							case inspector.OpLtq:
								*result = x1.A <= rightExact
							}
							return
						}
						if path[2] == "S" {
							var rightExact string
							rightExact = right

							switch cond {
							case inspector.OpEq:
								*result = x1.S == rightExact
							case inspector.OpNq:
								*result = x1.S != rightExact
							case inspector.OpGt:
								*result = x1.S > rightExact
							case inspector.OpGtq:
								*result = x1.S >= rightExact
							case inspector.OpLt:
								*result = x1.S < rightExact
							case inspector.OpLtq:
								*result = x1.S <= rightExact
							}
							return
						}
						if path[2] == "B" {
							var rightExact []byte
							rightExact = byteconv.S2B(right)

							if cond == inspector.OpEq {
								*result = bytes.Equal(x1.B, rightExact)
							} else {
								*result = !bytes.Equal(x1.B, rightExact)
							}
							return
						}
						if path[2] == "I" {
							var rightExact int
							t131, err131 := strconv.ParseInt(right, 0, 0)
							if err131 != nil {
								return err131
							}
							rightExact = int(t131)
							switch cond {
							case inspector.OpEq:
								*result = x1.I == rightExact
							case inspector.OpNq:
								*result = x1.I != rightExact
							case inspector.OpGt:
								*result = x1.I > rightExact
							case inspector.OpGtq:
								*result = x1.I >= rightExact
							case inspector.OpLt:
								*result = x1.I < rightExact
							case inspector.OpLtq:
								*result = x1.I <= rightExact
							}
							return
						}
						if path[2] == "I8" {
							var rightExact int8
							t132, err132 := strconv.ParseInt(right, 0, 0)
							if err132 != nil {
								return err132
							}
							rightExact = int8(t132)
							switch cond {
							case inspector.OpEq:
								*result = x1.I8 == rightExact
							case inspector.OpNq:
								*result = x1.I8 != rightExact
							case inspector.OpGt:
								*result = x1.I8 > rightExact
							case inspector.OpGtq:
								*result = x1.I8 >= rightExact
							case inspector.OpLt:
								*result = x1.I8 < rightExact
							case inspector.OpLtq:
								*result = x1.I8 <= rightExact
							}
							return
						}
						if path[2] == "I16" {
							var rightExact int16
							t133, err133 := strconv.ParseInt(right, 0, 0)
							if err133 != nil {
								return err133
							}
							rightExact = int16(t133)
							switch cond {
							case inspector.OpEq:
								*result = x1.I16 == rightExact
							case inspector.OpNq:
								*result = x1.I16 != rightExact
							case inspector.OpGt:
								*result = x1.I16 > rightExact
							case inspector.OpGtq:
								*result = x1.I16 >= rightExact
							case inspector.OpLt:
								*result = x1.I16 < rightExact
							case inspector.OpLtq:
								*result = x1.I16 <= rightExact
							}
							return
						}
						if path[2] == "I32" {
							var rightExact int32
							t134, err134 := strconv.ParseInt(right, 0, 0)
							if err134 != nil {
								return err134
							}
							rightExact = int32(t134)
							switch cond {
							case inspector.OpEq:
								*result = x1.I32 == rightExact
							case inspector.OpNq:
								*result = x1.I32 != rightExact
							case inspector.OpGt:
								*result = x1.I32 > rightExact
							case inspector.OpGtq:
								*result = x1.I32 >= rightExact
							case inspector.OpLt:
								*result = x1.I32 < rightExact
							case inspector.OpLtq:
								*result = x1.I32 <= rightExact
							}
							return
						}
						if path[2] == "I64" {
							var rightExact int64
							t135, err135 := strconv.ParseInt(right, 0, 0)
							if err135 != nil {
								return err135
							}
							rightExact = int64(t135)
							switch cond {
							case inspector.OpEq:
								*result = x1.I64 == rightExact
							case inspector.OpNq:
								*result = x1.I64 != rightExact
							case inspector.OpGt:
								*result = x1.I64 > rightExact
							case inspector.OpGtq:
								*result = x1.I64 >= rightExact
							case inspector.OpLt:
								*result = x1.I64 < rightExact
							case inspector.OpLtq:
								*result = x1.I64 <= rightExact
							}
							return
						}
						if path[2] == "U" {
							var rightExact uint
							t136, err136 := strconv.ParseUint(right, 0, 0)
							if err136 != nil {
								return err136
							}
							rightExact = uint(t136)
							switch cond {
							case inspector.OpEq:
								*result = x1.U == rightExact
							case inspector.OpNq:
								*result = x1.U != rightExact
							case inspector.OpGt:
								*result = x1.U > rightExact
							case inspector.OpGtq:
								*result = x1.U >= rightExact
							case inspector.OpLt:
								*result = x1.U < rightExact
							case inspector.OpLtq:
								*result = x1.U <= rightExact
							}
							return
						}
						if path[2] == "U8" {
							var rightExact uint8
							t137, err137 := strconv.ParseUint(right, 0, 0)
							if err137 != nil {
								return err137
							}
							rightExact = uint8(t137)
							switch cond {
							case inspector.OpEq:
								*result = x1.U8 == rightExact
							case inspector.OpNq:
								*result = x1.U8 != rightExact
							case inspector.OpGt:
								*result = x1.U8 > rightExact
							case inspector.OpGtq:
								*result = x1.U8 >= rightExact
							case inspector.OpLt:
								*result = x1.U8 < rightExact
							case inspector.OpLtq:
								*result = x1.U8 <= rightExact
							}
							return
						}
						if path[2] == "U16" {
							var rightExact uint16
							t138, err138 := strconv.ParseUint(right, 0, 0)
							if err138 != nil {
								return err138
							}
							rightExact = uint16(t138)
							switch cond {
							case inspector.OpEq:
								*result = x1.U16 == rightExact
							case inspector.OpNq:
								*result = x1.U16 != rightExact
							case inspector.OpGt:
								*result = x1.U16 > rightExact
							case inspector.OpGtq:
								*result = x1.U16 >= rightExact
							case inspector.OpLt:
								*result = x1.U16 < rightExact
							case inspector.OpLtq:
								*result = x1.U16 <= rightExact
							}
							return
						}
						if path[2] == "U32" {
							var rightExact uint32
							t139, err139 := strconv.ParseUint(right, 0, 0)
							if err139 != nil {
								return err139
							}
							rightExact = uint32(t139)
							switch cond {
							case inspector.OpEq:
								*result = x1.U32 == rightExact
							case inspector.OpNq:
								*result = x1.U32 != rightExact
							case inspector.OpGt:
								*result = x1.U32 > rightExact
							case inspector.OpGtq:
								*result = x1.U32 >= rightExact
							case inspector.OpLt:
								*result = x1.U32 < rightExact
							case inspector.OpLtq:
								*result = x1.U32 <= rightExact
							}
							return
						}
						if path[2] == "U64" {
							var rightExact uint64
							t140, err140 := strconv.ParseUint(right, 0, 0)
							if err140 != nil {
								return err140
							}
							rightExact = uint64(t140)
							switch cond {
							case inspector.OpEq:
								*result = x1.U64 == rightExact
							case inspector.OpNq:
								*result = x1.U64 != rightExact
							case inspector.OpGt:
								*result = x1.U64 > rightExact
							case inspector.OpGtq:
								*result = x1.U64 >= rightExact
							case inspector.OpLt:
								*result = x1.U64 < rightExact
							case inspector.OpLtq:
								*result = x1.U64 <= rightExact
							}
							return
						}
						if path[2] == "F" {
							var rightExact float32
							t141, err141 := strconv.ParseFloat(right, 0)
							if err141 != nil {
								return err141
							}
							rightExact = float32(t141)
							switch cond {
							case inspector.OpEq:
								*result = x1.F == rightExact
							case inspector.OpNq:
								*result = x1.F != rightExact
							case inspector.OpGt:
								*result = x1.F > rightExact
							case inspector.OpGtq:
								*result = x1.F >= rightExact
							case inspector.OpLt:
								*result = x1.F < rightExact
							case inspector.OpLtq:
								*result = x1.F <= rightExact
							}
							return
						}
						if path[2] == "D" {
							var rightExact float64
							t142, err142 := strconv.ParseFloat(right, 0)
							if err142 != nil {
								return err142
							}
							rightExact = float64(t142)
							switch cond {
							case inspector.OpEq:
								*result = x1.D == rightExact
							case inspector.OpNq:
								*result = x1.D != rightExact
							case inspector.OpGt:
								*result = x1.D > rightExact
							case inspector.OpGtq:
								*result = x1.D >= rightExact
							case inspector.OpLt:
								*result = x1.D < rightExact
							case inspector.OpLtq:
								*result = x1.D <= rightExact
							}
							return
						}
					}
				}
			}
		}
		if path[0] == "StructPtrSlicePtr" {
			x0 := x.StructPtrSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t143, err143 := strconv.ParseInt(path[1], 0, 0)
				if err143 != nil {
					return err143
				}
				i = int(t143)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return
						}
						if path[2] == "A" {
							var rightExact byte
							t144 := byteconv.S2B(right)
							if len(t144) > 0 {
								rightExact = t144[0]
							}

							switch cond {
							case inspector.OpEq:
								*result = x1.A == rightExact
							case inspector.OpNq:
								*result = x1.A != rightExact
							case inspector.OpGt:
								*result = x1.A > rightExact
							case inspector.OpGtq:
								*result = x1.A >= rightExact
							case inspector.OpLt:
								*result = x1.A < rightExact
							case inspector.OpLtq:
								*result = x1.A <= rightExact
							}
							return
						}
						if path[2] == "S" {
							var rightExact string
							rightExact = right

							switch cond {
							case inspector.OpEq:
								*result = x1.S == rightExact
							case inspector.OpNq:
								*result = x1.S != rightExact
							case inspector.OpGt:
								*result = x1.S > rightExact
							case inspector.OpGtq:
								*result = x1.S >= rightExact
							case inspector.OpLt:
								*result = x1.S < rightExact
							case inspector.OpLtq:
								*result = x1.S <= rightExact
							}
							return
						}
						if path[2] == "B" {
							var rightExact []byte
							rightExact = byteconv.S2B(right)

							if cond == inspector.OpEq {
								*result = bytes.Equal(x1.B, rightExact)
							} else {
								*result = !bytes.Equal(x1.B, rightExact)
							}
							return
						}
						if path[2] == "I" {
							var rightExact int
							t147, err147 := strconv.ParseInt(right, 0, 0)
							if err147 != nil {
								return err147
							}
							rightExact = int(t147)
							switch cond {
							case inspector.OpEq:
								*result = x1.I == rightExact
							case inspector.OpNq:
								*result = x1.I != rightExact
							case inspector.OpGt:
								*result = x1.I > rightExact
							case inspector.OpGtq:
								*result = x1.I >= rightExact
							case inspector.OpLt:
								*result = x1.I < rightExact
							case inspector.OpLtq:
								*result = x1.I <= rightExact
							}
							return
						}
						if path[2] == "I8" {
							var rightExact int8
							t148, err148 := strconv.ParseInt(right, 0, 0)
							if err148 != nil {
								return err148
							}
							rightExact = int8(t148)
							switch cond {
							case inspector.OpEq:
								*result = x1.I8 == rightExact
							case inspector.OpNq:
								*result = x1.I8 != rightExact
							case inspector.OpGt:
								*result = x1.I8 > rightExact
							case inspector.OpGtq:
								*result = x1.I8 >= rightExact
							case inspector.OpLt:
								*result = x1.I8 < rightExact
							case inspector.OpLtq:
								*result = x1.I8 <= rightExact
							}
							return
						}
						if path[2] == "I16" {
							var rightExact int16
							t149, err149 := strconv.ParseInt(right, 0, 0)
							if err149 != nil {
								return err149
							}
							rightExact = int16(t149)
							switch cond {
							case inspector.OpEq:
								*result = x1.I16 == rightExact
							case inspector.OpNq:
								*result = x1.I16 != rightExact
							case inspector.OpGt:
								*result = x1.I16 > rightExact
							case inspector.OpGtq:
								*result = x1.I16 >= rightExact
							case inspector.OpLt:
								*result = x1.I16 < rightExact
							case inspector.OpLtq:
								*result = x1.I16 <= rightExact
							}
							return
						}
						if path[2] == "I32" {
							var rightExact int32
							t150, err150 := strconv.ParseInt(right, 0, 0)
							if err150 != nil {
								return err150
							}
							rightExact = int32(t150)
							switch cond {
							case inspector.OpEq:
								*result = x1.I32 == rightExact
							case inspector.OpNq:
								*result = x1.I32 != rightExact
							case inspector.OpGt:
								*result = x1.I32 > rightExact
							case inspector.OpGtq:
								*result = x1.I32 >= rightExact
							case inspector.OpLt:
								*result = x1.I32 < rightExact
							case inspector.OpLtq:
								*result = x1.I32 <= rightExact
							}
							return
						}
						if path[2] == "I64" {
							var rightExact int64
							t151, err151 := strconv.ParseInt(right, 0, 0)
							if err151 != nil {
								return err151
							}
							rightExact = int64(t151)
							switch cond {
							case inspector.OpEq:
								*result = x1.I64 == rightExact
							case inspector.OpNq:
								*result = x1.I64 != rightExact
							case inspector.OpGt:
								*result = x1.I64 > rightExact
							case inspector.OpGtq:
								*result = x1.I64 >= rightExact
							case inspector.OpLt:
								*result = x1.I64 < rightExact
							case inspector.OpLtq:
								*result = x1.I64 <= rightExact
							}
							return
						}
						if path[2] == "U" {
							var rightExact uint
							t152, err152 := strconv.ParseUint(right, 0, 0)
							if err152 != nil {
								return err152
							}
							rightExact = uint(t152)
							switch cond {
							case inspector.OpEq:
								*result = x1.U == rightExact
							case inspector.OpNq:
								*result = x1.U != rightExact
							case inspector.OpGt:
								*result = x1.U > rightExact
							case inspector.OpGtq:
								*result = x1.U >= rightExact
							case inspector.OpLt:
								*result = x1.U < rightExact
							case inspector.OpLtq:
								*result = x1.U <= rightExact
							}
							return
						}
						if path[2] == "U8" {
							var rightExact uint8
							t153, err153 := strconv.ParseUint(right, 0, 0)
							if err153 != nil {
								return err153
							}
							rightExact = uint8(t153)
							switch cond {
							case inspector.OpEq:
								*result = x1.U8 == rightExact
							case inspector.OpNq:
								*result = x1.U8 != rightExact
							case inspector.OpGt:
								*result = x1.U8 > rightExact
							case inspector.OpGtq:
								*result = x1.U8 >= rightExact
							case inspector.OpLt:
								*result = x1.U8 < rightExact
							case inspector.OpLtq:
								*result = x1.U8 <= rightExact
							}
							return
						}
						if path[2] == "U16" {
							var rightExact uint16
							t154, err154 := strconv.ParseUint(right, 0, 0)
							if err154 != nil {
								return err154
							}
							rightExact = uint16(t154)
							switch cond {
							case inspector.OpEq:
								*result = x1.U16 == rightExact
							case inspector.OpNq:
								*result = x1.U16 != rightExact
							case inspector.OpGt:
								*result = x1.U16 > rightExact
							case inspector.OpGtq:
								*result = x1.U16 >= rightExact
							case inspector.OpLt:
								*result = x1.U16 < rightExact
							case inspector.OpLtq:
								*result = x1.U16 <= rightExact
							}
							return
						}
						if path[2] == "U32" {
							var rightExact uint32
							t155, err155 := strconv.ParseUint(right, 0, 0)
							if err155 != nil {
								return err155
							}
							rightExact = uint32(t155)
							switch cond {
							case inspector.OpEq:
								*result = x1.U32 == rightExact
							case inspector.OpNq:
								*result = x1.U32 != rightExact
							case inspector.OpGt:
								*result = x1.U32 > rightExact
							case inspector.OpGtq:
								*result = x1.U32 >= rightExact
							case inspector.OpLt:
								*result = x1.U32 < rightExact
							case inspector.OpLtq:
								*result = x1.U32 <= rightExact
							}
							return
						}
						if path[2] == "U64" {
							var rightExact uint64
							t156, err156 := strconv.ParseUint(right, 0, 0)
							if err156 != nil {
								return err156
							}
							rightExact = uint64(t156)
							switch cond {
							case inspector.OpEq:
								*result = x1.U64 == rightExact
							case inspector.OpNq:
								*result = x1.U64 != rightExact
							case inspector.OpGt:
								*result = x1.U64 > rightExact
							case inspector.OpGtq:
								*result = x1.U64 >= rightExact
							case inspector.OpLt:
								*result = x1.U64 < rightExact
							case inspector.OpLtq:
								*result = x1.U64 <= rightExact
							}
							return
						}
						if path[2] == "F" {
							var rightExact float32
							t157, err157 := strconv.ParseFloat(right, 0)
							if err157 != nil {
								return err157
							}
							rightExact = float32(t157)
							switch cond {
							case inspector.OpEq:
								*result = x1.F == rightExact
							case inspector.OpNq:
								*result = x1.F != rightExact
							case inspector.OpGt:
								*result = x1.F > rightExact
							case inspector.OpGtq:
								*result = x1.F >= rightExact
							case inspector.OpLt:
								*result = x1.F < rightExact
							case inspector.OpLtq:
								*result = x1.F <= rightExact
							}
							return
						}
						if path[2] == "D" {
							var rightExact float64
							t158, err158 := strconv.ParseFloat(right, 0)
							if err158 != nil {
								return err158
							}
							rightExact = float64(t158)
							switch cond {
							case inspector.OpEq:
								*result = x1.D == rightExact
							case inspector.OpNq:
								*result = x1.D != rightExact
							case inspector.OpGt:
								*result = x1.D > rightExact
							case inspector.OpGtq:
								*result = x1.D >= rightExact
							case inspector.OpLt:
								*result = x1.D < rightExact
							case inspector.OpLtq:
								*result = x1.D <= rightExact
							}
							return
						}
					}
				}
			}
		}
		if path[0] == "StructSliceLiteral" {
			x0 := x.StructSliceLiteral
			_ = x0
			if len(path) > 1 {
				var i int
				t159, err159 := strconv.ParseInt(path[1], 0, 0)
				if err159 != nil {
					return err159
				}
				i = int(t159)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return
						}
						if path[2] == "A" {
							var rightExact byte
							t160 := byteconv.S2B(right)
							if len(t160) > 0 {
								rightExact = t160[0]
							}

							switch cond {
							case inspector.OpEq:
								*result = x1.A == rightExact
							case inspector.OpNq:
								*result = x1.A != rightExact
							case inspector.OpGt:
								*result = x1.A > rightExact
							case inspector.OpGtq:
								*result = x1.A >= rightExact
							case inspector.OpLt:
								*result = x1.A < rightExact
							case inspector.OpLtq:
								*result = x1.A <= rightExact
							}
							return
						}
						if path[2] == "S" {
							var rightExact string
							rightExact = right

							switch cond {
							case inspector.OpEq:
								*result = x1.S == rightExact
							case inspector.OpNq:
								*result = x1.S != rightExact
							case inspector.OpGt:
								*result = x1.S > rightExact
							case inspector.OpGtq:
								*result = x1.S >= rightExact
							case inspector.OpLt:
								*result = x1.S < rightExact
							case inspector.OpLtq:
								*result = x1.S <= rightExact
							}
							return
						}
						if path[2] == "B" {
							var rightExact []byte
							rightExact = byteconv.S2B(right)

							if cond == inspector.OpEq {
								*result = bytes.Equal(x1.B, rightExact)
							} else {
								*result = !bytes.Equal(x1.B, rightExact)
							}
							return
						}
						if path[2] == "I" {
							var rightExact int
							t163, err163 := strconv.ParseInt(right, 0, 0)
							if err163 != nil {
								return err163
							}
							rightExact = int(t163)
							switch cond {
							case inspector.OpEq:
								*result = x1.I == rightExact
							case inspector.OpNq:
								*result = x1.I != rightExact
							case inspector.OpGt:
								*result = x1.I > rightExact
							case inspector.OpGtq:
								*result = x1.I >= rightExact
							case inspector.OpLt:
								*result = x1.I < rightExact
							case inspector.OpLtq:
								*result = x1.I <= rightExact
							}
							return
						}
						if path[2] == "I8" {
							var rightExact int8
							t164, err164 := strconv.ParseInt(right, 0, 0)
							if err164 != nil {
								return err164
							}
							rightExact = int8(t164)
							switch cond {
							case inspector.OpEq:
								*result = x1.I8 == rightExact
							case inspector.OpNq:
								*result = x1.I8 != rightExact
							case inspector.OpGt:
								*result = x1.I8 > rightExact
							case inspector.OpGtq:
								*result = x1.I8 >= rightExact
							case inspector.OpLt:
								*result = x1.I8 < rightExact
							case inspector.OpLtq:
								*result = x1.I8 <= rightExact
							}
							return
						}
						if path[2] == "I16" {
							var rightExact int16
							t165, err165 := strconv.ParseInt(right, 0, 0)
							if err165 != nil {
								return err165
							}
							rightExact = int16(t165)
							switch cond {
							case inspector.OpEq:
								*result = x1.I16 == rightExact
							case inspector.OpNq:
								*result = x1.I16 != rightExact
							case inspector.OpGt:
								*result = x1.I16 > rightExact
							case inspector.OpGtq:
								*result = x1.I16 >= rightExact
							case inspector.OpLt:
								*result = x1.I16 < rightExact
							case inspector.OpLtq:
								*result = x1.I16 <= rightExact
							}
							return
						}
						if path[2] == "I32" {
							var rightExact int32
							t166, err166 := strconv.ParseInt(right, 0, 0)
							if err166 != nil {
								return err166
							}
							rightExact = int32(t166)
							switch cond {
							case inspector.OpEq:
								*result = x1.I32 == rightExact
							case inspector.OpNq:
								*result = x1.I32 != rightExact
							case inspector.OpGt:
								*result = x1.I32 > rightExact
							case inspector.OpGtq:
								*result = x1.I32 >= rightExact
							case inspector.OpLt:
								*result = x1.I32 < rightExact
							case inspector.OpLtq:
								*result = x1.I32 <= rightExact
							}
							return
						}
						if path[2] == "I64" {
							var rightExact int64
							t167, err167 := strconv.ParseInt(right, 0, 0)
							if err167 != nil {
								return err167
							}
							rightExact = int64(t167)
							switch cond {
							case inspector.OpEq:
								*result = x1.I64 == rightExact
							case inspector.OpNq:
								*result = x1.I64 != rightExact
							case inspector.OpGt:
								*result = x1.I64 > rightExact
							case inspector.OpGtq:
								*result = x1.I64 >= rightExact
							case inspector.OpLt:
								*result = x1.I64 < rightExact
							case inspector.OpLtq:
								*result = x1.I64 <= rightExact
							}
							return
						}
						if path[2] == "U" {
							var rightExact uint
							t168, err168 := strconv.ParseUint(right, 0, 0)
							if err168 != nil {
								return err168
							}
							rightExact = uint(t168)
							switch cond {
							case inspector.OpEq:
								*result = x1.U == rightExact
							case inspector.OpNq:
								*result = x1.U != rightExact
							case inspector.OpGt:
								*result = x1.U > rightExact
							case inspector.OpGtq:
								*result = x1.U >= rightExact
							case inspector.OpLt:
								*result = x1.U < rightExact
							case inspector.OpLtq:
								*result = x1.U <= rightExact
							}
							return
						}
						if path[2] == "U8" {
							var rightExact uint8
							t169, err169 := strconv.ParseUint(right, 0, 0)
							if err169 != nil {
								return err169
							}
							rightExact = uint8(t169)
							switch cond {
							case inspector.OpEq:
								*result = x1.U8 == rightExact
							case inspector.OpNq:
								*result = x1.U8 != rightExact
							case inspector.OpGt:
								*result = x1.U8 > rightExact
							case inspector.OpGtq:
								*result = x1.U8 >= rightExact
							case inspector.OpLt:
								*result = x1.U8 < rightExact
							case inspector.OpLtq:
								*result = x1.U8 <= rightExact
							}
							return
						}
						if path[2] == "U16" {
							var rightExact uint16
							t170, err170 := strconv.ParseUint(right, 0, 0)
							if err170 != nil {
								return err170
							}
							rightExact = uint16(t170)
							switch cond {
							case inspector.OpEq:
								*result = x1.U16 == rightExact
							case inspector.OpNq:
								*result = x1.U16 != rightExact
							case inspector.OpGt:
								*result = x1.U16 > rightExact
							case inspector.OpGtq:
								*result = x1.U16 >= rightExact
							case inspector.OpLt:
								*result = x1.U16 < rightExact
							case inspector.OpLtq:
								*result = x1.U16 <= rightExact
							}
							return
						}
						if path[2] == "U32" {
							var rightExact uint32
							t171, err171 := strconv.ParseUint(right, 0, 0)
							if err171 != nil {
								return err171
							}
							rightExact = uint32(t171)
							switch cond {
							case inspector.OpEq:
								*result = x1.U32 == rightExact
							case inspector.OpNq:
								*result = x1.U32 != rightExact
							case inspector.OpGt:
								*result = x1.U32 > rightExact
							case inspector.OpGtq:
								*result = x1.U32 >= rightExact
							case inspector.OpLt:
								*result = x1.U32 < rightExact
							case inspector.OpLtq:
								*result = x1.U32 <= rightExact
							}
							return
						}
						if path[2] == "U64" {
							var rightExact uint64
							t172, err172 := strconv.ParseUint(right, 0, 0)
							if err172 != nil {
								return err172
							}
							rightExact = uint64(t172)
							switch cond {
							case inspector.OpEq:
								*result = x1.U64 == rightExact
							case inspector.OpNq:
								*result = x1.U64 != rightExact
							case inspector.OpGt:
								*result = x1.U64 > rightExact
							case inspector.OpGtq:
								*result = x1.U64 >= rightExact
							case inspector.OpLt:
								*result = x1.U64 < rightExact
							case inspector.OpLtq:
								*result = x1.U64 <= rightExact
							}
							return
						}
						if path[2] == "F" {
							var rightExact float32
							t173, err173 := strconv.ParseFloat(right, 0)
							if err173 != nil {
								return err173
							}
							rightExact = float32(t173)
							switch cond {
							case inspector.OpEq:
								*result = x1.F == rightExact
							case inspector.OpNq:
								*result = x1.F != rightExact
							case inspector.OpGt:
								*result = x1.F > rightExact
							case inspector.OpGtq:
								*result = x1.F >= rightExact
							case inspector.OpLt:
								*result = x1.F < rightExact
							case inspector.OpLtq:
								*result = x1.F <= rightExact
							}
							return
						}
						if path[2] == "D" {
							var rightExact float64
							t174, err174 := strconv.ParseFloat(right, 0)
							if err174 != nil {
								return err174
							}
							rightExact = float64(t174)
							switch cond {
							case inspector.OpEq:
								*result = x1.D == rightExact
							case inspector.OpNq:
								*result = x1.D != rightExact
							case inspector.OpGt:
								*result = x1.D > rightExact
							case inspector.OpGtq:
								*result = x1.D >= rightExact
							case inspector.OpLt:
								*result = x1.D < rightExact
							case inspector.OpLtq:
								*result = x1.D <= rightExact
							}
							return
						}
					}
				}
			}
		}
		if path[0] == "IntStringMap" {
			x0 := x.IntStringMap
			_ = x0
			if len(path) > 1 {
				var k int
				t175, err175 := strconv.ParseInt(path[1], 0, 0)
				if err175 != nil {
					return err175
				}
				k = int(t175)
				x1 := (x0)[k]
				_ = x1
				var rightExact string
				rightExact = right

				switch cond {
				case inspector.OpEq:
					*result = x1 == rightExact
				case inspector.OpNq:
					*result = x1 != rightExact
				case inspector.OpGt:
					*result = x1 > rightExact
				case inspector.OpGtq:
					*result = x1 >= rightExact
				case inspector.OpLt:
					*result = x1 < rightExact
				case inspector.OpLtq:
					*result = x1 <= rightExact
				}
				return
			}
		}
		if path[0] == "IntStringPtrMap" {
			x0 := x.IntStringPtrMap
			_ = x0
			if len(path) > 1 {
				var k int
				t177, err177 := strconv.ParseInt(path[1], 0, 0)
				if err177 != nil {
					return err177
				}
				k = int(t177)
				x1 := (x0)[k]
				_ = x1
				if x1 == nil {
					return
				}
				if right == inspector.Nil {
					if cond == inspector.OpEq {
						*result = x1 == nil
					} else {
						*result = x1 != nil
					}
					return
				}
				return
			}
		}
		if path[0] == "IntStringMapPtr" {
			x0 := x.IntStringMapPtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var k int
				t178, err178 := strconv.ParseInt(path[1], 0, 0)
				if err178 != nil {
					return err178
				}
				k = int(t178)
				x1 := (*x0)[k]
				_ = x1
				var rightExact string
				rightExact = right

				switch cond {
				case inspector.OpEq:
					*result = x1 == rightExact
				case inspector.OpNq:
					*result = x1 != rightExact
				case inspector.OpGt:
					*result = x1 > rightExact
				case inspector.OpGtq:
					*result = x1 >= rightExact
				case inspector.OpLt:
					*result = x1 < rightExact
				case inspector.OpLtq:
					*result = x1 <= rightExact
				}
				return
			}
		}
		if path[0] == "IntStringPtrMapPtr" {
			x0 := x.IntStringPtrMapPtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var k int
				t180, err180 := strconv.ParseInt(path[1], 0, 0)
				if err180 != nil {
					return err180
				}
				k = int(t180)
				x1 := (*x0)[k]
				_ = x1
				if x1 == nil {
					return
				}
				if right == inspector.Nil {
					if cond == inspector.OpEq {
						*result = x1 == nil
					} else {
						*result = x1 != nil
					}
					return
				}
				return
			}
		}
		if path[0] == "IntPtrStringPtrMapPtr" {
			x0 := x.IntPtrStringPtrMapPtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var k int
				t181, err181 := strconv.ParseInt(path[1], 0, 0)
				if err181 != nil {
					return err181
				}
				k = int(t181)
				x1 := (*x0)[&k]
				_ = x1
				if x1 == nil {
					return
				}
				if right == inspector.Nil {
					if cond == inspector.OpEq {
						*result = x1 == nil
					} else {
						*result = x1 != nil
					}
					return
				}
				return
			}
		}
		if path[0] == "IntIntMapMap" {
			x0 := x.IntIntMapMap
			_ = x0
			if len(path) > 1 {
				var k int32
				t182, err182 := strconv.ParseInt(path[1], 0, 0)
				if err182 != nil {
					return err182
				}
				k = int32(t182)
				x1 := (x0)[k]
				_ = x1
				if len(path) > 2 {
					var k int32
					t183, err183 := strconv.ParseInt(path[2], 0, 0)
					if err183 != nil {
						return err183
					}
					k = int32(t183)
					x2 := (x1)[k]
					_ = x2
					var rightExact int32
					t184, err184 := strconv.ParseInt(right, 0, 0)
					if err184 != nil {
						return err184
					}
					rightExact = int32(t184)
					switch cond {
					case inspector.OpEq:
						*result = x2 == rightExact
					case inspector.OpNq:
						*result = x2 != rightExact
					case inspector.OpGt:
						*result = x2 > rightExact
					case inspector.OpGtq:
						*result = x2 >= rightExact
					case inspector.OpLt:
						*result = x2 < rightExact
					case inspector.OpLtq:
						*result = x2 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "StringFloatMap" {
			x0 := x.StringFloatMap
			_ = x0
			if len(path) > 1 {
				if x1, ok := (x0)[path[1]]; ok {
					_ = x1
					var rightExact float64
					t185, err185 := strconv.ParseFloat(right, 0)
					if err185 != nil {
						return err185
					}
					rightExact = float64(t185)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "StringFloatPtrMap" {
			x0 := x.StringFloatPtrMap
			_ = x0
			if len(path) > 1 {
				if x1, ok := (x0)[path[1]]; ok {
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "StringFloatMapPtr" {
			x0 := x.StringFloatMapPtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if x1, ok := (*x0)[path[1]]; ok {
					_ = x1
					var rightExact float64
					t186, err186 := strconv.ParseFloat(right, 0)
					if err186 != nil {
						return err186
					}
					rightExact = float64(t186)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "StringFloatPtrMapPtr" {
			x0 := x.StringFloatPtrMapPtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if x1, ok := (*x0)[path[1]]; ok {
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "StringPtrFloatPtrMapPtr" {
			x0 := x.StringPtrFloatPtrMapPtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if x1, ok := (*x0)[&path[1]]; ok {
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "FloatStructMap" {
			x0 := x.FloatStructMap
			_ = x0
			if len(path) > 1 {
				var k float64
				t187, err187 := strconv.ParseFloat(path[1], 0)
				if err187 != nil {
					return err187
				}
				k = float64(t187)
				x1 := (x0)[k]
				_ = x1
				if len(path) > 2 {
					if path[2] == "A" {
						var rightExact byte
						t188 := byteconv.S2B(right)
						if len(t188) > 0 {
							rightExact = t188[0]
						}

						switch cond {
						case inspector.OpEq:
							*result = x1.A == rightExact
						case inspector.OpNq:
							*result = x1.A != rightExact
						case inspector.OpGt:
							*result = x1.A > rightExact
						case inspector.OpGtq:
							*result = x1.A >= rightExact
						case inspector.OpLt:
							*result = x1.A < rightExact
						case inspector.OpLtq:
							*result = x1.A <= rightExact
						}
						return
					}
					if path[2] == "S" {
						var rightExact string
						rightExact = right

						switch cond {
						case inspector.OpEq:
							*result = x1.S == rightExact
						case inspector.OpNq:
							*result = x1.S != rightExact
						case inspector.OpGt:
							*result = x1.S > rightExact
						case inspector.OpGtq:
							*result = x1.S >= rightExact
						case inspector.OpLt:
							*result = x1.S < rightExact
						case inspector.OpLtq:
							*result = x1.S <= rightExact
						}
						return
					}
					if path[2] == "B" {
						var rightExact []byte
						rightExact = byteconv.S2B(right)

						if cond == inspector.OpEq {
							*result = bytes.Equal(x1.B, rightExact)
						} else {
							*result = !bytes.Equal(x1.B, rightExact)
						}
						return
					}
					if path[2] == "I" {
						var rightExact int
						t191, err191 := strconv.ParseInt(right, 0, 0)
						if err191 != nil {
							return err191
						}
						rightExact = int(t191)
						switch cond {
						case inspector.OpEq:
							*result = x1.I == rightExact
						case inspector.OpNq:
							*result = x1.I != rightExact
						case inspector.OpGt:
							*result = x1.I > rightExact
						case inspector.OpGtq:
							*result = x1.I >= rightExact
						case inspector.OpLt:
							*result = x1.I < rightExact
						case inspector.OpLtq:
							*result = x1.I <= rightExact
						}
						return
					}
					if path[2] == "I8" {
						var rightExact int8
						t192, err192 := strconv.ParseInt(right, 0, 0)
						if err192 != nil {
							return err192
						}
						rightExact = int8(t192)
						switch cond {
						case inspector.OpEq:
							*result = x1.I8 == rightExact
						case inspector.OpNq:
							*result = x1.I8 != rightExact
						case inspector.OpGt:
							*result = x1.I8 > rightExact
						case inspector.OpGtq:
							*result = x1.I8 >= rightExact
						case inspector.OpLt:
							*result = x1.I8 < rightExact
						case inspector.OpLtq:
							*result = x1.I8 <= rightExact
						}
						return
					}
					if path[2] == "I16" {
						var rightExact int16
						t193, err193 := strconv.ParseInt(right, 0, 0)
						if err193 != nil {
							return err193
						}
						rightExact = int16(t193)
						switch cond {
						case inspector.OpEq:
							*result = x1.I16 == rightExact
						case inspector.OpNq:
							*result = x1.I16 != rightExact
						case inspector.OpGt:
							*result = x1.I16 > rightExact
						case inspector.OpGtq:
							*result = x1.I16 >= rightExact
						case inspector.OpLt:
							*result = x1.I16 < rightExact
						case inspector.OpLtq:
							*result = x1.I16 <= rightExact
						}
						return
					}
					if path[2] == "I32" {
						var rightExact int32
						t194, err194 := strconv.ParseInt(right, 0, 0)
						if err194 != nil {
							return err194
						}
						rightExact = int32(t194)
						switch cond {
						case inspector.OpEq:
							*result = x1.I32 == rightExact
						case inspector.OpNq:
							*result = x1.I32 != rightExact
						case inspector.OpGt:
							*result = x1.I32 > rightExact
						case inspector.OpGtq:
							*result = x1.I32 >= rightExact
						case inspector.OpLt:
							*result = x1.I32 < rightExact
						case inspector.OpLtq:
							*result = x1.I32 <= rightExact
						}
						return
					}
					if path[2] == "I64" {
						var rightExact int64
						t195, err195 := strconv.ParseInt(right, 0, 0)
						if err195 != nil {
							return err195
						}
						rightExact = int64(t195)
						switch cond {
						case inspector.OpEq:
							*result = x1.I64 == rightExact
						case inspector.OpNq:
							*result = x1.I64 != rightExact
						case inspector.OpGt:
							*result = x1.I64 > rightExact
						case inspector.OpGtq:
							*result = x1.I64 >= rightExact
						case inspector.OpLt:
							*result = x1.I64 < rightExact
						case inspector.OpLtq:
							*result = x1.I64 <= rightExact
						}
						return
					}
					if path[2] == "U" {
						var rightExact uint
						t196, err196 := strconv.ParseUint(right, 0, 0)
						if err196 != nil {
							return err196
						}
						rightExact = uint(t196)
						switch cond {
						case inspector.OpEq:
							*result = x1.U == rightExact
						case inspector.OpNq:
							*result = x1.U != rightExact
						case inspector.OpGt:
							*result = x1.U > rightExact
						case inspector.OpGtq:
							*result = x1.U >= rightExact
						case inspector.OpLt:
							*result = x1.U < rightExact
						case inspector.OpLtq:
							*result = x1.U <= rightExact
						}
						return
					}
					if path[2] == "U8" {
						var rightExact uint8
						t197, err197 := strconv.ParseUint(right, 0, 0)
						if err197 != nil {
							return err197
						}
						rightExact = uint8(t197)
						switch cond {
						case inspector.OpEq:
							*result = x1.U8 == rightExact
						case inspector.OpNq:
							*result = x1.U8 != rightExact
						case inspector.OpGt:
							*result = x1.U8 > rightExact
						case inspector.OpGtq:
							*result = x1.U8 >= rightExact
						case inspector.OpLt:
							*result = x1.U8 < rightExact
						case inspector.OpLtq:
							*result = x1.U8 <= rightExact
						}
						return
					}
					if path[2] == "U16" {
						var rightExact uint16
						t198, err198 := strconv.ParseUint(right, 0, 0)
						if err198 != nil {
							return err198
						}
						rightExact = uint16(t198)
						switch cond {
						case inspector.OpEq:
							*result = x1.U16 == rightExact
						case inspector.OpNq:
							*result = x1.U16 != rightExact
						case inspector.OpGt:
							*result = x1.U16 > rightExact
						case inspector.OpGtq:
							*result = x1.U16 >= rightExact
						case inspector.OpLt:
							*result = x1.U16 < rightExact
						case inspector.OpLtq:
							*result = x1.U16 <= rightExact
						}
						return
					}
					if path[2] == "U32" {
						var rightExact uint32
						t199, err199 := strconv.ParseUint(right, 0, 0)
						if err199 != nil {
							return err199
						}
						rightExact = uint32(t199)
						switch cond {
						case inspector.OpEq:
							*result = x1.U32 == rightExact
						case inspector.OpNq:
							*result = x1.U32 != rightExact
						case inspector.OpGt:
							*result = x1.U32 > rightExact
						case inspector.OpGtq:
							*result = x1.U32 >= rightExact
						case inspector.OpLt:
							*result = x1.U32 < rightExact
						case inspector.OpLtq:
							*result = x1.U32 <= rightExact
						}
						return
					}
					if path[2] == "U64" {
						var rightExact uint64
						t200, err200 := strconv.ParseUint(right, 0, 0)
						if err200 != nil {
							return err200
						}
						rightExact = uint64(t200)
						switch cond {
						case inspector.OpEq:
							*result = x1.U64 == rightExact
						case inspector.OpNq:
							*result = x1.U64 != rightExact
						case inspector.OpGt:
							*result = x1.U64 > rightExact
						case inspector.OpGtq:
							*result = x1.U64 >= rightExact
						case inspector.OpLt:
							*result = x1.U64 < rightExact
						case inspector.OpLtq:
							*result = x1.U64 <= rightExact
						}
						return
					}
					if path[2] == "F" {
						var rightExact float32
						t201, err201 := strconv.ParseFloat(right, 0)
						if err201 != nil {
							return err201
						}
						rightExact = float32(t201)
						switch cond {
						case inspector.OpEq:
							*result = x1.F == rightExact
						case inspector.OpNq:
							*result = x1.F != rightExact
						case inspector.OpGt:
							*result = x1.F > rightExact
						case inspector.OpGtq:
							*result = x1.F >= rightExact
						case inspector.OpLt:
							*result = x1.F < rightExact
						case inspector.OpLtq:
							*result = x1.F <= rightExact
						}
						return
					}
					if path[2] == "D" {
						var rightExact float64
						t202, err202 := strconv.ParseFloat(right, 0)
						if err202 != nil {
							return err202
						}
						rightExact = float64(t202)
						switch cond {
						case inspector.OpEq:
							*result = x1.D == rightExact
						case inspector.OpNq:
							*result = x1.D != rightExact
						case inspector.OpGt:
							*result = x1.D > rightExact
						case inspector.OpGtq:
							*result = x1.D >= rightExact
						case inspector.OpLt:
							*result = x1.D < rightExact
						case inspector.OpLtq:
							*result = x1.D <= rightExact
						}
						return
					}
				}
			}
		}
		if path[0] == "FloatStructPtrMap" {
			x0 := x.FloatStructPtrMap
			_ = x0
			if len(path) > 1 {
				var k float64
				t203, err203 := strconv.ParseFloat(path[1], 0)
				if err203 != nil {
					return err203
				}
				k = float64(t203)
				x1 := (x0)[k]
				_ = x1
				if len(path) > 2 {
					if x1 == nil {
						return
					}
					if path[2] == "A" {
						var rightExact byte
						t204 := byteconv.S2B(right)
						if len(t204) > 0 {
							rightExact = t204[0]
						}

						switch cond {
						case inspector.OpEq:
							*result = x1.A == rightExact
						case inspector.OpNq:
							*result = x1.A != rightExact
						case inspector.OpGt:
							*result = x1.A > rightExact
						case inspector.OpGtq:
							*result = x1.A >= rightExact
						case inspector.OpLt:
							*result = x1.A < rightExact
						case inspector.OpLtq:
							*result = x1.A <= rightExact
						}
						return
					}
					if path[2] == "S" {
						var rightExact string
						rightExact = right

						switch cond {
						case inspector.OpEq:
							*result = x1.S == rightExact
						case inspector.OpNq:
							*result = x1.S != rightExact
						case inspector.OpGt:
							*result = x1.S > rightExact
						case inspector.OpGtq:
							*result = x1.S >= rightExact
						case inspector.OpLt:
							*result = x1.S < rightExact
						case inspector.OpLtq:
							*result = x1.S <= rightExact
						}
						return
					}
					if path[2] == "B" {
						var rightExact []byte
						rightExact = byteconv.S2B(right)

						if cond == inspector.OpEq {
							*result = bytes.Equal(x1.B, rightExact)
						} else {
							*result = !bytes.Equal(x1.B, rightExact)
						}
						return
					}
					if path[2] == "I" {
						var rightExact int
						t207, err207 := strconv.ParseInt(right, 0, 0)
						if err207 != nil {
							return err207
						}
						rightExact = int(t207)
						switch cond {
						case inspector.OpEq:
							*result = x1.I == rightExact
						case inspector.OpNq:
							*result = x1.I != rightExact
						case inspector.OpGt:
							*result = x1.I > rightExact
						case inspector.OpGtq:
							*result = x1.I >= rightExact
						case inspector.OpLt:
							*result = x1.I < rightExact
						case inspector.OpLtq:
							*result = x1.I <= rightExact
						}
						return
					}
					if path[2] == "I8" {
						var rightExact int8
						t208, err208 := strconv.ParseInt(right, 0, 0)
						if err208 != nil {
							return err208
						}
						rightExact = int8(t208)
						switch cond {
						case inspector.OpEq:
							*result = x1.I8 == rightExact
						case inspector.OpNq:
							*result = x1.I8 != rightExact
						case inspector.OpGt:
							*result = x1.I8 > rightExact
						case inspector.OpGtq:
							*result = x1.I8 >= rightExact
						case inspector.OpLt:
							*result = x1.I8 < rightExact
						case inspector.OpLtq:
							*result = x1.I8 <= rightExact
						}
						return
					}
					if path[2] == "I16" {
						var rightExact int16
						t209, err209 := strconv.ParseInt(right, 0, 0)
						if err209 != nil {
							return err209
						}
						rightExact = int16(t209)
						switch cond {
						case inspector.OpEq:
							*result = x1.I16 == rightExact
						case inspector.OpNq:
							*result = x1.I16 != rightExact
						case inspector.OpGt:
							*result = x1.I16 > rightExact
						case inspector.OpGtq:
							*result = x1.I16 >= rightExact
						case inspector.OpLt:
							*result = x1.I16 < rightExact
						case inspector.OpLtq:
							*result = x1.I16 <= rightExact
						}
						return
					}
					if path[2] == "I32" {
						var rightExact int32
						t210, err210 := strconv.ParseInt(right, 0, 0)
						if err210 != nil {
							return err210
						}
						rightExact = int32(t210)
						switch cond {
						case inspector.OpEq:
							*result = x1.I32 == rightExact
						case inspector.OpNq:
							*result = x1.I32 != rightExact
						case inspector.OpGt:
							*result = x1.I32 > rightExact
						case inspector.OpGtq:
							*result = x1.I32 >= rightExact
						case inspector.OpLt:
							*result = x1.I32 < rightExact
						case inspector.OpLtq:
							*result = x1.I32 <= rightExact
						}
						return
					}
					if path[2] == "I64" {
						var rightExact int64
						t211, err211 := strconv.ParseInt(right, 0, 0)
						if err211 != nil {
							return err211
						}
						rightExact = int64(t211)
						switch cond {
						case inspector.OpEq:
							*result = x1.I64 == rightExact
						case inspector.OpNq:
							*result = x1.I64 != rightExact
						case inspector.OpGt:
							*result = x1.I64 > rightExact
						case inspector.OpGtq:
							*result = x1.I64 >= rightExact
						case inspector.OpLt:
							*result = x1.I64 < rightExact
						case inspector.OpLtq:
							*result = x1.I64 <= rightExact
						}
						return
					}
					if path[2] == "U" {
						var rightExact uint
						t212, err212 := strconv.ParseUint(right, 0, 0)
						if err212 != nil {
							return err212
						}
						rightExact = uint(t212)
						switch cond {
						case inspector.OpEq:
							*result = x1.U == rightExact
						case inspector.OpNq:
							*result = x1.U != rightExact
						case inspector.OpGt:
							*result = x1.U > rightExact
						case inspector.OpGtq:
							*result = x1.U >= rightExact
						case inspector.OpLt:
							*result = x1.U < rightExact
						case inspector.OpLtq:
							*result = x1.U <= rightExact
						}
						return
					}
					if path[2] == "U8" {
						var rightExact uint8
						t213, err213 := strconv.ParseUint(right, 0, 0)
						if err213 != nil {
							return err213
						}
						rightExact = uint8(t213)
						switch cond {
						case inspector.OpEq:
							*result = x1.U8 == rightExact
						case inspector.OpNq:
							*result = x1.U8 != rightExact
						case inspector.OpGt:
							*result = x1.U8 > rightExact
						case inspector.OpGtq:
							*result = x1.U8 >= rightExact
						case inspector.OpLt:
							*result = x1.U8 < rightExact
						case inspector.OpLtq:
							*result = x1.U8 <= rightExact
						}
						return
					}
					if path[2] == "U16" {
						var rightExact uint16
						t214, err214 := strconv.ParseUint(right, 0, 0)
						if err214 != nil {
							return err214
						}
						rightExact = uint16(t214)
						switch cond {
						case inspector.OpEq:
							*result = x1.U16 == rightExact
						case inspector.OpNq:
							*result = x1.U16 != rightExact
						case inspector.OpGt:
							*result = x1.U16 > rightExact
						case inspector.OpGtq:
							*result = x1.U16 >= rightExact
						case inspector.OpLt:
							*result = x1.U16 < rightExact
						case inspector.OpLtq:
							*result = x1.U16 <= rightExact
						}
						return
					}
					if path[2] == "U32" {
						var rightExact uint32
						t215, err215 := strconv.ParseUint(right, 0, 0)
						if err215 != nil {
							return err215
						}
						rightExact = uint32(t215)
						switch cond {
						case inspector.OpEq:
							*result = x1.U32 == rightExact
						case inspector.OpNq:
							*result = x1.U32 != rightExact
						case inspector.OpGt:
							*result = x1.U32 > rightExact
						case inspector.OpGtq:
							*result = x1.U32 >= rightExact
						case inspector.OpLt:
							*result = x1.U32 < rightExact
						case inspector.OpLtq:
							*result = x1.U32 <= rightExact
						}
						return
					}
					if path[2] == "U64" {
						var rightExact uint64
						t216, err216 := strconv.ParseUint(right, 0, 0)
						if err216 != nil {
							return err216
						}
						rightExact = uint64(t216)
						switch cond {
						case inspector.OpEq:
							*result = x1.U64 == rightExact
						case inspector.OpNq:
							*result = x1.U64 != rightExact
						case inspector.OpGt:
							*result = x1.U64 > rightExact
						case inspector.OpGtq:
							*result = x1.U64 >= rightExact
						case inspector.OpLt:
							*result = x1.U64 < rightExact
						case inspector.OpLtq:
							*result = x1.U64 <= rightExact
						}
						return
					}
					if path[2] == "F" {
						var rightExact float32
						t217, err217 := strconv.ParseFloat(right, 0)
						if err217 != nil {
							return err217
						}
						rightExact = float32(t217)
						switch cond {
						case inspector.OpEq:
							*result = x1.F == rightExact
						case inspector.OpNq:
							*result = x1.F != rightExact
						case inspector.OpGt:
							*result = x1.F > rightExact
						case inspector.OpGtq:
							*result = x1.F >= rightExact
						case inspector.OpLt:
							*result = x1.F < rightExact
						case inspector.OpLtq:
							*result = x1.F <= rightExact
						}
						return
					}
					if path[2] == "D" {
						var rightExact float64
						t218, err218 := strconv.ParseFloat(right, 0)
						if err218 != nil {
							return err218
						}
						rightExact = float64(t218)
						switch cond {
						case inspector.OpEq:
							*result = x1.D == rightExact
						case inspector.OpNq:
							*result = x1.D != rightExact
						case inspector.OpGt:
							*result = x1.D > rightExact
						case inspector.OpGtq:
							*result = x1.D >= rightExact
						case inspector.OpLt:
							*result = x1.D < rightExact
						case inspector.OpLtq:
							*result = x1.D <= rightExact
						}
						return
					}
				}
			}
		}
		if path[0] == "FloatPtrStructMap" {
			x0 := x.FloatPtrStructMap
			_ = x0
			if len(path) > 1 {
				var k float64
				t219, err219 := strconv.ParseFloat(path[1], 0)
				if err219 != nil {
					return err219
				}
				k = float64(t219)
				x1 := (x0)[&k]
				_ = x1
				if len(path) > 2 {
					if path[2] == "A" {
						var rightExact byte
						t220 := byteconv.S2B(right)
						if len(t220) > 0 {
							rightExact = t220[0]
						}

						switch cond {
						case inspector.OpEq:
							*result = x1.A == rightExact
						case inspector.OpNq:
							*result = x1.A != rightExact
						case inspector.OpGt:
							*result = x1.A > rightExact
						case inspector.OpGtq:
							*result = x1.A >= rightExact
						case inspector.OpLt:
							*result = x1.A < rightExact
						case inspector.OpLtq:
							*result = x1.A <= rightExact
						}
						return
					}
					if path[2] == "S" {
						var rightExact string
						rightExact = right

						switch cond {
						case inspector.OpEq:
							*result = x1.S == rightExact
						case inspector.OpNq:
							*result = x1.S != rightExact
						case inspector.OpGt:
							*result = x1.S > rightExact
						case inspector.OpGtq:
							*result = x1.S >= rightExact
						case inspector.OpLt:
							*result = x1.S < rightExact
						case inspector.OpLtq:
							*result = x1.S <= rightExact
						}
						return
					}
					if path[2] == "B" {
						var rightExact []byte
						rightExact = byteconv.S2B(right)

						if cond == inspector.OpEq {
							*result = bytes.Equal(x1.B, rightExact)
						} else {
							*result = !bytes.Equal(x1.B, rightExact)
						}
						return
					}
					if path[2] == "I" {
						var rightExact int
						t223, err223 := strconv.ParseInt(right, 0, 0)
						if err223 != nil {
							return err223
						}
						rightExact = int(t223)
						switch cond {
						case inspector.OpEq:
							*result = x1.I == rightExact
						case inspector.OpNq:
							*result = x1.I != rightExact
						case inspector.OpGt:
							*result = x1.I > rightExact
						case inspector.OpGtq:
							*result = x1.I >= rightExact
						case inspector.OpLt:
							*result = x1.I < rightExact
						case inspector.OpLtq:
							*result = x1.I <= rightExact
						}
						return
					}
					if path[2] == "I8" {
						var rightExact int8
						t224, err224 := strconv.ParseInt(right, 0, 0)
						if err224 != nil {
							return err224
						}
						rightExact = int8(t224)
						switch cond {
						case inspector.OpEq:
							*result = x1.I8 == rightExact
						case inspector.OpNq:
							*result = x1.I8 != rightExact
						case inspector.OpGt:
							*result = x1.I8 > rightExact
						case inspector.OpGtq:
							*result = x1.I8 >= rightExact
						case inspector.OpLt:
							*result = x1.I8 < rightExact
						case inspector.OpLtq:
							*result = x1.I8 <= rightExact
						}
						return
					}
					if path[2] == "I16" {
						var rightExact int16
						t225, err225 := strconv.ParseInt(right, 0, 0)
						if err225 != nil {
							return err225
						}
						rightExact = int16(t225)
						switch cond {
						case inspector.OpEq:
							*result = x1.I16 == rightExact
						case inspector.OpNq:
							*result = x1.I16 != rightExact
						case inspector.OpGt:
							*result = x1.I16 > rightExact
						case inspector.OpGtq:
							*result = x1.I16 >= rightExact
						case inspector.OpLt:
							*result = x1.I16 < rightExact
						case inspector.OpLtq:
							*result = x1.I16 <= rightExact
						}
						return
					}
					if path[2] == "I32" {
						var rightExact int32
						t226, err226 := strconv.ParseInt(right, 0, 0)
						if err226 != nil {
							return err226
						}
						rightExact = int32(t226)
						switch cond {
						case inspector.OpEq:
							*result = x1.I32 == rightExact
						case inspector.OpNq:
							*result = x1.I32 != rightExact
						case inspector.OpGt:
							*result = x1.I32 > rightExact
						case inspector.OpGtq:
							*result = x1.I32 >= rightExact
						case inspector.OpLt:
							*result = x1.I32 < rightExact
						case inspector.OpLtq:
							*result = x1.I32 <= rightExact
						}
						return
					}
					if path[2] == "I64" {
						var rightExact int64
						t227, err227 := strconv.ParseInt(right, 0, 0)
						if err227 != nil {
							return err227
						}
						rightExact = int64(t227)
						switch cond {
						case inspector.OpEq:
							*result = x1.I64 == rightExact
						case inspector.OpNq:
							*result = x1.I64 != rightExact
						case inspector.OpGt:
							*result = x1.I64 > rightExact
						case inspector.OpGtq:
							*result = x1.I64 >= rightExact
						case inspector.OpLt:
							*result = x1.I64 < rightExact
						case inspector.OpLtq:
							*result = x1.I64 <= rightExact
						}
						return
					}
					if path[2] == "U" {
						var rightExact uint
						t228, err228 := strconv.ParseUint(right, 0, 0)
						if err228 != nil {
							return err228
						}
						rightExact = uint(t228)
						switch cond {
						case inspector.OpEq:
							*result = x1.U == rightExact
						case inspector.OpNq:
							*result = x1.U != rightExact
						case inspector.OpGt:
							*result = x1.U > rightExact
						case inspector.OpGtq:
							*result = x1.U >= rightExact
						case inspector.OpLt:
							*result = x1.U < rightExact
						case inspector.OpLtq:
							*result = x1.U <= rightExact
						}
						return
					}
					if path[2] == "U8" {
						var rightExact uint8
						t229, err229 := strconv.ParseUint(right, 0, 0)
						if err229 != nil {
							return err229
						}
						rightExact = uint8(t229)
						switch cond {
						case inspector.OpEq:
							*result = x1.U8 == rightExact
						case inspector.OpNq:
							*result = x1.U8 != rightExact
						case inspector.OpGt:
							*result = x1.U8 > rightExact
						case inspector.OpGtq:
							*result = x1.U8 >= rightExact
						case inspector.OpLt:
							*result = x1.U8 < rightExact
						case inspector.OpLtq:
							*result = x1.U8 <= rightExact
						}
						return
					}
					if path[2] == "U16" {
						var rightExact uint16
						t230, err230 := strconv.ParseUint(right, 0, 0)
						if err230 != nil {
							return err230
						}
						rightExact = uint16(t230)
						switch cond {
						case inspector.OpEq:
							*result = x1.U16 == rightExact
						case inspector.OpNq:
							*result = x1.U16 != rightExact
						case inspector.OpGt:
							*result = x1.U16 > rightExact
						case inspector.OpGtq:
							*result = x1.U16 >= rightExact
						case inspector.OpLt:
							*result = x1.U16 < rightExact
						case inspector.OpLtq:
							*result = x1.U16 <= rightExact
						}
						return
					}
					if path[2] == "U32" {
						var rightExact uint32
						t231, err231 := strconv.ParseUint(right, 0, 0)
						if err231 != nil {
							return err231
						}
						rightExact = uint32(t231)
						switch cond {
						case inspector.OpEq:
							*result = x1.U32 == rightExact
						case inspector.OpNq:
							*result = x1.U32 != rightExact
						case inspector.OpGt:
							*result = x1.U32 > rightExact
						case inspector.OpGtq:
							*result = x1.U32 >= rightExact
						case inspector.OpLt:
							*result = x1.U32 < rightExact
						case inspector.OpLtq:
							*result = x1.U32 <= rightExact
						}
						return
					}
					if path[2] == "U64" {
						var rightExact uint64
						t232, err232 := strconv.ParseUint(right, 0, 0)
						if err232 != nil {
							return err232
						}
						rightExact = uint64(t232)
						switch cond {
						case inspector.OpEq:
							*result = x1.U64 == rightExact
						case inspector.OpNq:
							*result = x1.U64 != rightExact
						case inspector.OpGt:
							*result = x1.U64 > rightExact
						case inspector.OpGtq:
							*result = x1.U64 >= rightExact
						case inspector.OpLt:
							*result = x1.U64 < rightExact
						case inspector.OpLtq:
							*result = x1.U64 <= rightExact
						}
						return
					}
					if path[2] == "F" {
						var rightExact float32
						t233, err233 := strconv.ParseFloat(right, 0)
						if err233 != nil {
							return err233
						}
						rightExact = float32(t233)
						switch cond {
						case inspector.OpEq:
							*result = x1.F == rightExact
						case inspector.OpNq:
							*result = x1.F != rightExact
						case inspector.OpGt:
							*result = x1.F > rightExact
						case inspector.OpGtq:
							*result = x1.F >= rightExact
						case inspector.OpLt:
							*result = x1.F < rightExact
						case inspector.OpLtq:
							*result = x1.F <= rightExact
						}
						return
					}
					if path[2] == "D" {
						var rightExact float64
						t234, err234 := strconv.ParseFloat(right, 0)
						if err234 != nil {
							return err234
						}
						rightExact = float64(t234)
						switch cond {
						case inspector.OpEq:
							*result = x1.D == rightExact
						case inspector.OpNq:
							*result = x1.D != rightExact
						case inspector.OpGt:
							*result = x1.D > rightExact
						case inspector.OpGtq:
							*result = x1.D >= rightExact
						case inspector.OpLt:
							*result = x1.D < rightExact
						case inspector.OpLtq:
							*result = x1.D <= rightExact
						}
						return
					}
				}
			}
		}
		if path[0] == "FloatPtrStructPtrMap" {
			x0 := x.FloatPtrStructPtrMap
			_ = x0
			if len(path) > 1 {
				var k float64
				t235, err235 := strconv.ParseFloat(path[1], 0)
				if err235 != nil {
					return err235
				}
				k = float64(t235)
				x1 := (x0)[&k]
				_ = x1
				if len(path) > 2 {
					if x1 == nil {
						return
					}
					if path[2] == "A" {
						var rightExact byte
						t236 := byteconv.S2B(right)
						if len(t236) > 0 {
							rightExact = t236[0]
						}

						switch cond {
						case inspector.OpEq:
							*result = x1.A == rightExact
						case inspector.OpNq:
							*result = x1.A != rightExact
						case inspector.OpGt:
							*result = x1.A > rightExact
						case inspector.OpGtq:
							*result = x1.A >= rightExact
						case inspector.OpLt:
							*result = x1.A < rightExact
						case inspector.OpLtq:
							*result = x1.A <= rightExact
						}
						return
					}
					if path[2] == "S" {
						var rightExact string
						rightExact = right

						switch cond {
						case inspector.OpEq:
							*result = x1.S == rightExact
						case inspector.OpNq:
							*result = x1.S != rightExact
						case inspector.OpGt:
							*result = x1.S > rightExact
						case inspector.OpGtq:
							*result = x1.S >= rightExact
						case inspector.OpLt:
							*result = x1.S < rightExact
						case inspector.OpLtq:
							*result = x1.S <= rightExact
						}
						return
					}
					if path[2] == "B" {
						var rightExact []byte
						rightExact = byteconv.S2B(right)

						if cond == inspector.OpEq {
							*result = bytes.Equal(x1.B, rightExact)
						} else {
							*result = !bytes.Equal(x1.B, rightExact)
						}
						return
					}
					if path[2] == "I" {
						var rightExact int
						t239, err239 := strconv.ParseInt(right, 0, 0)
						if err239 != nil {
							return err239
						}
						rightExact = int(t239)
						switch cond {
						case inspector.OpEq:
							*result = x1.I == rightExact
						case inspector.OpNq:
							*result = x1.I != rightExact
						case inspector.OpGt:
							*result = x1.I > rightExact
						case inspector.OpGtq:
							*result = x1.I >= rightExact
						case inspector.OpLt:
							*result = x1.I < rightExact
						case inspector.OpLtq:
							*result = x1.I <= rightExact
						}
						return
					}
					if path[2] == "I8" {
						var rightExact int8
						t240, err240 := strconv.ParseInt(right, 0, 0)
						if err240 != nil {
							return err240
						}
						rightExact = int8(t240)
						switch cond {
						case inspector.OpEq:
							*result = x1.I8 == rightExact
						case inspector.OpNq:
							*result = x1.I8 != rightExact
						case inspector.OpGt:
							*result = x1.I8 > rightExact
						case inspector.OpGtq:
							*result = x1.I8 >= rightExact
						case inspector.OpLt:
							*result = x1.I8 < rightExact
						case inspector.OpLtq:
							*result = x1.I8 <= rightExact
						}
						return
					}
					if path[2] == "I16" {
						var rightExact int16
						t241, err241 := strconv.ParseInt(right, 0, 0)
						if err241 != nil {
							return err241
						}
						rightExact = int16(t241)
						switch cond {
						case inspector.OpEq:
							*result = x1.I16 == rightExact
						case inspector.OpNq:
							*result = x1.I16 != rightExact
						case inspector.OpGt:
							*result = x1.I16 > rightExact
						case inspector.OpGtq:
							*result = x1.I16 >= rightExact
						case inspector.OpLt:
							*result = x1.I16 < rightExact
						case inspector.OpLtq:
							*result = x1.I16 <= rightExact
						}
						return
					}
					if path[2] == "I32" {
						var rightExact int32
						t242, err242 := strconv.ParseInt(right, 0, 0)
						if err242 != nil {
							return err242
						}
						rightExact = int32(t242)
						switch cond {
						case inspector.OpEq:
							*result = x1.I32 == rightExact
						case inspector.OpNq:
							*result = x1.I32 != rightExact
						case inspector.OpGt:
							*result = x1.I32 > rightExact
						case inspector.OpGtq:
							*result = x1.I32 >= rightExact
						case inspector.OpLt:
							*result = x1.I32 < rightExact
						case inspector.OpLtq:
							*result = x1.I32 <= rightExact
						}
						return
					}
					if path[2] == "I64" {
						var rightExact int64
						t243, err243 := strconv.ParseInt(right, 0, 0)
						if err243 != nil {
							return err243
						}
						rightExact = int64(t243)
						switch cond {
						case inspector.OpEq:
							*result = x1.I64 == rightExact
						case inspector.OpNq:
							*result = x1.I64 != rightExact
						case inspector.OpGt:
							*result = x1.I64 > rightExact
						case inspector.OpGtq:
							*result = x1.I64 >= rightExact
						case inspector.OpLt:
							*result = x1.I64 < rightExact
						case inspector.OpLtq:
							*result = x1.I64 <= rightExact
						}
						return
					}
					if path[2] == "U" {
						var rightExact uint
						t244, err244 := strconv.ParseUint(right, 0, 0)
						if err244 != nil {
							return err244
						}
						rightExact = uint(t244)
						switch cond {
						case inspector.OpEq:
							*result = x1.U == rightExact
						case inspector.OpNq:
							*result = x1.U != rightExact
						case inspector.OpGt:
							*result = x1.U > rightExact
						case inspector.OpGtq:
							*result = x1.U >= rightExact
						case inspector.OpLt:
							*result = x1.U < rightExact
						case inspector.OpLtq:
							*result = x1.U <= rightExact
						}
						return
					}
					if path[2] == "U8" {
						var rightExact uint8
						t245, err245 := strconv.ParseUint(right, 0, 0)
						if err245 != nil {
							return err245
						}
						rightExact = uint8(t245)
						switch cond {
						case inspector.OpEq:
							*result = x1.U8 == rightExact
						case inspector.OpNq:
							*result = x1.U8 != rightExact
						case inspector.OpGt:
							*result = x1.U8 > rightExact
						case inspector.OpGtq:
							*result = x1.U8 >= rightExact
						case inspector.OpLt:
							*result = x1.U8 < rightExact
						case inspector.OpLtq:
							*result = x1.U8 <= rightExact
						}
						return
					}
					if path[2] == "U16" {
						var rightExact uint16
						t246, err246 := strconv.ParseUint(right, 0, 0)
						if err246 != nil {
							return err246
						}
						rightExact = uint16(t246)
						switch cond {
						case inspector.OpEq:
							*result = x1.U16 == rightExact
						case inspector.OpNq:
							*result = x1.U16 != rightExact
						case inspector.OpGt:
							*result = x1.U16 > rightExact
						case inspector.OpGtq:
							*result = x1.U16 >= rightExact
						case inspector.OpLt:
							*result = x1.U16 < rightExact
						case inspector.OpLtq:
							*result = x1.U16 <= rightExact
						}
						return
					}
					if path[2] == "U32" {
						var rightExact uint32
						t247, err247 := strconv.ParseUint(right, 0, 0)
						if err247 != nil {
							return err247
						}
						rightExact = uint32(t247)
						switch cond {
						case inspector.OpEq:
							*result = x1.U32 == rightExact
						case inspector.OpNq:
							*result = x1.U32 != rightExact
						case inspector.OpGt:
							*result = x1.U32 > rightExact
						case inspector.OpGtq:
							*result = x1.U32 >= rightExact
						case inspector.OpLt:
							*result = x1.U32 < rightExact
						case inspector.OpLtq:
							*result = x1.U32 <= rightExact
						}
						return
					}
					if path[2] == "U64" {
						var rightExact uint64
						t248, err248 := strconv.ParseUint(right, 0, 0)
						if err248 != nil {
							return err248
						}
						rightExact = uint64(t248)
						switch cond {
						case inspector.OpEq:
							*result = x1.U64 == rightExact
						case inspector.OpNq:
							*result = x1.U64 != rightExact
						case inspector.OpGt:
							*result = x1.U64 > rightExact
						case inspector.OpGtq:
							*result = x1.U64 >= rightExact
						case inspector.OpLt:
							*result = x1.U64 < rightExact
						case inspector.OpLtq:
							*result = x1.U64 <= rightExact
						}
						return
					}
					if path[2] == "F" {
						var rightExact float32
						t249, err249 := strconv.ParseFloat(right, 0)
						if err249 != nil {
							return err249
						}
						rightExact = float32(t249)
						switch cond {
						case inspector.OpEq:
							*result = x1.F == rightExact
						case inspector.OpNq:
							*result = x1.F != rightExact
						case inspector.OpGt:
							*result = x1.F > rightExact
						case inspector.OpGtq:
							*result = x1.F >= rightExact
						case inspector.OpLt:
							*result = x1.F < rightExact
						case inspector.OpLtq:
							*result = x1.F <= rightExact
						}
						return
					}
					if path[2] == "D" {
						var rightExact float64
						t250, err250 := strconv.ParseFloat(right, 0)
						if err250 != nil {
							return err250
						}
						rightExact = float64(t250)
						switch cond {
						case inspector.OpEq:
							*result = x1.D == rightExact
						case inspector.OpNq:
							*result = x1.D != rightExact
						case inspector.OpGt:
							*result = x1.D > rightExact
						case inspector.OpGtq:
							*result = x1.D >= rightExact
						case inspector.OpLt:
							*result = x1.D < rightExact
						case inspector.OpLtq:
							*result = x1.D <= rightExact
						}
						return
					}
				}
			}
		}
		if path[0] == "FloatPtrStructPtrMapPtr" {
			x0 := x.FloatPtrStructPtrMapPtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var k float64
				t251, err251 := strconv.ParseFloat(path[1], 0)
				if err251 != nil {
					return err251
				}
				k = float64(t251)
				x1 := (*x0)[&k]
				_ = x1
				if len(path) > 2 {
					if x1 == nil {
						return
					}
					if path[2] == "A" {
						var rightExact byte
						t252 := byteconv.S2B(right)
						if len(t252) > 0 {
							rightExact = t252[0]
						}

						switch cond {
						case inspector.OpEq:
							*result = x1.A == rightExact
						case inspector.OpNq:
							*result = x1.A != rightExact
						case inspector.OpGt:
							*result = x1.A > rightExact
						case inspector.OpGtq:
							*result = x1.A >= rightExact
						case inspector.OpLt:
							*result = x1.A < rightExact
						case inspector.OpLtq:
							*result = x1.A <= rightExact
						}
						return
					}
					if path[2] == "S" {
						var rightExact string
						rightExact = right

						switch cond {
						case inspector.OpEq:
							*result = x1.S == rightExact
						case inspector.OpNq:
							*result = x1.S != rightExact
						case inspector.OpGt:
							*result = x1.S > rightExact
						case inspector.OpGtq:
							*result = x1.S >= rightExact
						case inspector.OpLt:
							*result = x1.S < rightExact
						case inspector.OpLtq:
							*result = x1.S <= rightExact
						}
						return
					}
					if path[2] == "B" {
						var rightExact []byte
						rightExact = byteconv.S2B(right)

						if cond == inspector.OpEq {
							*result = bytes.Equal(x1.B, rightExact)
						} else {
							*result = !bytes.Equal(x1.B, rightExact)
						}
						return
					}
					if path[2] == "I" {
						var rightExact int
						t255, err255 := strconv.ParseInt(right, 0, 0)
						if err255 != nil {
							return err255
						}
						rightExact = int(t255)
						switch cond {
						case inspector.OpEq:
							*result = x1.I == rightExact
						case inspector.OpNq:
							*result = x1.I != rightExact
						case inspector.OpGt:
							*result = x1.I > rightExact
						case inspector.OpGtq:
							*result = x1.I >= rightExact
						case inspector.OpLt:
							*result = x1.I < rightExact
						case inspector.OpLtq:
							*result = x1.I <= rightExact
						}
						return
					}
					if path[2] == "I8" {
						var rightExact int8
						t256, err256 := strconv.ParseInt(right, 0, 0)
						if err256 != nil {
							return err256
						}
						rightExact = int8(t256)
						switch cond {
						case inspector.OpEq:
							*result = x1.I8 == rightExact
						case inspector.OpNq:
							*result = x1.I8 != rightExact
						case inspector.OpGt:
							*result = x1.I8 > rightExact
						case inspector.OpGtq:
							*result = x1.I8 >= rightExact
						case inspector.OpLt:
							*result = x1.I8 < rightExact
						case inspector.OpLtq:
							*result = x1.I8 <= rightExact
						}
						return
					}
					if path[2] == "I16" {
						var rightExact int16
						t257, err257 := strconv.ParseInt(right, 0, 0)
						if err257 != nil {
							return err257
						}
						rightExact = int16(t257)
						switch cond {
						case inspector.OpEq:
							*result = x1.I16 == rightExact
						case inspector.OpNq:
							*result = x1.I16 != rightExact
						case inspector.OpGt:
							*result = x1.I16 > rightExact
						case inspector.OpGtq:
							*result = x1.I16 >= rightExact
						case inspector.OpLt:
							*result = x1.I16 < rightExact
						case inspector.OpLtq:
							*result = x1.I16 <= rightExact
						}
						return
					}
					if path[2] == "I32" {
						var rightExact int32
						t258, err258 := strconv.ParseInt(right, 0, 0)
						if err258 != nil {
							return err258
						}
						rightExact = int32(t258)
						switch cond {
						case inspector.OpEq:
							*result = x1.I32 == rightExact
						case inspector.OpNq:
							*result = x1.I32 != rightExact
						case inspector.OpGt:
							*result = x1.I32 > rightExact
						case inspector.OpGtq:
							*result = x1.I32 >= rightExact
						case inspector.OpLt:
							*result = x1.I32 < rightExact
						case inspector.OpLtq:
							*result = x1.I32 <= rightExact
						}
						return
					}
					if path[2] == "I64" {
						var rightExact int64
						t259, err259 := strconv.ParseInt(right, 0, 0)
						if err259 != nil {
							return err259
						}
						rightExact = int64(t259)
						switch cond {
						case inspector.OpEq:
							*result = x1.I64 == rightExact
						case inspector.OpNq:
							*result = x1.I64 != rightExact
						case inspector.OpGt:
							*result = x1.I64 > rightExact
						case inspector.OpGtq:
							*result = x1.I64 >= rightExact
						case inspector.OpLt:
							*result = x1.I64 < rightExact
						case inspector.OpLtq:
							*result = x1.I64 <= rightExact
						}
						return
					}
					if path[2] == "U" {
						var rightExact uint
						t260, err260 := strconv.ParseUint(right, 0, 0)
						if err260 != nil {
							return err260
						}
						rightExact = uint(t260)
						switch cond {
						case inspector.OpEq:
							*result = x1.U == rightExact
						case inspector.OpNq:
							*result = x1.U != rightExact
						case inspector.OpGt:
							*result = x1.U > rightExact
						case inspector.OpGtq:
							*result = x1.U >= rightExact
						case inspector.OpLt:
							*result = x1.U < rightExact
						case inspector.OpLtq:
							*result = x1.U <= rightExact
						}
						return
					}
					if path[2] == "U8" {
						var rightExact uint8
						t261, err261 := strconv.ParseUint(right, 0, 0)
						if err261 != nil {
							return err261
						}
						rightExact = uint8(t261)
						switch cond {
						case inspector.OpEq:
							*result = x1.U8 == rightExact
						case inspector.OpNq:
							*result = x1.U8 != rightExact
						case inspector.OpGt:
							*result = x1.U8 > rightExact
						case inspector.OpGtq:
							*result = x1.U8 >= rightExact
						case inspector.OpLt:
							*result = x1.U8 < rightExact
						case inspector.OpLtq:
							*result = x1.U8 <= rightExact
						}
						return
					}
					if path[2] == "U16" {
						var rightExact uint16
						t262, err262 := strconv.ParseUint(right, 0, 0)
						if err262 != nil {
							return err262
						}
						rightExact = uint16(t262)
						switch cond {
						case inspector.OpEq:
							*result = x1.U16 == rightExact
						case inspector.OpNq:
							*result = x1.U16 != rightExact
						case inspector.OpGt:
							*result = x1.U16 > rightExact
						case inspector.OpGtq:
							*result = x1.U16 >= rightExact
						case inspector.OpLt:
							*result = x1.U16 < rightExact
						case inspector.OpLtq:
							*result = x1.U16 <= rightExact
						}
						return
					}
					if path[2] == "U32" {
						var rightExact uint32
						t263, err263 := strconv.ParseUint(right, 0, 0)
						if err263 != nil {
							return err263
						}
						rightExact = uint32(t263)
						switch cond {
						case inspector.OpEq:
							*result = x1.U32 == rightExact
						case inspector.OpNq:
							*result = x1.U32 != rightExact
						case inspector.OpGt:
							*result = x1.U32 > rightExact
						case inspector.OpGtq:
							*result = x1.U32 >= rightExact
						case inspector.OpLt:
							*result = x1.U32 < rightExact
						case inspector.OpLtq:
							*result = x1.U32 <= rightExact
						}
						return
					}
					if path[2] == "U64" {
						var rightExact uint64
						t264, err264 := strconv.ParseUint(right, 0, 0)
						if err264 != nil {
							return err264
						}
						rightExact = uint64(t264)
						switch cond {
						case inspector.OpEq:
							*result = x1.U64 == rightExact
						case inspector.OpNq:
							*result = x1.U64 != rightExact
						case inspector.OpGt:
							*result = x1.U64 > rightExact
						case inspector.OpGtq:
							*result = x1.U64 >= rightExact
						case inspector.OpLt:
							*result = x1.U64 < rightExact
						case inspector.OpLtq:
							*result = x1.U64 <= rightExact
						}
						return
					}
					if path[2] == "F" {
						var rightExact float32
						t265, err265 := strconv.ParseFloat(right, 0)
						if err265 != nil {
							return err265
						}
						rightExact = float32(t265)
						switch cond {
						case inspector.OpEq:
							*result = x1.F == rightExact
						case inspector.OpNq:
							*result = x1.F != rightExact
						case inspector.OpGt:
							*result = x1.F > rightExact
						case inspector.OpGtq:
							*result = x1.F >= rightExact
						case inspector.OpLt:
							*result = x1.F < rightExact
						case inspector.OpLtq:
							*result = x1.F <= rightExact
						}
						return
					}
					if path[2] == "D" {
						var rightExact float64
						t266, err266 := strconv.ParseFloat(right, 0)
						if err266 != nil {
							return err266
						}
						rightExact = float64(t266)
						switch cond {
						case inspector.OpEq:
							*result = x1.D == rightExact
						case inspector.OpNq:
							*result = x1.D != rightExact
						case inspector.OpGt:
							*result = x1.D > rightExact
						case inspector.OpGtq:
							*result = x1.D >= rightExact
						case inspector.OpLt:
							*result = x1.D < rightExact
						case inspector.OpLtq:
							*result = x1.D <= rightExact
						}
						return
					}
				}
			}
		}
		if path[0] == "NestedStruct" {
			x0 := &x.NestedStruct
			_ = x0
			if len(path) > 1 {
				if path[1] == "A" {
					var rightExact byte
					t267 := byteconv.S2B(right)
					if len(t267) > 0 {
						rightExact = t267[0]
					}

					switch cond {
					case inspector.OpEq:
						*result = x0.A == rightExact
					case inspector.OpNq:
						*result = x0.A != rightExact
					case inspector.OpGt:
						*result = x0.A > rightExact
					case inspector.OpGtq:
						*result = x0.A >= rightExact
					case inspector.OpLt:
						*result = x0.A < rightExact
					case inspector.OpLtq:
						*result = x0.A <= rightExact
					}
					return
				}
				if path[1] == "S" {
					var rightExact string
					rightExact = right

					switch cond {
					case inspector.OpEq:
						*result = x0.S == rightExact
					case inspector.OpNq:
						*result = x0.S != rightExact
					case inspector.OpGt:
						*result = x0.S > rightExact
					case inspector.OpGtq:
						*result = x0.S >= rightExact
					case inspector.OpLt:
						*result = x0.S < rightExact
					case inspector.OpLtq:
						*result = x0.S <= rightExact
					}
					return
				}
				if path[1] == "B" {
					var rightExact []byte
					rightExact = byteconv.S2B(right)

					if cond == inspector.OpEq {
						*result = bytes.Equal(x0.B, rightExact)
					} else {
						*result = !bytes.Equal(x0.B, rightExact)
					}
					return
				}
				if path[1] == "I" {
					var rightExact int
					t270, err270 := strconv.ParseInt(right, 0, 0)
					if err270 != nil {
						return err270
					}
					rightExact = int(t270)
					switch cond {
					case inspector.OpEq:
						*result = x0.I == rightExact
					case inspector.OpNq:
						*result = x0.I != rightExact
					case inspector.OpGt:
						*result = x0.I > rightExact
					case inspector.OpGtq:
						*result = x0.I >= rightExact
					case inspector.OpLt:
						*result = x0.I < rightExact
					case inspector.OpLtq:
						*result = x0.I <= rightExact
					}
					return
				}
				if path[1] == "I8" {
					var rightExact int8
					t271, err271 := strconv.ParseInt(right, 0, 0)
					if err271 != nil {
						return err271
					}
					rightExact = int8(t271)
					switch cond {
					case inspector.OpEq:
						*result = x0.I8 == rightExact
					case inspector.OpNq:
						*result = x0.I8 != rightExact
					case inspector.OpGt:
						*result = x0.I8 > rightExact
					case inspector.OpGtq:
						*result = x0.I8 >= rightExact
					case inspector.OpLt:
						*result = x0.I8 < rightExact
					case inspector.OpLtq:
						*result = x0.I8 <= rightExact
					}
					return
				}
				if path[1] == "I16" {
					var rightExact int16
					t272, err272 := strconv.ParseInt(right, 0, 0)
					if err272 != nil {
						return err272
					}
					rightExact = int16(t272)
					switch cond {
					case inspector.OpEq:
						*result = x0.I16 == rightExact
					case inspector.OpNq:
						*result = x0.I16 != rightExact
					case inspector.OpGt:
						*result = x0.I16 > rightExact
					case inspector.OpGtq:
						*result = x0.I16 >= rightExact
					case inspector.OpLt:
						*result = x0.I16 < rightExact
					case inspector.OpLtq:
						*result = x0.I16 <= rightExact
					}
					return
				}
				if path[1] == "I32" {
					var rightExact int32
					t273, err273 := strconv.ParseInt(right, 0, 0)
					if err273 != nil {
						return err273
					}
					rightExact = int32(t273)
					switch cond {
					case inspector.OpEq:
						*result = x0.I32 == rightExact
					case inspector.OpNq:
						*result = x0.I32 != rightExact
					case inspector.OpGt:
						*result = x0.I32 > rightExact
					case inspector.OpGtq:
						*result = x0.I32 >= rightExact
					case inspector.OpLt:
						*result = x0.I32 < rightExact
					case inspector.OpLtq:
						*result = x0.I32 <= rightExact
					}
					return
				}
				if path[1] == "I64" {
					var rightExact int64
					t274, err274 := strconv.ParseInt(right, 0, 0)
					if err274 != nil {
						return err274
					}
					rightExact = int64(t274)
					switch cond {
					case inspector.OpEq:
						*result = x0.I64 == rightExact
					case inspector.OpNq:
						*result = x0.I64 != rightExact
					case inspector.OpGt:
						*result = x0.I64 > rightExact
					case inspector.OpGtq:
						*result = x0.I64 >= rightExact
					case inspector.OpLt:
						*result = x0.I64 < rightExact
					case inspector.OpLtq:
						*result = x0.I64 <= rightExact
					}
					return
				}
				if path[1] == "U" {
					var rightExact uint
					t275, err275 := strconv.ParseUint(right, 0, 0)
					if err275 != nil {
						return err275
					}
					rightExact = uint(t275)
					switch cond {
					case inspector.OpEq:
						*result = x0.U == rightExact
					case inspector.OpNq:
						*result = x0.U != rightExact
					case inspector.OpGt:
						*result = x0.U > rightExact
					case inspector.OpGtq:
						*result = x0.U >= rightExact
					case inspector.OpLt:
						*result = x0.U < rightExact
					case inspector.OpLtq:
						*result = x0.U <= rightExact
					}
					return
				}
				if path[1] == "U8" {
					var rightExact uint8
					t276, err276 := strconv.ParseUint(right, 0, 0)
					if err276 != nil {
						return err276
					}
					rightExact = uint8(t276)
					switch cond {
					case inspector.OpEq:
						*result = x0.U8 == rightExact
					case inspector.OpNq:
						*result = x0.U8 != rightExact
					case inspector.OpGt:
						*result = x0.U8 > rightExact
					case inspector.OpGtq:
						*result = x0.U8 >= rightExact
					case inspector.OpLt:
						*result = x0.U8 < rightExact
					case inspector.OpLtq:
						*result = x0.U8 <= rightExact
					}
					return
				}
				if path[1] == "U16" {
					var rightExact uint16
					t277, err277 := strconv.ParseUint(right, 0, 0)
					if err277 != nil {
						return err277
					}
					rightExact = uint16(t277)
					switch cond {
					case inspector.OpEq:
						*result = x0.U16 == rightExact
					case inspector.OpNq:
						*result = x0.U16 != rightExact
					case inspector.OpGt:
						*result = x0.U16 > rightExact
					case inspector.OpGtq:
						*result = x0.U16 >= rightExact
					case inspector.OpLt:
						*result = x0.U16 < rightExact
					case inspector.OpLtq:
						*result = x0.U16 <= rightExact
					}
					return
				}
				if path[1] == "U32" {
					var rightExact uint32
					t278, err278 := strconv.ParseUint(right, 0, 0)
					if err278 != nil {
						return err278
					}
					rightExact = uint32(t278)
					switch cond {
					case inspector.OpEq:
						*result = x0.U32 == rightExact
					case inspector.OpNq:
						*result = x0.U32 != rightExact
					case inspector.OpGt:
						*result = x0.U32 > rightExact
					case inspector.OpGtq:
						*result = x0.U32 >= rightExact
					case inspector.OpLt:
						*result = x0.U32 < rightExact
					case inspector.OpLtq:
						*result = x0.U32 <= rightExact
					}
					return
				}
				if path[1] == "U64" {
					var rightExact uint64
					t279, err279 := strconv.ParseUint(right, 0, 0)
					if err279 != nil {
						return err279
					}
					rightExact = uint64(t279)
					switch cond {
					case inspector.OpEq:
						*result = x0.U64 == rightExact
					case inspector.OpNq:
						*result = x0.U64 != rightExact
					case inspector.OpGt:
						*result = x0.U64 > rightExact
					case inspector.OpGtq:
						*result = x0.U64 >= rightExact
					case inspector.OpLt:
						*result = x0.U64 < rightExact
					case inspector.OpLtq:
						*result = x0.U64 <= rightExact
					}
					return
				}
				if path[1] == "F" {
					var rightExact float32
					t280, err280 := strconv.ParseFloat(right, 0)
					if err280 != nil {
						return err280
					}
					rightExact = float32(t280)
					switch cond {
					case inspector.OpEq:
						*result = x0.F == rightExact
					case inspector.OpNq:
						*result = x0.F != rightExact
					case inspector.OpGt:
						*result = x0.F > rightExact
					case inspector.OpGtq:
						*result = x0.F >= rightExact
					case inspector.OpLt:
						*result = x0.F < rightExact
					case inspector.OpLtq:
						*result = x0.F <= rightExact
					}
					return
				}
				if path[1] == "D" {
					var rightExact float64
					t281, err281 := strconv.ParseFloat(right, 0)
					if err281 != nil {
						return err281
					}
					rightExact = float64(t281)
					switch cond {
					case inspector.OpEq:
						*result = x0.D == rightExact
					case inspector.OpNq:
						*result = x0.D != rightExact
					case inspector.OpGt:
						*result = x0.D > rightExact
					case inspector.OpGtq:
						*result = x0.D >= rightExact
					case inspector.OpLt:
						*result = x0.D < rightExact
					case inspector.OpLtq:
						*result = x0.D <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "NestedStructPtr" {
			x0 := x.NestedStructPtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if path[1] == "A" {
					var rightExact byte
					t282 := byteconv.S2B(right)
					if len(t282) > 0 {
						rightExact = t282[0]
					}

					switch cond {
					case inspector.OpEq:
						*result = x0.A == rightExact
					case inspector.OpNq:
						*result = x0.A != rightExact
					case inspector.OpGt:
						*result = x0.A > rightExact
					case inspector.OpGtq:
						*result = x0.A >= rightExact
					case inspector.OpLt:
						*result = x0.A < rightExact
					case inspector.OpLtq:
						*result = x0.A <= rightExact
					}
					return
				}
				if path[1] == "S" {
					var rightExact string
					rightExact = right

					switch cond {
					case inspector.OpEq:
						*result = x0.S == rightExact
					case inspector.OpNq:
						*result = x0.S != rightExact
					case inspector.OpGt:
						*result = x0.S > rightExact
					case inspector.OpGtq:
						*result = x0.S >= rightExact
					case inspector.OpLt:
						*result = x0.S < rightExact
					case inspector.OpLtq:
						*result = x0.S <= rightExact
					}
					return
				}
				if path[1] == "B" {
					var rightExact []byte
					rightExact = byteconv.S2B(right)

					if cond == inspector.OpEq {
						*result = bytes.Equal(x0.B, rightExact)
					} else {
						*result = !bytes.Equal(x0.B, rightExact)
					}
					return
				}
				if path[1] == "I" {
					var rightExact int
					t285, err285 := strconv.ParseInt(right, 0, 0)
					if err285 != nil {
						return err285
					}
					rightExact = int(t285)
					switch cond {
					case inspector.OpEq:
						*result = x0.I == rightExact
					case inspector.OpNq:
						*result = x0.I != rightExact
					case inspector.OpGt:
						*result = x0.I > rightExact
					case inspector.OpGtq:
						*result = x0.I >= rightExact
					case inspector.OpLt:
						*result = x0.I < rightExact
					case inspector.OpLtq:
						*result = x0.I <= rightExact
					}
					return
				}
				if path[1] == "I8" {
					var rightExact int8
					t286, err286 := strconv.ParseInt(right, 0, 0)
					if err286 != nil {
						return err286
					}
					rightExact = int8(t286)
					switch cond {
					case inspector.OpEq:
						*result = x0.I8 == rightExact
					case inspector.OpNq:
						*result = x0.I8 != rightExact
					case inspector.OpGt:
						*result = x0.I8 > rightExact
					case inspector.OpGtq:
						*result = x0.I8 >= rightExact
					case inspector.OpLt:
						*result = x0.I8 < rightExact
					case inspector.OpLtq:
						*result = x0.I8 <= rightExact
					}
					return
				}
				if path[1] == "I16" {
					var rightExact int16
					t287, err287 := strconv.ParseInt(right, 0, 0)
					if err287 != nil {
						return err287
					}
					rightExact = int16(t287)
					switch cond {
					case inspector.OpEq:
						*result = x0.I16 == rightExact
					case inspector.OpNq:
						*result = x0.I16 != rightExact
					case inspector.OpGt:
						*result = x0.I16 > rightExact
					case inspector.OpGtq:
						*result = x0.I16 >= rightExact
					case inspector.OpLt:
						*result = x0.I16 < rightExact
					case inspector.OpLtq:
						*result = x0.I16 <= rightExact
					}
					return
				}
				if path[1] == "I32" {
					var rightExact int32
					t288, err288 := strconv.ParseInt(right, 0, 0)
					if err288 != nil {
						return err288
					}
					rightExact = int32(t288)
					switch cond {
					case inspector.OpEq:
						*result = x0.I32 == rightExact
					case inspector.OpNq:
						*result = x0.I32 != rightExact
					case inspector.OpGt:
						*result = x0.I32 > rightExact
					case inspector.OpGtq:
						*result = x0.I32 >= rightExact
					case inspector.OpLt:
						*result = x0.I32 < rightExact
					case inspector.OpLtq:
						*result = x0.I32 <= rightExact
					}
					return
				}
				if path[1] == "I64" {
					var rightExact int64
					t289, err289 := strconv.ParseInt(right, 0, 0)
					if err289 != nil {
						return err289
					}
					rightExact = int64(t289)
					switch cond {
					case inspector.OpEq:
						*result = x0.I64 == rightExact
					case inspector.OpNq:
						*result = x0.I64 != rightExact
					case inspector.OpGt:
						*result = x0.I64 > rightExact
					case inspector.OpGtq:
						*result = x0.I64 >= rightExact
					case inspector.OpLt:
						*result = x0.I64 < rightExact
					case inspector.OpLtq:
						*result = x0.I64 <= rightExact
					}
					return
				}
				if path[1] == "U" {
					var rightExact uint
					t290, err290 := strconv.ParseUint(right, 0, 0)
					if err290 != nil {
						return err290
					}
					rightExact = uint(t290)
					switch cond {
					case inspector.OpEq:
						*result = x0.U == rightExact
					case inspector.OpNq:
						*result = x0.U != rightExact
					case inspector.OpGt:
						*result = x0.U > rightExact
					case inspector.OpGtq:
						*result = x0.U >= rightExact
					case inspector.OpLt:
						*result = x0.U < rightExact
					case inspector.OpLtq:
						*result = x0.U <= rightExact
					}
					return
				}
				if path[1] == "U8" {
					var rightExact uint8
					t291, err291 := strconv.ParseUint(right, 0, 0)
					if err291 != nil {
						return err291
					}
					rightExact = uint8(t291)
					switch cond {
					case inspector.OpEq:
						*result = x0.U8 == rightExact
					case inspector.OpNq:
						*result = x0.U8 != rightExact
					case inspector.OpGt:
						*result = x0.U8 > rightExact
					case inspector.OpGtq:
						*result = x0.U8 >= rightExact
					case inspector.OpLt:
						*result = x0.U8 < rightExact
					case inspector.OpLtq:
						*result = x0.U8 <= rightExact
					}
					return
				}
				if path[1] == "U16" {
					var rightExact uint16
					t292, err292 := strconv.ParseUint(right, 0, 0)
					if err292 != nil {
						return err292
					}
					rightExact = uint16(t292)
					switch cond {
					case inspector.OpEq:
						*result = x0.U16 == rightExact
					case inspector.OpNq:
						*result = x0.U16 != rightExact
					case inspector.OpGt:
						*result = x0.U16 > rightExact
					case inspector.OpGtq:
						*result = x0.U16 >= rightExact
					case inspector.OpLt:
						*result = x0.U16 < rightExact
					case inspector.OpLtq:
						*result = x0.U16 <= rightExact
					}
					return
				}
				if path[1] == "U32" {
					var rightExact uint32
					t293, err293 := strconv.ParseUint(right, 0, 0)
					if err293 != nil {
						return err293
					}
					rightExact = uint32(t293)
					switch cond {
					case inspector.OpEq:
						*result = x0.U32 == rightExact
					case inspector.OpNq:
						*result = x0.U32 != rightExact
					case inspector.OpGt:
						*result = x0.U32 > rightExact
					case inspector.OpGtq:
						*result = x0.U32 >= rightExact
					case inspector.OpLt:
						*result = x0.U32 < rightExact
					case inspector.OpLtq:
						*result = x0.U32 <= rightExact
					}
					return
				}
				if path[1] == "U64" {
					var rightExact uint64
					t294, err294 := strconv.ParseUint(right, 0, 0)
					if err294 != nil {
						return err294
					}
					rightExact = uint64(t294)
					switch cond {
					case inspector.OpEq:
						*result = x0.U64 == rightExact
					case inspector.OpNq:
						*result = x0.U64 != rightExact
					case inspector.OpGt:
						*result = x0.U64 > rightExact
					case inspector.OpGtq:
						*result = x0.U64 >= rightExact
					case inspector.OpLt:
						*result = x0.U64 < rightExact
					case inspector.OpLtq:
						*result = x0.U64 <= rightExact
					}
					return
				}
				if path[1] == "F" {
					var rightExact float32
					t295, err295 := strconv.ParseFloat(right, 0)
					if err295 != nil {
						return err295
					}
					rightExact = float32(t295)
					switch cond {
					case inspector.OpEq:
						*result = x0.F == rightExact
					case inspector.OpNq:
						*result = x0.F != rightExact
					case inspector.OpGt:
						*result = x0.F > rightExact
					case inspector.OpGtq:
						*result = x0.F >= rightExact
					case inspector.OpLt:
						*result = x0.F < rightExact
					case inspector.OpLtq:
						*result = x0.F <= rightExact
					}
					return
				}
				if path[1] == "D" {
					var rightExact float64
					t296, err296 := strconv.ParseFloat(right, 0)
					if err296 != nil {
						return err296
					}
					rightExact = float64(t296)
					switch cond {
					case inspector.OpEq:
						*result = x0.D == rightExact
					case inspector.OpNq:
						*result = x0.D != rightExact
					case inspector.OpGt:
						*result = x0.D > rightExact
					case inspector.OpGtq:
						*result = x0.D >= rightExact
					case inspector.OpLt:
						*result = x0.D < rightExact
					case inspector.OpLtq:
						*result = x0.D <= rightExact
					}
					return
				}
			}
		}
	}
	return
}

func (i6 TestObject1Inspector) Loop(src any, l inspector.Iterator, buf *[]byte, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *testobj.TestObject1
	_ = x
	if p, ok := src.(**testobj.TestObject1); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestObject1); ok {
		x = p
	} else if v, ok := src.(testobj.TestObject1); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
		if path[0] == "IntSlice" {
			x0 := x.IntSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntPtrSlice" {
			x0 := x.IntPtrSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntSlicePtr" {
			x0 := x.IntSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntPtrSlicePtr" {
			x0 := x.IntPtrSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "BytePtrSlice" {
			x0 := x.BytePtrSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "BytePtrSlicePtr" {
			x0 := x.BytePtrSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatSlice" {
			x0 := x.FloatSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatPtrSlice" {
			x0 := x.FloatPtrSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatSlicePtr" {
			x0 := x.FloatSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatPtrSlicePtr" {
			x0 := x.FloatPtrSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StructSlice" {
			x0 := x.StructSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &TestStructInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StructPtrSlice" {
			x0 := x.StructPtrSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &TestStructInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StructSlicePtr" {
			x0 := x.StructSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &TestStructInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StructPtrSlicePtr" {
			x0 := x.StructPtrSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &TestStructInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StructSliceLiteral" {
			x0 := x.StructSliceLiteral
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &TestStructInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntStringMap" {
			x0 := x.IntStringMap
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntStringPtrMap" {
			x0 := x.IntStringPtrMap
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntStringMapPtr" {
			x0 := x.IntStringMapPtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntStringPtrMapPtr" {
			x0 := x.IntStringPtrMapPtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntPtrStringPtrMapPtr" {
			x0 := x.IntPtrStringPtrMapPtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(*k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntIntMapMap" {
			x0 := x.IntIntMapMap
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StringFloatMap" {
			x0 := x.StringFloatMap
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = append((*buf)[:0], k...)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StringFloatPtrMap" {
			x0 := x.StringFloatPtrMap
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = append((*buf)[:0], k...)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StringFloatMapPtr" {
			x0 := x.StringFloatMapPtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = append((*buf)[:0], k...)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StringFloatPtrMapPtr" {
			x0 := x.StringFloatPtrMapPtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = append((*buf)[:0], k...)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StringPtrFloatPtrMapPtr" {
			x0 := x.StringPtrFloatPtrMapPtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = append((*buf)[:0], *k...)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatStructMap" {
			x0 := x.FloatStructMap
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendFloat((*buf)[:0], float64(k), 'f', -1, 64)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((x0)[k], &TestStructInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatStructPtrMap" {
			x0 := x.FloatStructPtrMap
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendFloat((*buf)[:0], float64(k), 'f', -1, 64)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((x0)[k], &TestStructInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatPtrStructMap" {
			x0 := x.FloatPtrStructMap
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendFloat((*buf)[:0], float64(*k), 'f', -1, 64)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((x0)[k], &TestStructInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatPtrStructPtrMap" {
			x0 := x.FloatPtrStructPtrMap
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendFloat((*buf)[:0], float64(*k), 'f', -1, 64)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((x0)[k], &TestStructInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatPtrStructPtrMapPtr" {
			x0 := x.FloatPtrStructPtrMapPtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendFloat((*buf)[:0], float64(*k), 'f', -1, 64)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((*x0)[k], &TestStructInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "NestedStruct" {
			x0 := &x.NestedStruct
			_ = x0
			if len(path) > 1 {
			}
		}
		if path[0] == "NestedStructPtr" {
			x0 := x.NestedStructPtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
			}
		}
	}
	return
}

func (i6 TestObject1Inspector) SetWithBuffer(dst, value any, buf inspector.AccumulativeBuffer, path ...string) error {
	if len(path) == 0 {
		return nil
	}
	if dst == nil {
		return nil
	}
	var x *testobj.TestObject1
	_ = x
	if p, ok := dst.(**testobj.TestObject1); ok {
		x = *p
	} else if p, ok := dst.(*testobj.TestObject1); ok {
		x = p
	} else if v, ok := dst.(testobj.TestObject1); ok {
		x = &v
	} else {
		return nil
	}

	if len(path) > 0 {
		if path[0] == "IntSlice" {
			x0 := x.IntSlice
			if uvalue, ok := value.(*[]int32); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make([]int32, 0)
				x0 = z
				x.IntSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t297, err297 := strconv.ParseInt(path[1], 0, 0)
				if err297 != nil {
					return err297
				}
				i = int(t297)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					inspector.AssignBuf(&x1, value, buf)
					return nil
					(x0)[i] = x1
					return nil
				}
			}
			x.IntSlice = x0
		}
		if path[0] == "IntPtrSlice" {
			x0 := x.IntPtrSlice
			if uvalue, ok := value.(*[]*int32); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make([]*int32, 0)
				x0 = z
				x.IntPtrSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t298, err298 := strconv.ParseInt(path[1], 0, 0)
				if err298 != nil {
					return err298
				}
				i = int(t298)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return nil
					}
					inspector.AssignBuf(x1, value, buf)
					return nil
					(x0)[i] = x1
					return nil
				}
			}
			x.IntPtrSlice = x0
		}
		if path[0] == "IntSlicePtr" {
			x0 := x.IntSlicePtr
			if uvalue, ok := value.(*[]int32); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make([]int32, 0)
				x0 = &z
				x.IntSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t299, err299 := strconv.ParseInt(path[1], 0, 0)
				if err299 != nil {
					return err299
				}
				i = int(t299)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					inspector.AssignBuf(&x1, value, buf)
					return nil
					(*x0)[i] = x1
					return nil
				}
			}
			x.IntSlicePtr = x0
		}
		if path[0] == "IntPtrSlicePtr" {
			x0 := x.IntPtrSlicePtr
			if uvalue, ok := value.(*[]*int32); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make([]*int32, 0)
				x0 = &z
				x.IntPtrSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t300, err300 := strconv.ParseInt(path[1], 0, 0)
				if err300 != nil {
					return err300
				}
				i = int(t300)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return nil
					}
					inspector.AssignBuf(x1, value, buf)
					return nil
					(*x0)[i] = x1
					return nil
				}
			}
			x.IntPtrSlicePtr = x0
		}
		if path[0] == "ByteSlice" {
			inspector.AssignBuf(&x.ByteSlice, value, buf)
			return nil
		}
		if path[0] == "BytePtrSlice" {
			x0 := x.BytePtrSlice
			if uvalue, ok := value.(*[]*byte); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make([]*byte, 0)
				x0 = z
				x.BytePtrSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t301, err301 := strconv.ParseInt(path[1], 0, 0)
				if err301 != nil {
					return err301
				}
				i = int(t301)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return nil
					}
					inspector.AssignBuf(x1, value, buf)
					return nil
					(x0)[i] = x1
					return nil
				}
			}
			x.BytePtrSlice = x0
		}
		if path[0] == "ByteSlicePtr" {
			inspector.AssignBuf(x.ByteSlicePtr, value, buf)
			return nil
		}
		if path[0] == "BytePtrSlicePtr" {
			x0 := x.BytePtrSlicePtr
			if uvalue, ok := value.(*[]*byte); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make([]*byte, 0)
				x0 = &z
				x.BytePtrSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t302, err302 := strconv.ParseInt(path[1], 0, 0)
				if err302 != nil {
					return err302
				}
				i = int(t302)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return nil
					}
					inspector.AssignBuf(x1, value, buf)
					return nil
					(*x0)[i] = x1
					return nil
				}
			}
			x.BytePtrSlicePtr = x0
		}
		if path[0] == "FloatSlice" {
			x0 := x.FloatSlice
			if uvalue, ok := value.(*testobj.TestFloatSlice); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(testobj.TestFloatSlice, 0)
				x0 = z
				x.FloatSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t303, err303 := strconv.ParseInt(path[1], 0, 0)
				if err303 != nil {
					return err303
				}
				i = int(t303)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					inspector.AssignBuf(&x1, value, buf)
					return nil
					(x0)[i] = x1
					return nil
				}
			}
			x.FloatSlice = x0
		}
		if path[0] == "FloatPtrSlice" {
			x0 := x.FloatPtrSlice
			if uvalue, ok := value.(*testobj.TestFloatPtrSlice); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(testobj.TestFloatPtrSlice, 0)
				x0 = z
				x.FloatPtrSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t304, err304 := strconv.ParseInt(path[1], 0, 0)
				if err304 != nil {
					return err304
				}
				i = int(t304)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return nil
					}
					inspector.AssignBuf(x1, value, buf)
					return nil
					(x0)[i] = x1
					return nil
				}
			}
			x.FloatPtrSlice = x0
		}
		if path[0] == "FloatSlicePtr" {
			x0 := x.FloatSlicePtr
			if uvalue, ok := value.(*testobj.TestFloatSlice); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(testobj.TestFloatSlice, 0)
				x0 = &z
				x.FloatSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t305, err305 := strconv.ParseInt(path[1], 0, 0)
				if err305 != nil {
					return err305
				}
				i = int(t305)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					inspector.AssignBuf(&x1, value, buf)
					return nil
					(*x0)[i] = x1
					return nil
				}
			}
			x.FloatSlicePtr = x0
		}
		if path[0] == "FloatPtrSlicePtr" {
			x0 := x.FloatPtrSlicePtr
			if uvalue, ok := value.(*testobj.TestFloatPtrSlice); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(testobj.TestFloatPtrSlice, 0)
				x0 = &z
				x.FloatPtrSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t306, err306 := strconv.ParseInt(path[1], 0, 0)
				if err306 != nil {
					return err306
				}
				i = int(t306)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return nil
					}
					inspector.AssignBuf(x1, value, buf)
					return nil
					(*x0)[i] = x1
					return nil
				}
			}
			x.FloatPtrSlicePtr = x0
		}
		if path[0] == "StructSlice" {
			x0 := x.StructSlice
			if uvalue, ok := value.(*[]testobj.TestStruct); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make([]testobj.TestStruct, 0)
				x0 = z
				x.StructSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t307, err307 := strconv.ParseInt(path[1], 0, 0)
				if err307 != nil {
					return err307
				}
				i = int(t307)
				if len(x0) > i {
					x1 := &(x0)[i]
					_ = x1
					if len(path) > 2 {
						if path[2] == "A" {
							inspector.AssignBuf(&x1.A, value, buf)
							return nil
						}
						if path[2] == "S" {
							inspector.AssignBuf(&x1.S, value, buf)
							return nil
						}
						if path[2] == "B" {
							inspector.AssignBuf(&x1.B, value, buf)
							return nil
						}
						if path[2] == "I" {
							inspector.AssignBuf(&x1.I, value, buf)
							return nil
						}
						if path[2] == "I8" {
							inspector.AssignBuf(&x1.I8, value, buf)
							return nil
						}
						if path[2] == "I16" {
							inspector.AssignBuf(&x1.I16, value, buf)
							return nil
						}
						if path[2] == "I32" {
							inspector.AssignBuf(&x1.I32, value, buf)
							return nil
						}
						if path[2] == "I64" {
							inspector.AssignBuf(&x1.I64, value, buf)
							return nil
						}
						if path[2] == "U" {
							inspector.AssignBuf(&x1.U, value, buf)
							return nil
						}
						if path[2] == "U8" {
							inspector.AssignBuf(&x1.U8, value, buf)
							return nil
						}
						if path[2] == "U16" {
							inspector.AssignBuf(&x1.U16, value, buf)
							return nil
						}
						if path[2] == "U32" {
							inspector.AssignBuf(&x1.U32, value, buf)
							return nil
						}
						if path[2] == "U64" {
							inspector.AssignBuf(&x1.U64, value, buf)
							return nil
						}
						if path[2] == "F" {
							inspector.AssignBuf(&x1.F, value, buf)
							return nil
						}
						if path[2] == "D" {
							inspector.AssignBuf(&x1.D, value, buf)
							return nil
						}
					}
					(x0)[i] = *x1
					return nil
				}
			}
			x.StructSlice = x0
		}
		if path[0] == "StructPtrSlice" {
			x0 := x.StructPtrSlice
			if uvalue, ok := value.(*[]*testobj.TestStruct); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make([]*testobj.TestStruct, 0)
				x0 = z
				x.StructPtrSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t308, err308 := strconv.ParseInt(path[1], 0, 0)
				if err308 != nil {
					return err308
				}
				i = int(t308)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return nil
						}
						if path[2] == "A" {
							inspector.AssignBuf(&x1.A, value, buf)
							return nil
						}
						if path[2] == "S" {
							inspector.AssignBuf(&x1.S, value, buf)
							return nil
						}
						if path[2] == "B" {
							inspector.AssignBuf(&x1.B, value, buf)
							return nil
						}
						if path[2] == "I" {
							inspector.AssignBuf(&x1.I, value, buf)
							return nil
						}
						if path[2] == "I8" {
							inspector.AssignBuf(&x1.I8, value, buf)
							return nil
						}
						if path[2] == "I16" {
							inspector.AssignBuf(&x1.I16, value, buf)
							return nil
						}
						if path[2] == "I32" {
							inspector.AssignBuf(&x1.I32, value, buf)
							return nil
						}
						if path[2] == "I64" {
							inspector.AssignBuf(&x1.I64, value, buf)
							return nil
						}
						if path[2] == "U" {
							inspector.AssignBuf(&x1.U, value, buf)
							return nil
						}
						if path[2] == "U8" {
							inspector.AssignBuf(&x1.U8, value, buf)
							return nil
						}
						if path[2] == "U16" {
							inspector.AssignBuf(&x1.U16, value, buf)
							return nil
						}
						if path[2] == "U32" {
							inspector.AssignBuf(&x1.U32, value, buf)
							return nil
						}
						if path[2] == "U64" {
							inspector.AssignBuf(&x1.U64, value, buf)
							return nil
						}
						if path[2] == "F" {
							inspector.AssignBuf(&x1.F, value, buf)
							return nil
						}
						if path[2] == "D" {
							inspector.AssignBuf(&x1.D, value, buf)
							return nil
						}
					}
					(x0)[i] = x1
					return nil
				}
			}
			x.StructPtrSlice = x0
		}
		if path[0] == "StructSlicePtr" {
			x0 := x.StructSlicePtr
			if uvalue, ok := value.(*[]testobj.TestStruct); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make([]testobj.TestStruct, 0)
				x0 = &z
				x.StructSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t309, err309 := strconv.ParseInt(path[1], 0, 0)
				if err309 != nil {
					return err309
				}
				i = int(t309)
				if len(*x0) > i {
					x1 := &(*x0)[i]
					_ = x1
					if len(path) > 2 {
						if path[2] == "A" {
							inspector.AssignBuf(&x1.A, value, buf)
							return nil
						}
						if path[2] == "S" {
							inspector.AssignBuf(&x1.S, value, buf)
							return nil
						}
						if path[2] == "B" {
							inspector.AssignBuf(&x1.B, value, buf)
							return nil
						}
						if path[2] == "I" {
							inspector.AssignBuf(&x1.I, value, buf)
							return nil
						}
						if path[2] == "I8" {
							inspector.AssignBuf(&x1.I8, value, buf)
							return nil
						}
						if path[2] == "I16" {
							inspector.AssignBuf(&x1.I16, value, buf)
							return nil
						}
						if path[2] == "I32" {
							inspector.AssignBuf(&x1.I32, value, buf)
							return nil
						}
						if path[2] == "I64" {
							inspector.AssignBuf(&x1.I64, value, buf)
							return nil
						}
						if path[2] == "U" {
							inspector.AssignBuf(&x1.U, value, buf)
							return nil
						}
						if path[2] == "U8" {
							inspector.AssignBuf(&x1.U8, value, buf)
							return nil
						}
						if path[2] == "U16" {
							inspector.AssignBuf(&x1.U16, value, buf)
							return nil
						}
						if path[2] == "U32" {
							inspector.AssignBuf(&x1.U32, value, buf)
							return nil
						}
						if path[2] == "U64" {
							inspector.AssignBuf(&x1.U64, value, buf)
							return nil
						}
						if path[2] == "F" {
							inspector.AssignBuf(&x1.F, value, buf)
							return nil
						}
						if path[2] == "D" {
							inspector.AssignBuf(&x1.D, value, buf)
							return nil
						}
					}
					(*x0)[i] = *x1
					return nil
				}
			}
			x.StructSlicePtr = x0
		}
		if path[0] == "StructPtrSlicePtr" {
			x0 := x.StructPtrSlicePtr
			if uvalue, ok := value.(*[]*testobj.TestStruct); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make([]*testobj.TestStruct, 0)
				x0 = &z
				x.StructPtrSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t310, err310 := strconv.ParseInt(path[1], 0, 0)
				if err310 != nil {
					return err310
				}
				i = int(t310)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return nil
						}
						if path[2] == "A" {
							inspector.AssignBuf(&x1.A, value, buf)
							return nil
						}
						if path[2] == "S" {
							inspector.AssignBuf(&x1.S, value, buf)
							return nil
						}
						if path[2] == "B" {
							inspector.AssignBuf(&x1.B, value, buf)
							return nil
						}
						if path[2] == "I" {
							inspector.AssignBuf(&x1.I, value, buf)
							return nil
						}
						if path[2] == "I8" {
							inspector.AssignBuf(&x1.I8, value, buf)
							return nil
						}
						if path[2] == "I16" {
							inspector.AssignBuf(&x1.I16, value, buf)
							return nil
						}
						if path[2] == "I32" {
							inspector.AssignBuf(&x1.I32, value, buf)
							return nil
						}
						if path[2] == "I64" {
							inspector.AssignBuf(&x1.I64, value, buf)
							return nil
						}
						if path[2] == "U" {
							inspector.AssignBuf(&x1.U, value, buf)
							return nil
						}
						if path[2] == "U8" {
							inspector.AssignBuf(&x1.U8, value, buf)
							return nil
						}
						if path[2] == "U16" {
							inspector.AssignBuf(&x1.U16, value, buf)
							return nil
						}
						if path[2] == "U32" {
							inspector.AssignBuf(&x1.U32, value, buf)
							return nil
						}
						if path[2] == "U64" {
							inspector.AssignBuf(&x1.U64, value, buf)
							return nil
						}
						if path[2] == "F" {
							inspector.AssignBuf(&x1.F, value, buf)
							return nil
						}
						if path[2] == "D" {
							inspector.AssignBuf(&x1.D, value, buf)
							return nil
						}
					}
					(*x0)[i] = x1
					return nil
				}
			}
			x.StructPtrSlicePtr = x0
		}
		if path[0] == "StructSliceLiteral" {
			x0 := x.StructSliceLiteral
			if uvalue, ok := value.(*testobj.TestStructSliceLiteral); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(testobj.TestStructSliceLiteral, 0)
				x0 = z
				x.StructSliceLiteral = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t311, err311 := strconv.ParseInt(path[1], 0, 0)
				if err311 != nil {
					return err311
				}
				i = int(t311)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return nil
						}
						if path[2] == "A" {
							inspector.AssignBuf(&x1.A, value, buf)
							return nil
						}
						if path[2] == "S" {
							inspector.AssignBuf(&x1.S, value, buf)
							return nil
						}
						if path[2] == "B" {
							inspector.AssignBuf(&x1.B, value, buf)
							return nil
						}
						if path[2] == "I" {
							inspector.AssignBuf(&x1.I, value, buf)
							return nil
						}
						if path[2] == "I8" {
							inspector.AssignBuf(&x1.I8, value, buf)
							return nil
						}
						if path[2] == "I16" {
							inspector.AssignBuf(&x1.I16, value, buf)
							return nil
						}
						if path[2] == "I32" {
							inspector.AssignBuf(&x1.I32, value, buf)
							return nil
						}
						if path[2] == "I64" {
							inspector.AssignBuf(&x1.I64, value, buf)
							return nil
						}
						if path[2] == "U" {
							inspector.AssignBuf(&x1.U, value, buf)
							return nil
						}
						if path[2] == "U8" {
							inspector.AssignBuf(&x1.U8, value, buf)
							return nil
						}
						if path[2] == "U16" {
							inspector.AssignBuf(&x1.U16, value, buf)
							return nil
						}
						if path[2] == "U32" {
							inspector.AssignBuf(&x1.U32, value, buf)
							return nil
						}
						if path[2] == "U64" {
							inspector.AssignBuf(&x1.U64, value, buf)
							return nil
						}
						if path[2] == "F" {
							inspector.AssignBuf(&x1.F, value, buf)
							return nil
						}
						if path[2] == "D" {
							inspector.AssignBuf(&x1.D, value, buf)
							return nil
						}
					}
					(x0)[i] = x1
					return nil
				}
			}
			x.StructSliceLiteral = x0
		}
		if path[0] == "IntStringMap" {
			x0 := x.IntStringMap
			if uvalue, ok := value.(*map[int]string); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(map[int]string)
				x0 = z
				x.IntStringMap = x0
			}
			_ = x0
			if len(path) > 1 {
				var k int
				t312, err312 := strconv.ParseInt(path[1], 0, 0)
				if err312 != nil {
					return err312
				}
				k = int(t312)
				x1 := (x0)[k]
				_ = x1
				inspector.AssignBuf(&x1, value, buf)
				(x0)[k] = x1
				return nil
			}
			x.IntStringMap = x0
		}
		if path[0] == "IntStringPtrMap" {
			x0 := x.IntStringPtrMap
			if uvalue, ok := value.(*map[int]*string); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(map[int]*string)
				x0 = z
				x.IntStringPtrMap = x0
			}
			_ = x0
			if len(path) > 1 {
				var k int
				t313, err313 := strconv.ParseInt(path[1], 0, 0)
				if err313 != nil {
					return err313
				}
				k = int(t313)
				x1 := (x0)[k]
				_ = x1
				if x1 == nil {
					return nil
				}
				inspector.AssignBuf(x1, value, buf)
				(x0)[k] = x1
				return nil
			}
			x.IntStringPtrMap = x0
		}
		if path[0] == "IntStringMapPtr" {
			x0 := x.IntStringMapPtr
			if uvalue, ok := value.(*map[int]string); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(map[int]string)
				x0 = &z
				x.IntStringMapPtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var k int
				t314, err314 := strconv.ParseInt(path[1], 0, 0)
				if err314 != nil {
					return err314
				}
				k = int(t314)
				x1 := (*x0)[k]
				_ = x1
				inspector.AssignBuf(&x1, value, buf)
				(*x0)[k] = x1
				return nil
			}
			x.IntStringMapPtr = x0
		}
		if path[0] == "IntStringPtrMapPtr" {
			x0 := x.IntStringPtrMapPtr
			if uvalue, ok := value.(*map[int]*string); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(map[int]*string)
				x0 = &z
				x.IntStringPtrMapPtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var k int
				t315, err315 := strconv.ParseInt(path[1], 0, 0)
				if err315 != nil {
					return err315
				}
				k = int(t315)
				x1 := (*x0)[k]
				_ = x1
				if x1 == nil {
					return nil
				}
				inspector.AssignBuf(x1, value, buf)
				(*x0)[k] = x1
				return nil
			}
			x.IntStringPtrMapPtr = x0
		}
		if path[0] == "IntPtrStringPtrMapPtr" {
			x0 := x.IntPtrStringPtrMapPtr
			if uvalue, ok := value.(*map[*int]*string); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(map[*int]*string)
				x0 = &z
				x.IntPtrStringPtrMapPtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var k int
				t316, err316 := strconv.ParseInt(path[1], 0, 0)
				if err316 != nil {
					return err316
				}
				k = int(t316)
				x1 := (*x0)[&k]
				_ = x1
				if x1 == nil {
					return nil
				}
				inspector.AssignBuf(x1, value, buf)
				(*x0)[&k] = x1
				return nil
			}
			x.IntPtrStringPtrMapPtr = x0
		}
		if path[0] == "IntIntMapMap" {
			x0 := x.IntIntMapMap
			if uvalue, ok := value.(*map[int32]map[int32]int32); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(map[int32]map[int32]int32)
				x0 = z
				x.IntIntMapMap = x0
			}
			_ = x0
			if len(path) > 1 {
				var k int32
				t317, err317 := strconv.ParseInt(path[1], 0, 0)
				if err317 != nil {
					return err317
				}
				k = int32(t317)
				x1 := (x0)[k]
				_ = x1
				if len(path) > 2 {
					var k int32
					t318, err318 := strconv.ParseInt(path[2], 0, 0)
					if err318 != nil {
						return err318
					}
					k = int32(t318)
					x2 := (x1)[k]
					_ = x2
					inspector.AssignBuf(&x2, value, buf)
					(x1)[k] = x2
					return nil
				}
				(x0)[k] = x1
				return nil
			}
			x.IntIntMapMap = x0
		}
		if path[0] == "StringFloatMap" {
			x0 := x.StringFloatMap
			if uvalue, ok := value.(*testobj.TestStringFloatMap); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(testobj.TestStringFloatMap)
				x0 = z
				x.StringFloatMap = x0
			}
			_ = x0
			if len(path) > 1 {
				x1 := (x0)[path[1]]
				_ = x1
				inspector.AssignBuf(&x1, value, buf)
				(x0)[path[1]] = x1
				return nil
			}
			x.StringFloatMap = x0
		}
		if path[0] == "StringFloatPtrMap" {
			x0 := x.StringFloatPtrMap
			if uvalue, ok := value.(*testobj.TestStringFloatPtrMap); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(testobj.TestStringFloatPtrMap)
				x0 = z
				x.StringFloatPtrMap = x0
			}
			_ = x0
			if len(path) > 1 {
				x1 := (x0)[path[1]]
				_ = x1
				if x1 == nil {
					return nil
				}
				inspector.AssignBuf(x1, value, buf)
				(x0)[path[1]] = x1
				return nil
			}
			x.StringFloatPtrMap = x0
		}
		if path[0] == "StringFloatMapPtr" {
			x0 := x.StringFloatMapPtr
			if uvalue, ok := value.(*testobj.TestStringFloatMap); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(testobj.TestStringFloatMap)
				x0 = &z
				x.StringFloatMapPtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				x1 := (*x0)[path[1]]
				_ = x1
				inspector.AssignBuf(&x1, value, buf)
				(*x0)[path[1]] = x1
				return nil
			}
			x.StringFloatMapPtr = x0
		}
		if path[0] == "StringFloatPtrMapPtr" {
			x0 := x.StringFloatPtrMapPtr
			if uvalue, ok := value.(*testobj.TestStringFloatPtrMap); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(testobj.TestStringFloatPtrMap)
				x0 = &z
				x.StringFloatPtrMapPtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				x1 := (*x0)[path[1]]
				_ = x1
				if x1 == nil {
					return nil
				}
				inspector.AssignBuf(x1, value, buf)
				(*x0)[path[1]] = x1
				return nil
			}
			x.StringFloatPtrMapPtr = x0
		}
		if path[0] == "StringPtrFloatPtrMapPtr" {
			x0 := x.StringPtrFloatPtrMapPtr
			if uvalue, ok := value.(*testobj.TestStringPtrFloatPtrMap); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(testobj.TestStringPtrFloatPtrMap)
				x0 = &z
				x.StringPtrFloatPtrMapPtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				x1 := (*x0)[&path[1]]
				_ = x1
				if x1 == nil {
					return nil
				}
				inspector.AssignBuf(x1, value, buf)
				(*x0)[&path[1]] = x1
				return nil
			}
			x.StringPtrFloatPtrMapPtr = x0
		}
		if path[0] == "FloatStructMap" {
			x0 := x.FloatStructMap
			if uvalue, ok := value.(*map[float64]testobj.TestStruct); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(map[float64]testobj.TestStruct)
				x0 = z
				x.FloatStructMap = x0
			}
			_ = x0
			if len(path) > 1 {
				var k float64
				t319, err319 := strconv.ParseFloat(path[1], 0)
				if err319 != nil {
					return err319
				}
				k = float64(t319)
				x1 := (x0)[k]
				_ = x1
				if len(path) > 2 {
					if path[2] == "A" {
						inspector.AssignBuf(&x1.A, value, buf)
						return nil
					}
					if path[2] == "S" {
						inspector.AssignBuf(&x1.S, value, buf)
						return nil
					}
					if path[2] == "B" {
						inspector.AssignBuf(&x1.B, value, buf)
						return nil
					}
					if path[2] == "I" {
						inspector.AssignBuf(&x1.I, value, buf)
						return nil
					}
					if path[2] == "I8" {
						inspector.AssignBuf(&x1.I8, value, buf)
						return nil
					}
					if path[2] == "I16" {
						inspector.AssignBuf(&x1.I16, value, buf)
						return nil
					}
					if path[2] == "I32" {
						inspector.AssignBuf(&x1.I32, value, buf)
						return nil
					}
					if path[2] == "I64" {
						inspector.AssignBuf(&x1.I64, value, buf)
						return nil
					}
					if path[2] == "U" {
						inspector.AssignBuf(&x1.U, value, buf)
						return nil
					}
					if path[2] == "U8" {
						inspector.AssignBuf(&x1.U8, value, buf)
						return nil
					}
					if path[2] == "U16" {
						inspector.AssignBuf(&x1.U16, value, buf)
						return nil
					}
					if path[2] == "U32" {
						inspector.AssignBuf(&x1.U32, value, buf)
						return nil
					}
					if path[2] == "U64" {
						inspector.AssignBuf(&x1.U64, value, buf)
						return nil
					}
					if path[2] == "F" {
						inspector.AssignBuf(&x1.F, value, buf)
						return nil
					}
					if path[2] == "D" {
						inspector.AssignBuf(&x1.D, value, buf)
						return nil
					}
				}
				(x0)[k] = x1
				return nil
			}
			x.FloatStructMap = x0
		}
		if path[0] == "FloatStructPtrMap" {
			x0 := x.FloatStructPtrMap
			if uvalue, ok := value.(*map[float64]*testobj.TestStruct); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(map[float64]*testobj.TestStruct)
				x0 = z
				x.FloatStructPtrMap = x0
			}
			_ = x0
			if len(path) > 1 {
				var k float64
				t320, err320 := strconv.ParseFloat(path[1], 0)
				if err320 != nil {
					return err320
				}
				k = float64(t320)
				x1 := (x0)[k]
				_ = x1
				if len(path) > 2 {
					if x1 == nil {
						return nil
					}
					if path[2] == "A" {
						inspector.AssignBuf(&x1.A, value, buf)
						return nil
					}
					if path[2] == "S" {
						inspector.AssignBuf(&x1.S, value, buf)
						return nil
					}
					if path[2] == "B" {
						inspector.AssignBuf(&x1.B, value, buf)
						return nil
					}
					if path[2] == "I" {
						inspector.AssignBuf(&x1.I, value, buf)
						return nil
					}
					if path[2] == "I8" {
						inspector.AssignBuf(&x1.I8, value, buf)
						return nil
					}
					if path[2] == "I16" {
						inspector.AssignBuf(&x1.I16, value, buf)
						return nil
					}
					if path[2] == "I32" {
						inspector.AssignBuf(&x1.I32, value, buf)
						return nil
					}
					if path[2] == "I64" {
						inspector.AssignBuf(&x1.I64, value, buf)
						return nil
					}
					if path[2] == "U" {
						inspector.AssignBuf(&x1.U, value, buf)
						return nil
					}
					if path[2] == "U8" {
						inspector.AssignBuf(&x1.U8, value, buf)
						return nil
					}
					if path[2] == "U16" {
						inspector.AssignBuf(&x1.U16, value, buf)
						return nil
					}
					if path[2] == "U32" {
						inspector.AssignBuf(&x1.U32, value, buf)
						return nil
					}
					if path[2] == "U64" {
						inspector.AssignBuf(&x1.U64, value, buf)
						return nil
					}
					if path[2] == "F" {
						inspector.AssignBuf(&x1.F, value, buf)
						return nil
					}
					if path[2] == "D" {
						inspector.AssignBuf(&x1.D, value, buf)
						return nil
					}
				}
				(x0)[k] = x1
				return nil
			}
			x.FloatStructPtrMap = x0
		}
		if path[0] == "FloatPtrStructMap" {
			x0 := x.FloatPtrStructMap
			if uvalue, ok := value.(*map[*float64]testobj.TestStruct); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(map[*float64]testobj.TestStruct)
				x0 = z
				x.FloatPtrStructMap = x0
			}
			_ = x0
			if len(path) > 1 {
				var k float64
				t321, err321 := strconv.ParseFloat(path[1], 0)
				if err321 != nil {
					return err321
				}
				k = float64(t321)
				x1 := (x0)[&k]
				_ = x1
				if len(path) > 2 {
					if path[2] == "A" {
						inspector.AssignBuf(&x1.A, value, buf)
						return nil
					}
					if path[2] == "S" {
						inspector.AssignBuf(&x1.S, value, buf)
						return nil
					}
					if path[2] == "B" {
						inspector.AssignBuf(&x1.B, value, buf)
						return nil
					}
					if path[2] == "I" {
						inspector.AssignBuf(&x1.I, value, buf)
						return nil
					}
					if path[2] == "I8" {
						inspector.AssignBuf(&x1.I8, value, buf)
						return nil
					}
					if path[2] == "I16" {
						inspector.AssignBuf(&x1.I16, value, buf)
						return nil
					}
					if path[2] == "I32" {
						inspector.AssignBuf(&x1.I32, value, buf)
						return nil
					}
					if path[2] == "I64" {
						inspector.AssignBuf(&x1.I64, value, buf)
						return nil
					}
					if path[2] == "U" {
						inspector.AssignBuf(&x1.U, value, buf)
						return nil
					}
					if path[2] == "U8" {
						inspector.AssignBuf(&x1.U8, value, buf)
						return nil
					}
					if path[2] == "U16" {
						inspector.AssignBuf(&x1.U16, value, buf)
						return nil
					}
					if path[2] == "U32" {
						inspector.AssignBuf(&x1.U32, value, buf)
						return nil
					}
					if path[2] == "U64" {
						inspector.AssignBuf(&x1.U64, value, buf)
						return nil
					}
					if path[2] == "F" {
						inspector.AssignBuf(&x1.F, value, buf)
						return nil
					}
					if path[2] == "D" {
						inspector.AssignBuf(&x1.D, value, buf)
						return nil
					}
				}
				(x0)[&k] = x1
				return nil
			}
			x.FloatPtrStructMap = x0
		}
		if path[0] == "FloatPtrStructPtrMap" {
			x0 := x.FloatPtrStructPtrMap
			if uvalue, ok := value.(*map[*float64]*testobj.TestStruct); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(map[*float64]*testobj.TestStruct)
				x0 = z
				x.FloatPtrStructPtrMap = x0
			}
			_ = x0
			if len(path) > 1 {
				var k float64
				t322, err322 := strconv.ParseFloat(path[1], 0)
				if err322 != nil {
					return err322
				}
				k = float64(t322)
				x1 := (x0)[&k]
				_ = x1
				if len(path) > 2 {
					if x1 == nil {
						return nil
					}
					if path[2] == "A" {
						inspector.AssignBuf(&x1.A, value, buf)
						return nil
					}
					if path[2] == "S" {
						inspector.AssignBuf(&x1.S, value, buf)
						return nil
					}
					if path[2] == "B" {
						inspector.AssignBuf(&x1.B, value, buf)
						return nil
					}
					if path[2] == "I" {
						inspector.AssignBuf(&x1.I, value, buf)
						return nil
					}
					if path[2] == "I8" {
						inspector.AssignBuf(&x1.I8, value, buf)
						return nil
					}
					if path[2] == "I16" {
						inspector.AssignBuf(&x1.I16, value, buf)
						return nil
					}
					if path[2] == "I32" {
						inspector.AssignBuf(&x1.I32, value, buf)
						return nil
					}
					if path[2] == "I64" {
						inspector.AssignBuf(&x1.I64, value, buf)
						return nil
					}
					if path[2] == "U" {
						inspector.AssignBuf(&x1.U, value, buf)
						return nil
					}
					if path[2] == "U8" {
						inspector.AssignBuf(&x1.U8, value, buf)
						return nil
					}
					if path[2] == "U16" {
						inspector.AssignBuf(&x1.U16, value, buf)
						return nil
					}
					if path[2] == "U32" {
						inspector.AssignBuf(&x1.U32, value, buf)
						return nil
					}
					if path[2] == "U64" {
						inspector.AssignBuf(&x1.U64, value, buf)
						return nil
					}
					if path[2] == "F" {
						inspector.AssignBuf(&x1.F, value, buf)
						return nil
					}
					if path[2] == "D" {
						inspector.AssignBuf(&x1.D, value, buf)
						return nil
					}
				}
				(x0)[&k] = x1
				return nil
			}
			x.FloatPtrStructPtrMap = x0
		}
		if path[0] == "FloatPtrStructPtrMapPtr" {
			x0 := x.FloatPtrStructPtrMapPtr
			if uvalue, ok := value.(*map[*float64]*testobj.TestStruct); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(map[*float64]*testobj.TestStruct)
				x0 = &z
				x.FloatPtrStructPtrMapPtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var k float64
				t323, err323 := strconv.ParseFloat(path[1], 0)
				if err323 != nil {
					return err323
				}
				k = float64(t323)
				x1 := (*x0)[&k]
				_ = x1
				if len(path) > 2 {
					if x1 == nil {
						return nil
					}
					if path[2] == "A" {
						inspector.AssignBuf(&x1.A, value, buf)
						return nil
					}
					if path[2] == "S" {
						inspector.AssignBuf(&x1.S, value, buf)
						return nil
					}
					if path[2] == "B" {
						inspector.AssignBuf(&x1.B, value, buf)
						return nil
					}
					if path[2] == "I" {
						inspector.AssignBuf(&x1.I, value, buf)
						return nil
					}
					if path[2] == "I8" {
						inspector.AssignBuf(&x1.I8, value, buf)
						return nil
					}
					if path[2] == "I16" {
						inspector.AssignBuf(&x1.I16, value, buf)
						return nil
					}
					if path[2] == "I32" {
						inspector.AssignBuf(&x1.I32, value, buf)
						return nil
					}
					if path[2] == "I64" {
						inspector.AssignBuf(&x1.I64, value, buf)
						return nil
					}
					if path[2] == "U" {
						inspector.AssignBuf(&x1.U, value, buf)
						return nil
					}
					if path[2] == "U8" {
						inspector.AssignBuf(&x1.U8, value, buf)
						return nil
					}
					if path[2] == "U16" {
						inspector.AssignBuf(&x1.U16, value, buf)
						return nil
					}
					if path[2] == "U32" {
						inspector.AssignBuf(&x1.U32, value, buf)
						return nil
					}
					if path[2] == "U64" {
						inspector.AssignBuf(&x1.U64, value, buf)
						return nil
					}
					if path[2] == "F" {
						inspector.AssignBuf(&x1.F, value, buf)
						return nil
					}
					if path[2] == "D" {
						inspector.AssignBuf(&x1.D, value, buf)
						return nil
					}
				}
				(*x0)[&k] = x1
				return nil
			}
			x.FloatPtrStructPtrMapPtr = x0
		}
		if path[0] == "NestedStruct" {
			x0 := &x.NestedStruct
			if uvalue, ok := value.(*testobj.TestStruct); ok {
				x0 = uvalue
			}
			_ = x0
			if len(path) > 1 {
				if path[1] == "A" {
					inspector.AssignBuf(&x0.A, value, buf)
					return nil
				}
				if path[1] == "S" {
					inspector.AssignBuf(&x0.S, value, buf)
					return nil
				}
				if path[1] == "B" {
					inspector.AssignBuf(&x0.B, value, buf)
					return nil
				}
				if path[1] == "I" {
					inspector.AssignBuf(&x0.I, value, buf)
					return nil
				}
				if path[1] == "I8" {
					inspector.AssignBuf(&x0.I8, value, buf)
					return nil
				}
				if path[1] == "I16" {
					inspector.AssignBuf(&x0.I16, value, buf)
					return nil
				}
				if path[1] == "I32" {
					inspector.AssignBuf(&x0.I32, value, buf)
					return nil
				}
				if path[1] == "I64" {
					inspector.AssignBuf(&x0.I64, value, buf)
					return nil
				}
				if path[1] == "U" {
					inspector.AssignBuf(&x0.U, value, buf)
					return nil
				}
				if path[1] == "U8" {
					inspector.AssignBuf(&x0.U8, value, buf)
					return nil
				}
				if path[1] == "U16" {
					inspector.AssignBuf(&x0.U16, value, buf)
					return nil
				}
				if path[1] == "U32" {
					inspector.AssignBuf(&x0.U32, value, buf)
					return nil
				}
				if path[1] == "U64" {
					inspector.AssignBuf(&x0.U64, value, buf)
					return nil
				}
				if path[1] == "F" {
					inspector.AssignBuf(&x0.F, value, buf)
					return nil
				}
				if path[1] == "D" {
					inspector.AssignBuf(&x0.D, value, buf)
					return nil
				}
			}
			x.NestedStruct = *x0
		}
		if path[0] == "NestedStructPtr" {
			x0 := x.NestedStructPtr
			if uvalue, ok := value.(*testobj.TestStruct); ok {
				x0 = uvalue
			}
			if x0 == nil {
				x0 = &testobj.TestStruct{}
				x.NestedStructPtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				if path[1] == "A" {
					inspector.AssignBuf(&x0.A, value, buf)
					return nil
				}
				if path[1] == "S" {
					inspector.AssignBuf(&x0.S, value, buf)
					return nil
				}
				if path[1] == "B" {
					inspector.AssignBuf(&x0.B, value, buf)
					return nil
				}
				if path[1] == "I" {
					inspector.AssignBuf(&x0.I, value, buf)
					return nil
				}
				if path[1] == "I8" {
					inspector.AssignBuf(&x0.I8, value, buf)
					return nil
				}
				if path[1] == "I16" {
					inspector.AssignBuf(&x0.I16, value, buf)
					return nil
				}
				if path[1] == "I32" {
					inspector.AssignBuf(&x0.I32, value, buf)
					return nil
				}
				if path[1] == "I64" {
					inspector.AssignBuf(&x0.I64, value, buf)
					return nil
				}
				if path[1] == "U" {
					inspector.AssignBuf(&x0.U, value, buf)
					return nil
				}
				if path[1] == "U8" {
					inspector.AssignBuf(&x0.U8, value, buf)
					return nil
				}
				if path[1] == "U16" {
					inspector.AssignBuf(&x0.U16, value, buf)
					return nil
				}
				if path[1] == "U32" {
					inspector.AssignBuf(&x0.U32, value, buf)
					return nil
				}
				if path[1] == "U64" {
					inspector.AssignBuf(&x0.U64, value, buf)
					return nil
				}
				if path[1] == "F" {
					inspector.AssignBuf(&x0.F, value, buf)
					return nil
				}
				if path[1] == "D" {
					inspector.AssignBuf(&x0.D, value, buf)
					return nil
				}
			}
			x.NestedStructPtr = x0
		}
	}
	return nil
}

func (i6 TestObject1Inspector) Set(dst, value any, path ...string) error {
	return i6.SetWithBuffer(dst, value, nil, path...)
}

func (i6 TestObject1Inspector) DeepEqual(l, r any) bool {
	return i6.DeepEqualWithOptions(l, r, nil)
}

func (i6 TestObject1Inspector) DeepEqualWithOptions(l, r any, opts *inspector.DEQOptions) bool {
	var (
		lx, rx   *testobj.TestObject1
		leq, req bool
	)
	_, _, _, _ = lx, rx, leq, req
	if lp, ok := l.(**testobj.TestObject1); ok {
		lx, leq = *lp, true
	} else if lp, ok := l.(*testobj.TestObject1); ok {
		lx, leq = lp, true
	} else if lp, ok := l.(testobj.TestObject1); ok {
		lx, leq = &lp, true
	}
	if rp, ok := r.(**testobj.TestObject1); ok {
		rx, req = *rp, true
	} else if rp, ok := r.(*testobj.TestObject1); ok {
		rx, req = rp, true
	} else if rp, ok := r.(testobj.TestObject1); ok {
		rx, req = &rp, true
	}
	if !leq || !req {
		return false
	}
	if lx == nil && rx == nil {
		return true
	}
	if (lx == nil && rx != nil) || (lx != nil && rx == nil) {
		return false
	}

	lx1 := lx.IntSlice
	rx1 := rx.IntSlice
	_, _ = lx1, rx1
	if inspector.DEQMustCheck("IntSlice", opts) {
		if len(lx1) != len(rx1) {
			return false
		}
		for i := 0; i < len(lx1); i++ {
			lx2 := (lx1)[i]
			rx2 := (rx1)[i]
			_, _ = lx2, rx2
			if lx2 != rx2 {
				return false
			}
		}
	}
	lx3 := lx.IntPtrSlice
	rx3 := rx.IntPtrSlice
	_, _ = lx3, rx3
	if inspector.DEQMustCheck("IntPtrSlice", opts) {
		if len(lx3) != len(rx3) {
			return false
		}
		for i := 0; i < len(lx3); i++ {
			lx4 := (lx3)[i]
			rx4 := (rx3)[i]
			_, _ = lx4, rx4
			if (lx4 == nil && rx4 != nil) || (lx4 != nil && rx4 == nil) {
				return false
			}
			if lx4 != nil && rx4 != nil {
				if *lx4 != *rx4 {
					return false
				}
			}
		}
	}
	lx5 := lx.IntSlicePtr
	rx5 := rx.IntSlicePtr
	_, _ = lx5, rx5
	if (lx5 == nil && rx5 != nil) || (lx5 != nil && rx5 == nil) {
		return false
	}
	if lx5 != nil && rx5 != nil {
		if inspector.DEQMustCheck("IntSlicePtr", opts) {
			if len(*lx5) != len(*rx5) {
				return false
			}
			for i := 0; i < len(*lx5); i++ {
				lx6 := (*lx5)[i]
				rx6 := (*rx5)[i]
				_, _ = lx6, rx6
				if lx6 != rx6 {
					return false
				}
			}
		}
	}
	lx7 := lx.IntPtrSlicePtr
	rx7 := rx.IntPtrSlicePtr
	_, _ = lx7, rx7
	if (lx7 == nil && rx7 != nil) || (lx7 != nil && rx7 == nil) {
		return false
	}
	if lx7 != nil && rx7 != nil {
		if inspector.DEQMustCheck("IntPtrSlicePtr", opts) {
			if len(*lx7) != len(*rx7) {
				return false
			}
			for i := 0; i < len(*lx7); i++ {
				lx8 := (*lx7)[i]
				rx8 := (*rx7)[i]
				_, _ = lx8, rx8
				if (lx8 == nil && rx8 != nil) || (lx8 != nil && rx8 == nil) {
					return false
				}
				if lx8 != nil && rx8 != nil {
					if *lx8 != *rx8 {
						return false
					}
				}
			}
		}
	}
	if !bytes.Equal(lx.ByteSlice, rx.ByteSlice) && inspector.DEQMustCheck("ByteSlice", opts) {
		return false
	}
	lx9 := lx.BytePtrSlice
	rx9 := rx.BytePtrSlice
	_, _ = lx9, rx9
	if inspector.DEQMustCheck("BytePtrSlice", opts) {
		if len(lx9) != len(rx9) {
			return false
		}
		for i := 0; i < len(lx9); i++ {
			lx10 := (lx9)[i]
			rx10 := (rx9)[i]
			_, _ = lx10, rx10
			if (lx10 == nil && rx10 != nil) || (lx10 != nil && rx10 == nil) {
				return false
			}
			if lx10 != nil && rx10 != nil {
				if *lx10 != *rx10 {
					return false
				}
			}
		}
	}
	if (lx == nil && rx != nil) || (lx != nil && rx == nil) {
		return false
	}
	if lx != nil && rx != nil {
		if !bytes.Equal(*lx.ByteSlicePtr, *rx.ByteSlicePtr) && inspector.DEQMustCheck("ByteSlicePtr", opts) {
			return false
		}
	}
	lx11 := lx.BytePtrSlicePtr
	rx11 := rx.BytePtrSlicePtr
	_, _ = lx11, rx11
	if (lx11 == nil && rx11 != nil) || (lx11 != nil && rx11 == nil) {
		return false
	}
	if lx11 != nil && rx11 != nil {
		if inspector.DEQMustCheck("BytePtrSlicePtr", opts) {
			if len(*lx11) != len(*rx11) {
				return false
			}
			for i := 0; i < len(*lx11); i++ {
				lx12 := (*lx11)[i]
				rx12 := (*rx11)[i]
				_, _ = lx12, rx12
				if (lx12 == nil && rx12 != nil) || (lx12 != nil && rx12 == nil) {
					return false
				}
				if lx12 != nil && rx12 != nil {
					if *lx12 != *rx12 {
						return false
					}
				}
			}
		}
	}
	lx13 := lx.FloatSlice
	rx13 := rx.FloatSlice
	_, _ = lx13, rx13
	if inspector.DEQMustCheck("FloatSlice", opts) {
		if len(lx13) != len(rx13) {
			return false
		}
		for i := 0; i < len(lx13); i++ {
			lx14 := (lx13)[i]
			rx14 := (rx13)[i]
			_, _ = lx14, rx14
			if lx14 != rx14 {
				return false
			}
		}
	}
	lx15 := lx.FloatPtrSlice
	rx15 := rx.FloatPtrSlice
	_, _ = lx15, rx15
	if inspector.DEQMustCheck("FloatPtrSlice", opts) {
		if len(lx15) != len(rx15) {
			return false
		}
		for i := 0; i < len(lx15); i++ {
			lx16 := (lx15)[i]
			rx16 := (rx15)[i]
			_, _ = lx16, rx16
			if (lx16 == nil && rx16 != nil) || (lx16 != nil && rx16 == nil) {
				return false
			}
			if lx16 != nil && rx16 != nil {
				if *lx16 != *rx16 {
					return false
				}
			}
		}
	}
	lx17 := lx.FloatSlicePtr
	rx17 := rx.FloatSlicePtr
	_, _ = lx17, rx17
	if (lx17 == nil && rx17 != nil) || (lx17 != nil && rx17 == nil) {
		return false
	}
	if lx17 != nil && rx17 != nil {
		if inspector.DEQMustCheck("FloatSlicePtr", opts) {
			if len(*lx17) != len(*rx17) {
				return false
			}
			for i := 0; i < len(*lx17); i++ {
				lx18 := (*lx17)[i]
				rx18 := (*rx17)[i]
				_, _ = lx18, rx18
				if lx18 != rx18 {
					return false
				}
			}
		}
	}
	lx19 := lx.FloatPtrSlicePtr
	rx19 := rx.FloatPtrSlicePtr
	_, _ = lx19, rx19
	if (lx19 == nil && rx19 != nil) || (lx19 != nil && rx19 == nil) {
		return false
	}
	if lx19 != nil && rx19 != nil {
		if inspector.DEQMustCheck("FloatPtrSlicePtr", opts) {
			if len(*lx19) != len(*rx19) {
				return false
			}
			for i := 0; i < len(*lx19); i++ {
				lx20 := (*lx19)[i]
				rx20 := (*rx19)[i]
				_, _ = lx20, rx20
				if (lx20 == nil && rx20 != nil) || (lx20 != nil && rx20 == nil) {
					return false
				}
				if lx20 != nil && rx20 != nil {
					if *lx20 != *rx20 {
						return false
					}
				}
			}
		}
	}
	lx21 := lx.StructSlice
	rx21 := rx.StructSlice
	_, _ = lx21, rx21
	if inspector.DEQMustCheck("StructSlice", opts) {
		if len(lx21) != len(rx21) {
			return false
		}
		for i := 0; i < len(lx21); i++ {
			lx22 := (lx21)[i]
			rx22 := (rx21)[i]
			_, _ = lx22, rx22
			if lx22.A != rx22.A && inspector.DEQMustCheck("StructSlice.A", opts) {
				return false
			}
			if lx22.S != rx22.S && inspector.DEQMustCheck("StructSlice.S", opts) {
				return false
			}
			if !bytes.Equal(lx22.B, rx22.B) && inspector.DEQMustCheck("StructSlice.B", opts) {
				return false
			}
			if lx22.I != rx22.I && inspector.DEQMustCheck("StructSlice.I", opts) {
				return false
			}
			if lx22.I8 != rx22.I8 && inspector.DEQMustCheck("StructSlice.I8", opts) {
				return false
			}
			if lx22.I16 != rx22.I16 && inspector.DEQMustCheck("StructSlice.I16", opts) {
				return false
			}
			if lx22.I32 != rx22.I32 && inspector.DEQMustCheck("StructSlice.I32", opts) {
				return false
			}
			if lx22.I64 != rx22.I64 && inspector.DEQMustCheck("StructSlice.I64", opts) {
				return false
			}
			if lx22.U != rx22.U && inspector.DEQMustCheck("StructSlice.U", opts) {
				return false
			}
			if lx22.U8 != rx22.U8 && inspector.DEQMustCheck("StructSlice.U8", opts) {
				return false
			}
			if lx22.U16 != rx22.U16 && inspector.DEQMustCheck("StructSlice.U16", opts) {
				return false
			}
			if lx22.U32 != rx22.U32 && inspector.DEQMustCheck("StructSlice.U32", opts) {
				return false
			}
			if lx22.U64 != rx22.U64 && inspector.DEQMustCheck("StructSlice.U64", opts) {
				return false
			}
			if !inspector.EqualFloat32(lx22.F, rx22.F, opts) && inspector.DEQMustCheck("StructSlice.F", opts) {
				return false
			}
			if !inspector.EqualFloat64(lx22.D, rx22.D, opts) && inspector.DEQMustCheck("StructSlice.D", opts) {
				return false
			}
		}
	}
	lx23 := lx.StructPtrSlice
	rx23 := rx.StructPtrSlice
	_, _ = lx23, rx23
	if inspector.DEQMustCheck("StructPtrSlice", opts) {
		if len(lx23) != len(rx23) {
			return false
		}
		for i := 0; i < len(lx23); i++ {
			lx24 := (lx23)[i]
			rx24 := (rx23)[i]
			_, _ = lx24, rx24
			if (lx24 == nil && rx24 != nil) || (lx24 != nil && rx24 == nil) {
				return false
			}
			if lx24 != nil && rx24 != nil {
				if lx24.A != rx24.A && inspector.DEQMustCheck("StructPtrSlice.A", opts) {
					return false
				}
				if lx24.S != rx24.S && inspector.DEQMustCheck("StructPtrSlice.S", opts) {
					return false
				}
				if !bytes.Equal(lx24.B, rx24.B) && inspector.DEQMustCheck("StructPtrSlice.B", opts) {
					return false
				}
				if lx24.I != rx24.I && inspector.DEQMustCheck("StructPtrSlice.I", opts) {
					return false
				}
				if lx24.I8 != rx24.I8 && inspector.DEQMustCheck("StructPtrSlice.I8", opts) {
					return false
				}
				if lx24.I16 != rx24.I16 && inspector.DEQMustCheck("StructPtrSlice.I16", opts) {
					return false
				}
				if lx24.I32 != rx24.I32 && inspector.DEQMustCheck("StructPtrSlice.I32", opts) {
					return false
				}
				if lx24.I64 != rx24.I64 && inspector.DEQMustCheck("StructPtrSlice.I64", opts) {
					return false
				}
				if lx24.U != rx24.U && inspector.DEQMustCheck("StructPtrSlice.U", opts) {
					return false
				}
				if lx24.U8 != rx24.U8 && inspector.DEQMustCheck("StructPtrSlice.U8", opts) {
					return false
				}
				if lx24.U16 != rx24.U16 && inspector.DEQMustCheck("StructPtrSlice.U16", opts) {
					return false
				}
				if lx24.U32 != rx24.U32 && inspector.DEQMustCheck("StructPtrSlice.U32", opts) {
					return false
				}
				if lx24.U64 != rx24.U64 && inspector.DEQMustCheck("StructPtrSlice.U64", opts) {
					return false
				}
				if !inspector.EqualFloat32(lx24.F, rx24.F, opts) && inspector.DEQMustCheck("StructPtrSlice.F", opts) {
					return false
				}
				if !inspector.EqualFloat64(lx24.D, rx24.D, opts) && inspector.DEQMustCheck("StructPtrSlice.D", opts) {
					return false
				}
			}
		}
	}
	lx25 := lx.StructSlicePtr
	rx25 := rx.StructSlicePtr
	_, _ = lx25, rx25
	if (lx25 == nil && rx25 != nil) || (lx25 != nil && rx25 == nil) {
		return false
	}
	if lx25 != nil && rx25 != nil {
		if inspector.DEQMustCheck("StructSlicePtr", opts) {
			if len(*lx25) != len(*rx25) {
				return false
			}
			for i := 0; i < len(*lx25); i++ {
				lx26 := (*lx25)[i]
				rx26 := (*rx25)[i]
				_, _ = lx26, rx26
				if lx26.A != rx26.A && inspector.DEQMustCheck("StructSlicePtr.A", opts) {
					return false
				}
				if lx26.S != rx26.S && inspector.DEQMustCheck("StructSlicePtr.S", opts) {
					return false
				}
				if !bytes.Equal(lx26.B, rx26.B) && inspector.DEQMustCheck("StructSlicePtr.B", opts) {
					return false
				}
				if lx26.I != rx26.I && inspector.DEQMustCheck("StructSlicePtr.I", opts) {
					return false
				}
				if lx26.I8 != rx26.I8 && inspector.DEQMustCheck("StructSlicePtr.I8", opts) {
					return false
				}
				if lx26.I16 != rx26.I16 && inspector.DEQMustCheck("StructSlicePtr.I16", opts) {
					return false
				}
				if lx26.I32 != rx26.I32 && inspector.DEQMustCheck("StructSlicePtr.I32", opts) {
					return false
				}
				if lx26.I64 != rx26.I64 && inspector.DEQMustCheck("StructSlicePtr.I64", opts) {
					return false
				}
				if lx26.U != rx26.U && inspector.DEQMustCheck("StructSlicePtr.U", opts) {
					return false
				}
				if lx26.U8 != rx26.U8 && inspector.DEQMustCheck("StructSlicePtr.U8", opts) {
					return false
				}
				if lx26.U16 != rx26.U16 && inspector.DEQMustCheck("StructSlicePtr.U16", opts) {
					return false
				}
				if lx26.U32 != rx26.U32 && inspector.DEQMustCheck("StructSlicePtr.U32", opts) {
					return false
				}
				if lx26.U64 != rx26.U64 && inspector.DEQMustCheck("StructSlicePtr.U64", opts) {
					return false
				}
				if !inspector.EqualFloat32(lx26.F, rx26.F, opts) && inspector.DEQMustCheck("StructSlicePtr.F", opts) {
					return false
				}
				if !inspector.EqualFloat64(lx26.D, rx26.D, opts) && inspector.DEQMustCheck("StructSlicePtr.D", opts) {
					return false
				}
			}
		}
	}
	lx27 := lx.StructPtrSlicePtr
	rx27 := rx.StructPtrSlicePtr
	_, _ = lx27, rx27
	if (lx27 == nil && rx27 != nil) || (lx27 != nil && rx27 == nil) {
		return false
	}
	if lx27 != nil && rx27 != nil {
		if inspector.DEQMustCheck("StructPtrSlicePtr", opts) {
			if len(*lx27) != len(*rx27) {
				return false
			}
			for i := 0; i < len(*lx27); i++ {
				lx28 := (*lx27)[i]
				rx28 := (*rx27)[i]
				_, _ = lx28, rx28
				if (lx28 == nil && rx28 != nil) || (lx28 != nil && rx28 == nil) {
					return false
				}
				if lx28 != nil && rx28 != nil {
					if lx28.A != rx28.A && inspector.DEQMustCheck("StructPtrSlicePtr.A", opts) {
						return false
					}
					if lx28.S != rx28.S && inspector.DEQMustCheck("StructPtrSlicePtr.S", opts) {
						return false
					}
					if !bytes.Equal(lx28.B, rx28.B) && inspector.DEQMustCheck("StructPtrSlicePtr.B", opts) {
						return false
					}
					if lx28.I != rx28.I && inspector.DEQMustCheck("StructPtrSlicePtr.I", opts) {
						return false
					}
					if lx28.I8 != rx28.I8 && inspector.DEQMustCheck("StructPtrSlicePtr.I8", opts) {
						return false
					}
					if lx28.I16 != rx28.I16 && inspector.DEQMustCheck("StructPtrSlicePtr.I16", opts) {
						return false
					}
					if lx28.I32 != rx28.I32 && inspector.DEQMustCheck("StructPtrSlicePtr.I32", opts) {
						return false
					}
					if lx28.I64 != rx28.I64 && inspector.DEQMustCheck("StructPtrSlicePtr.I64", opts) {
						return false
					}
					if lx28.U != rx28.U && inspector.DEQMustCheck("StructPtrSlicePtr.U", opts) {
						return false
					}
					if lx28.U8 != rx28.U8 && inspector.DEQMustCheck("StructPtrSlicePtr.U8", opts) {
						return false
					}
					if lx28.U16 != rx28.U16 && inspector.DEQMustCheck("StructPtrSlicePtr.U16", opts) {
						return false
					}
					if lx28.U32 != rx28.U32 && inspector.DEQMustCheck("StructPtrSlicePtr.U32", opts) {
						return false
					}
					if lx28.U64 != rx28.U64 && inspector.DEQMustCheck("StructPtrSlicePtr.U64", opts) {
						return false
					}
					if !inspector.EqualFloat32(lx28.F, rx28.F, opts) && inspector.DEQMustCheck("StructPtrSlicePtr.F", opts) {
						return false
					}
					if !inspector.EqualFloat64(lx28.D, rx28.D, opts) && inspector.DEQMustCheck("StructPtrSlicePtr.D", opts) {
						return false
					}
				}
			}
		}
	}
	lx29 := lx.StructSliceLiteral
	rx29 := rx.StructSliceLiteral
	_, _ = lx29, rx29
	if inspector.DEQMustCheck("StructSliceLiteral", opts) {
		if len(lx29) != len(rx29) {
			return false
		}
		for i := 0; i < len(lx29); i++ {
			lx30 := (lx29)[i]
			rx30 := (rx29)[i]
			_, _ = lx30, rx30
			if (lx30 == nil && rx30 != nil) || (lx30 != nil && rx30 == nil) {
				return false
			}
			if lx30 != nil && rx30 != nil {
				if lx30.A != rx30.A && inspector.DEQMustCheck("StructSliceLiteral.A", opts) {
					return false
				}
				if lx30.S != rx30.S && inspector.DEQMustCheck("StructSliceLiteral.S", opts) {
					return false
				}
				if !bytes.Equal(lx30.B, rx30.B) && inspector.DEQMustCheck("StructSliceLiteral.B", opts) {
					return false
				}
				if lx30.I != rx30.I && inspector.DEQMustCheck("StructSliceLiteral.I", opts) {
					return false
				}
				if lx30.I8 != rx30.I8 && inspector.DEQMustCheck("StructSliceLiteral.I8", opts) {
					return false
				}
				if lx30.I16 != rx30.I16 && inspector.DEQMustCheck("StructSliceLiteral.I16", opts) {
					return false
				}
				if lx30.I32 != rx30.I32 && inspector.DEQMustCheck("StructSliceLiteral.I32", opts) {
					return false
				}
				if lx30.I64 != rx30.I64 && inspector.DEQMustCheck("StructSliceLiteral.I64", opts) {
					return false
				}
				if lx30.U != rx30.U && inspector.DEQMustCheck("StructSliceLiteral.U", opts) {
					return false
				}
				if lx30.U8 != rx30.U8 && inspector.DEQMustCheck("StructSliceLiteral.U8", opts) {
					return false
				}
				if lx30.U16 != rx30.U16 && inspector.DEQMustCheck("StructSliceLiteral.U16", opts) {
					return false
				}
				if lx30.U32 != rx30.U32 && inspector.DEQMustCheck("StructSliceLiteral.U32", opts) {
					return false
				}
				if lx30.U64 != rx30.U64 && inspector.DEQMustCheck("StructSliceLiteral.U64", opts) {
					return false
				}
				if !inspector.EqualFloat32(lx30.F, rx30.F, opts) && inspector.DEQMustCheck("StructSliceLiteral.F", opts) {
					return false
				}
				if !inspector.EqualFloat64(lx30.D, rx30.D, opts) && inspector.DEQMustCheck("StructSliceLiteral.D", opts) {
					return false
				}
			}
		}
	}
	lx31 := lx.IntStringMap
	rx31 := rx.IntStringMap
	_, _ = lx31, rx31
	if inspector.DEQMustCheck("IntStringMap", opts) {
		if len(lx31) != len(rx31) {
			return false
		}
		for k := range lx31 {
			lx32 := (lx31)[k]
			rx32, ok32 := (rx31)[k]
			_, _, _ = lx32, rx32, ok32
			if !ok32 {
				return false
			}
			if lx32 != rx32 {
				return false
			}
		}
	}
	lx33 := lx.IntStringPtrMap
	rx33 := rx.IntStringPtrMap
	_, _ = lx33, rx33
	if inspector.DEQMustCheck("IntStringPtrMap", opts) {
		if len(lx33) != len(rx33) {
			return false
		}
		for k := range lx33 {
			lx34 := (lx33)[k]
			rx34, ok34 := (rx33)[k]
			_, _, _ = lx34, rx34, ok34
			if !ok34 {
				return false
			}
			if (lx34 == nil && rx34 != nil) || (lx34 != nil && rx34 == nil) {
				return false
			}
			if lx34 != nil && rx34 != nil {
				if *lx34 != *rx34 {
					return false
				}
			}
		}
	}
	lx35 := lx.IntStringMapPtr
	rx35 := rx.IntStringMapPtr
	_, _ = lx35, rx35
	if (lx35 == nil && rx35 != nil) || (lx35 != nil && rx35 == nil) {
		return false
	}
	if lx35 != nil && rx35 != nil {
		if inspector.DEQMustCheck("IntStringMapPtr", opts) {
			if len(*lx35) != len(*rx35) {
				return false
			}
			for k := range *lx35 {
				lx36 := (*lx35)[k]
				rx36, ok36 := (*rx35)[k]
				_, _, _ = lx36, rx36, ok36
				if !ok36 {
					return false
				}
				if lx36 != rx36 {
					return false
				}
			}
		}
	}
	lx37 := lx.IntStringPtrMapPtr
	rx37 := rx.IntStringPtrMapPtr
	_, _ = lx37, rx37
	if (lx37 == nil && rx37 != nil) || (lx37 != nil && rx37 == nil) {
		return false
	}
	if lx37 != nil && rx37 != nil {
		if inspector.DEQMustCheck("IntStringPtrMapPtr", opts) {
			if len(*lx37) != len(*rx37) {
				return false
			}
			for k := range *lx37 {
				lx38 := (*lx37)[k]
				rx38, ok38 := (*rx37)[k]
				_, _, _ = lx38, rx38, ok38
				if !ok38 {
					return false
				}
				if (lx38 == nil && rx38 != nil) || (lx38 != nil && rx38 == nil) {
					return false
				}
				if lx38 != nil && rx38 != nil {
					if *lx38 != *rx38 {
						return false
					}
				}
			}
		}
	}
	lx39 := lx.IntPtrStringPtrMapPtr
	rx39 := rx.IntPtrStringPtrMapPtr
	_, _ = lx39, rx39
	if (lx39 == nil && rx39 != nil) || (lx39 != nil && rx39 == nil) {
		return false
	}
	if lx39 != nil && rx39 != nil {
		if inspector.DEQMustCheck("IntPtrStringPtrMapPtr", opts) {
			if len(*lx39) != len(*rx39) {
				return false
			}
			for k := range *lx39 {
				lx40 := (*lx39)[k]
				rx40, ok40 := (*rx39)[k]
				_, _, _ = lx40, rx40, ok40
				if !ok40 {
					return false
				}
				if (lx40 == nil && rx40 != nil) || (lx40 != nil && rx40 == nil) {
					return false
				}
				if lx40 != nil && rx40 != nil {
					if *lx40 != *rx40 {
						return false
					}
				}
			}
		}
	}
	lx41 := lx.IntIntMapMap
	rx41 := rx.IntIntMapMap
	_, _ = lx41, rx41
	if inspector.DEQMustCheck("IntIntMapMap", opts) {
		if len(lx41) != len(rx41) {
			return false
		}
		for k := range lx41 {
			lx42 := (lx41)[k]
			rx42, ok42 := (rx41)[k]
			_, _, _ = lx42, rx42, ok42
			if !ok42 {
				return false
			}
			if len(lx42) != len(rx42) {
				return false
			}
			for k := range lx42 {
				lx43 := (lx42)[k]
				rx43, ok43 := (rx42)[k]
				_, _, _ = lx43, rx43, ok43
				if !ok43 {
					return false
				}
				if lx43 != rx43 {
					return false
				}
			}
		}
	}
	lx44 := lx.StringFloatMap
	rx44 := rx.StringFloatMap
	_, _ = lx44, rx44
	if inspector.DEQMustCheck("StringFloatMap", opts) {
		if len(lx44) != len(rx44) {
			return false
		}
		for k := range lx44 {
			lx45 := (lx44)[k]
			rx45, ok45 := (rx44)[k]
			_, _, _ = lx45, rx45, ok45
			if !ok45 {
				return false
			}
			if lx45 != rx45 {
				return false
			}
		}
	}
	lx46 := lx.StringFloatPtrMap
	rx46 := rx.StringFloatPtrMap
	_, _ = lx46, rx46
	if inspector.DEQMustCheck("StringFloatPtrMap", opts) {
		if len(lx46) != len(rx46) {
			return false
		}
		for k := range lx46 {
			lx47 := (lx46)[k]
			rx47, ok47 := (rx46)[k]
			_, _, _ = lx47, rx47, ok47
			if !ok47 {
				return false
			}
			if (lx47 == nil && rx47 != nil) || (lx47 != nil && rx47 == nil) {
				return false
			}
			if lx47 != nil && rx47 != nil {
				if *lx47 != *rx47 {
					return false
				}
			}
		}
	}
	lx48 := lx.StringFloatMapPtr
	rx48 := rx.StringFloatMapPtr
	_, _ = lx48, rx48
	if (lx48 == nil && rx48 != nil) || (lx48 != nil && rx48 == nil) {
		return false
	}
	if lx48 != nil && rx48 != nil {
		if inspector.DEQMustCheck("StringFloatMapPtr", opts) {
			if len(*lx48) != len(*rx48) {
				return false
			}
			for k := range *lx48 {
				lx49 := (*lx48)[k]
				rx49, ok49 := (*rx48)[k]
				_, _, _ = lx49, rx49, ok49
				if !ok49 {
					return false
				}
				if lx49 != rx49 {
					return false
				}
			}
		}
	}
	lx50 := lx.StringFloatPtrMapPtr
	rx50 := rx.StringFloatPtrMapPtr
	_, _ = lx50, rx50
	if (lx50 == nil && rx50 != nil) || (lx50 != nil && rx50 == nil) {
		return false
	}
	if lx50 != nil && rx50 != nil {
		if inspector.DEQMustCheck("StringFloatPtrMapPtr", opts) {
			if len(*lx50) != len(*rx50) {
				return false
			}
			for k := range *lx50 {
				lx51 := (*lx50)[k]
				rx51, ok51 := (*rx50)[k]
				_, _, _ = lx51, rx51, ok51
				if !ok51 {
					return false
				}
				if (lx51 == nil && rx51 != nil) || (lx51 != nil && rx51 == nil) {
					return false
				}
				if lx51 != nil && rx51 != nil {
					if *lx51 != *rx51 {
						return false
					}
				}
			}
		}
	}
	lx52 := lx.StringPtrFloatPtrMapPtr
	rx52 := rx.StringPtrFloatPtrMapPtr
	_, _ = lx52, rx52
	if (lx52 == nil && rx52 != nil) || (lx52 != nil && rx52 == nil) {
		return false
	}
	if lx52 != nil && rx52 != nil {
		if inspector.DEQMustCheck("StringPtrFloatPtrMapPtr", opts) {
			if len(*lx52) != len(*rx52) {
				return false
			}
			for k := range *lx52 {
				lx53 := (*lx52)[k]
				rx53, ok53 := (*rx52)[k]
				_, _, _ = lx53, rx53, ok53
				if !ok53 {
					return false
				}
				if (lx53 == nil && rx53 != nil) || (lx53 != nil && rx53 == nil) {
					return false
				}
				if lx53 != nil && rx53 != nil {
					if *lx53 != *rx53 {
						return false
					}
				}
			}
		}
	}
	lx54 := lx.FloatStructMap
	rx54 := rx.FloatStructMap
	_, _ = lx54, rx54
	if inspector.DEQMustCheck("FloatStructMap", opts) {
		if len(lx54) != len(rx54) {
			return false
		}
		for k := range lx54 {
			lx55 := (lx54)[k]
			rx55, ok55 := (rx54)[k]
			_, _, _ = lx55, rx55, ok55
			if !ok55 {
				return false
			}
			if lx55.A != rx55.A && inspector.DEQMustCheck("FloatStructMap.A", opts) {
				return false
			}
			if lx55.S != rx55.S && inspector.DEQMustCheck("FloatStructMap.S", opts) {
				return false
			}
			if !bytes.Equal(lx55.B, rx55.B) && inspector.DEQMustCheck("FloatStructMap.B", opts) {
				return false
			}
			if lx55.I != rx55.I && inspector.DEQMustCheck("FloatStructMap.I", opts) {
				return false
			}
			if lx55.I8 != rx55.I8 && inspector.DEQMustCheck("FloatStructMap.I8", opts) {
				return false
			}
			if lx55.I16 != rx55.I16 && inspector.DEQMustCheck("FloatStructMap.I16", opts) {
				return false
			}
			if lx55.I32 != rx55.I32 && inspector.DEQMustCheck("FloatStructMap.I32", opts) {
				return false
			}
			if lx55.I64 != rx55.I64 && inspector.DEQMustCheck("FloatStructMap.I64", opts) {
				return false
			}
			if lx55.U != rx55.U && inspector.DEQMustCheck("FloatStructMap.U", opts) {
				return false
			}
			if lx55.U8 != rx55.U8 && inspector.DEQMustCheck("FloatStructMap.U8", opts) {
				return false
			}
			if lx55.U16 != rx55.U16 && inspector.DEQMustCheck("FloatStructMap.U16", opts) {
				return false
			}
			if lx55.U32 != rx55.U32 && inspector.DEQMustCheck("FloatStructMap.U32", opts) {
				return false
			}
			if lx55.U64 != rx55.U64 && inspector.DEQMustCheck("FloatStructMap.U64", opts) {
				return false
			}
			if !inspector.EqualFloat32(lx55.F, rx55.F, opts) && inspector.DEQMustCheck("FloatStructMap.F", opts) {
				return false
			}
			if !inspector.EqualFloat64(lx55.D, rx55.D, opts) && inspector.DEQMustCheck("FloatStructMap.D", opts) {
				return false
			}
		}
	}
	lx56 := lx.FloatStructPtrMap
	rx56 := rx.FloatStructPtrMap
	_, _ = lx56, rx56
	if inspector.DEQMustCheck("FloatStructPtrMap", opts) {
		if len(lx56) != len(rx56) {
			return false
		}
		for k := range lx56 {
			lx57 := (lx56)[k]
			rx57, ok57 := (rx56)[k]
			_, _, _ = lx57, rx57, ok57
			if !ok57 {
				return false
			}
			if (lx57 == nil && rx57 != nil) || (lx57 != nil && rx57 == nil) {
				return false
			}
			if lx57 != nil && rx57 != nil {
				if lx57.A != rx57.A && inspector.DEQMustCheck("FloatStructPtrMap.A", opts) {
					return false
				}
				if lx57.S != rx57.S && inspector.DEQMustCheck("FloatStructPtrMap.S", opts) {
					return false
				}
				if !bytes.Equal(lx57.B, rx57.B) && inspector.DEQMustCheck("FloatStructPtrMap.B", opts) {
					return false
				}
				if lx57.I != rx57.I && inspector.DEQMustCheck("FloatStructPtrMap.I", opts) {
					return false
				}
				if lx57.I8 != rx57.I8 && inspector.DEQMustCheck("FloatStructPtrMap.I8", opts) {
					return false
				}
				if lx57.I16 != rx57.I16 && inspector.DEQMustCheck("FloatStructPtrMap.I16", opts) {
					return false
				}
				if lx57.I32 != rx57.I32 && inspector.DEQMustCheck("FloatStructPtrMap.I32", opts) {
					return false
				}
				if lx57.I64 != rx57.I64 && inspector.DEQMustCheck("FloatStructPtrMap.I64", opts) {
					return false
				}
				if lx57.U != rx57.U && inspector.DEQMustCheck("FloatStructPtrMap.U", opts) {
					return false
				}
				if lx57.U8 != rx57.U8 && inspector.DEQMustCheck("FloatStructPtrMap.U8", opts) {
					return false
				}
				if lx57.U16 != rx57.U16 && inspector.DEQMustCheck("FloatStructPtrMap.U16", opts) {
					return false
				}
				if lx57.U32 != rx57.U32 && inspector.DEQMustCheck("FloatStructPtrMap.U32", opts) {
					return false
				}
				if lx57.U64 != rx57.U64 && inspector.DEQMustCheck("FloatStructPtrMap.U64", opts) {
					return false
				}
				if !inspector.EqualFloat32(lx57.F, rx57.F, opts) && inspector.DEQMustCheck("FloatStructPtrMap.F", opts) {
					return false
				}
				if !inspector.EqualFloat64(lx57.D, rx57.D, opts) && inspector.DEQMustCheck("FloatStructPtrMap.D", opts) {
					return false
				}
			}
		}
	}
	lx58 := lx.FloatPtrStructMap
	rx58 := rx.FloatPtrStructMap
	_, _ = lx58, rx58
	if inspector.DEQMustCheck("FloatPtrStructMap", opts) {
		if len(lx58) != len(rx58) {
			return false
		}
		for k := range lx58 {
			lx59 := (lx58)[k]
			rx59, ok59 := (rx58)[k]
			_, _, _ = lx59, rx59, ok59
			if !ok59 {
				return false
			}
			if lx59.A != rx59.A && inspector.DEQMustCheck("FloatPtrStructMap.A", opts) {
				return false
			}
			if lx59.S != rx59.S && inspector.DEQMustCheck("FloatPtrStructMap.S", opts) {
				return false
			}
			if !bytes.Equal(lx59.B, rx59.B) && inspector.DEQMustCheck("FloatPtrStructMap.B", opts) {
				return false
			}
			if lx59.I != rx59.I && inspector.DEQMustCheck("FloatPtrStructMap.I", opts) {
				return false
			}
			if lx59.I8 != rx59.I8 && inspector.DEQMustCheck("FloatPtrStructMap.I8", opts) {
				return false
			}
			if lx59.I16 != rx59.I16 && inspector.DEQMustCheck("FloatPtrStructMap.I16", opts) {
				return false
			}
			if lx59.I32 != rx59.I32 && inspector.DEQMustCheck("FloatPtrStructMap.I32", opts) {
				return false
			}
			if lx59.I64 != rx59.I64 && inspector.DEQMustCheck("FloatPtrStructMap.I64", opts) {
				return false
			}
			if lx59.U != rx59.U && inspector.DEQMustCheck("FloatPtrStructMap.U", opts) {
				return false
			}
			if lx59.U8 != rx59.U8 && inspector.DEQMustCheck("FloatPtrStructMap.U8", opts) {
				return false
			}
			if lx59.U16 != rx59.U16 && inspector.DEQMustCheck("FloatPtrStructMap.U16", opts) {
				return false
			}
			if lx59.U32 != rx59.U32 && inspector.DEQMustCheck("FloatPtrStructMap.U32", opts) {
				return false
			}
			if lx59.U64 != rx59.U64 && inspector.DEQMustCheck("FloatPtrStructMap.U64", opts) {
				return false
			}
			if !inspector.EqualFloat32(lx59.F, rx59.F, opts) && inspector.DEQMustCheck("FloatPtrStructMap.F", opts) {
				return false
			}
			if !inspector.EqualFloat64(lx59.D, rx59.D, opts) && inspector.DEQMustCheck("FloatPtrStructMap.D", opts) {
				return false
			}
		}
	}
	lx60 := lx.FloatPtrStructPtrMap
	rx60 := rx.FloatPtrStructPtrMap
	_, _ = lx60, rx60
	if inspector.DEQMustCheck("FloatPtrStructPtrMap", opts) {
		if len(lx60) != len(rx60) {
			return false
		}
		for k := range lx60 {
			lx61 := (lx60)[k]
			rx61, ok61 := (rx60)[k]
			_, _, _ = lx61, rx61, ok61
			if !ok61 {
				return false
			}
			if (lx61 == nil && rx61 != nil) || (lx61 != nil && rx61 == nil) {
				return false
			}
			if lx61 != nil && rx61 != nil {
				if lx61.A != rx61.A && inspector.DEQMustCheck("FloatPtrStructPtrMap.A", opts) {
					return false
				}
				if lx61.S != rx61.S && inspector.DEQMustCheck("FloatPtrStructPtrMap.S", opts) {
					return false
				}
				if !bytes.Equal(lx61.B, rx61.B) && inspector.DEQMustCheck("FloatPtrStructPtrMap.B", opts) {
					return false
				}
				if lx61.I != rx61.I && inspector.DEQMustCheck("FloatPtrStructPtrMap.I", opts) {
					return false
				}
				if lx61.I8 != rx61.I8 && inspector.DEQMustCheck("FloatPtrStructPtrMap.I8", opts) {
					return false
				}
				if lx61.I16 != rx61.I16 && inspector.DEQMustCheck("FloatPtrStructPtrMap.I16", opts) {
					return false
				}
				if lx61.I32 != rx61.I32 && inspector.DEQMustCheck("FloatPtrStructPtrMap.I32", opts) {
					return false
				}
				if lx61.I64 != rx61.I64 && inspector.DEQMustCheck("FloatPtrStructPtrMap.I64", opts) {
					return false
				}
				if lx61.U != rx61.U && inspector.DEQMustCheck("FloatPtrStructPtrMap.U", opts) {
					return false
				}
				if lx61.U8 != rx61.U8 && inspector.DEQMustCheck("FloatPtrStructPtrMap.U8", opts) {
					return false
				}
				if lx61.U16 != rx61.U16 && inspector.DEQMustCheck("FloatPtrStructPtrMap.U16", opts) {
					return false
				}
				if lx61.U32 != rx61.U32 && inspector.DEQMustCheck("FloatPtrStructPtrMap.U32", opts) {
					return false
				}
				if lx61.U64 != rx61.U64 && inspector.DEQMustCheck("FloatPtrStructPtrMap.U64", opts) {
					return false
				}
				if !inspector.EqualFloat32(lx61.F, rx61.F, opts) && inspector.DEQMustCheck("FloatPtrStructPtrMap.F", opts) {
					return false
				}
				if !inspector.EqualFloat64(lx61.D, rx61.D, opts) && inspector.DEQMustCheck("FloatPtrStructPtrMap.D", opts) {
					return false
				}
			}
		}
	}
	lx62 := lx.FloatPtrStructPtrMapPtr
	rx62 := rx.FloatPtrStructPtrMapPtr
	_, _ = lx62, rx62
	if (lx62 == nil && rx62 != nil) || (lx62 != nil && rx62 == nil) {
		return false
	}
	if lx62 != nil && rx62 != nil {
		if inspector.DEQMustCheck("FloatPtrStructPtrMapPtr", opts) {
			if len(*lx62) != len(*rx62) {
				return false
			}
			for k := range *lx62 {
				lx63 := (*lx62)[k]
				rx63, ok63 := (*rx62)[k]
				_, _, _ = lx63, rx63, ok63
				if !ok63 {
					return false
				}
				if (lx63 == nil && rx63 != nil) || (lx63 != nil && rx63 == nil) {
					return false
				}
				if lx63 != nil && rx63 != nil {
					if lx63.A != rx63.A && inspector.DEQMustCheck("FloatPtrStructPtrMapPtr.A", opts) {
						return false
					}
					if lx63.S != rx63.S && inspector.DEQMustCheck("FloatPtrStructPtrMapPtr.S", opts) {
						return false
					}
					if !bytes.Equal(lx63.B, rx63.B) && inspector.DEQMustCheck("FloatPtrStructPtrMapPtr.B", opts) {
						return false
					}
					if lx63.I != rx63.I && inspector.DEQMustCheck("FloatPtrStructPtrMapPtr.I", opts) {
						return false
					}
					if lx63.I8 != rx63.I8 && inspector.DEQMustCheck("FloatPtrStructPtrMapPtr.I8", opts) {
						return false
					}
					if lx63.I16 != rx63.I16 && inspector.DEQMustCheck("FloatPtrStructPtrMapPtr.I16", opts) {
						return false
					}
					if lx63.I32 != rx63.I32 && inspector.DEQMustCheck("FloatPtrStructPtrMapPtr.I32", opts) {
						return false
					}
					if lx63.I64 != rx63.I64 && inspector.DEQMustCheck("FloatPtrStructPtrMapPtr.I64", opts) {
						return false
					}
					if lx63.U != rx63.U && inspector.DEQMustCheck("FloatPtrStructPtrMapPtr.U", opts) {
						return false
					}
					if lx63.U8 != rx63.U8 && inspector.DEQMustCheck("FloatPtrStructPtrMapPtr.U8", opts) {
						return false
					}
					if lx63.U16 != rx63.U16 && inspector.DEQMustCheck("FloatPtrStructPtrMapPtr.U16", opts) {
						return false
					}
					if lx63.U32 != rx63.U32 && inspector.DEQMustCheck("FloatPtrStructPtrMapPtr.U32", opts) {
						return false
					}
					if lx63.U64 != rx63.U64 && inspector.DEQMustCheck("FloatPtrStructPtrMapPtr.U64", opts) {
						return false
					}
					if !inspector.EqualFloat32(lx63.F, rx63.F, opts) && inspector.DEQMustCheck("FloatPtrStructPtrMapPtr.F", opts) {
						return false
					}
					if !inspector.EqualFloat64(lx63.D, rx63.D, opts) && inspector.DEQMustCheck("FloatPtrStructPtrMapPtr.D", opts) {
						return false
					}
				}
			}
		}
	}
	lx64 := lx.NestedStruct
	rx64 := rx.NestedStruct
	_, _ = lx64, rx64
	if inspector.DEQMustCheck("NestedStruct", opts) {
		if lx64.A != rx64.A && inspector.DEQMustCheck("NestedStruct.A", opts) {
			return false
		}
		if lx64.S != rx64.S && inspector.DEQMustCheck("NestedStruct.S", opts) {
			return false
		}
		if !bytes.Equal(lx64.B, rx64.B) && inspector.DEQMustCheck("NestedStruct.B", opts) {
			return false
		}
		if lx64.I != rx64.I && inspector.DEQMustCheck("NestedStruct.I", opts) {
			return false
		}
		if lx64.I8 != rx64.I8 && inspector.DEQMustCheck("NestedStruct.I8", opts) {
			return false
		}
		if lx64.I16 != rx64.I16 && inspector.DEQMustCheck("NestedStruct.I16", opts) {
			return false
		}
		if lx64.I32 != rx64.I32 && inspector.DEQMustCheck("NestedStruct.I32", opts) {
			return false
		}
		if lx64.I64 != rx64.I64 && inspector.DEQMustCheck("NestedStruct.I64", opts) {
			return false
		}
		if lx64.U != rx64.U && inspector.DEQMustCheck("NestedStruct.U", opts) {
			return false
		}
		if lx64.U8 != rx64.U8 && inspector.DEQMustCheck("NestedStruct.U8", opts) {
			return false
		}
		if lx64.U16 != rx64.U16 && inspector.DEQMustCheck("NestedStruct.U16", opts) {
			return false
		}
		if lx64.U32 != rx64.U32 && inspector.DEQMustCheck("NestedStruct.U32", opts) {
			return false
		}
		if lx64.U64 != rx64.U64 && inspector.DEQMustCheck("NestedStruct.U64", opts) {
			return false
		}
		if !inspector.EqualFloat32(lx64.F, rx64.F, opts) && inspector.DEQMustCheck("NestedStruct.F", opts) {
			return false
		}
		if !inspector.EqualFloat64(lx64.D, rx64.D, opts) && inspector.DEQMustCheck("NestedStruct.D", opts) {
			return false
		}
	}
	lx65 := lx.NestedStructPtr
	rx65 := rx.NestedStructPtr
	_, _ = lx65, rx65
	if (lx65 == nil && rx65 != nil) || (lx65 != nil && rx65 == nil) {
		return false
	}
	if lx65 != nil && rx65 != nil {
		if inspector.DEQMustCheck("NestedStructPtr", opts) {
			if lx65.A != rx65.A && inspector.DEQMustCheck("NestedStructPtr.A", opts) {
				return false
			}
			if lx65.S != rx65.S && inspector.DEQMustCheck("NestedStructPtr.S", opts) {
				return false
			}
			if !bytes.Equal(lx65.B, rx65.B) && inspector.DEQMustCheck("NestedStructPtr.B", opts) {
				return false
			}
			if lx65.I != rx65.I && inspector.DEQMustCheck("NestedStructPtr.I", opts) {
				return false
			}
			if lx65.I8 != rx65.I8 && inspector.DEQMustCheck("NestedStructPtr.I8", opts) {
				return false
			}
			if lx65.I16 != rx65.I16 && inspector.DEQMustCheck("NestedStructPtr.I16", opts) {
				return false
			}
			if lx65.I32 != rx65.I32 && inspector.DEQMustCheck("NestedStructPtr.I32", opts) {
				return false
			}
			if lx65.I64 != rx65.I64 && inspector.DEQMustCheck("NestedStructPtr.I64", opts) {
				return false
			}
			if lx65.U != rx65.U && inspector.DEQMustCheck("NestedStructPtr.U", opts) {
				return false
			}
			if lx65.U8 != rx65.U8 && inspector.DEQMustCheck("NestedStructPtr.U8", opts) {
				return false
			}
			if lx65.U16 != rx65.U16 && inspector.DEQMustCheck("NestedStructPtr.U16", opts) {
				return false
			}
			if lx65.U32 != rx65.U32 && inspector.DEQMustCheck("NestedStructPtr.U32", opts) {
				return false
			}
			if lx65.U64 != rx65.U64 && inspector.DEQMustCheck("NestedStructPtr.U64", opts) {
				return false
			}
			if !inspector.EqualFloat32(lx65.F, rx65.F, opts) && inspector.DEQMustCheck("NestedStructPtr.F", opts) {
				return false
			}
			if !inspector.EqualFloat64(lx65.D, rx65.D, opts) && inspector.DEQMustCheck("NestedStructPtr.D", opts) {
				return false
			}
		}
	}
	return true
}

func (i6 TestObject1Inspector) Unmarshal(p []byte, typ inspector.Encoding) (any, error) {
	var x testobj.TestObject1
	switch typ {
	case inspector.EncodingJSON:
		err := json.Unmarshal(p, &x)
		return &x, err
	default:
		return nil, inspector.ErrUnknownEncodingType
	}
}

func (i6 TestObject1Inspector) Copy(x any) (any, error) {
	var r testobj.TestObject1
	switch x.(type) {
	case testobj.TestObject1:
		r = x.(testobj.TestObject1)
	case *testobj.TestObject1:
		r = *x.(*testobj.TestObject1)
	case **testobj.TestObject1:
		r = **x.(**testobj.TestObject1)
	default:
		return nil, inspector.ErrUnsupportedType
	}
	bc := i6.countBytes(&r)
	var l testobj.TestObject1
	err := i6.CopyTo(&r, &l, inspector.NewByteBuffer(bc))
	return &l, err
}

func (i6 TestObject1Inspector) CopyTo(src, dst any, buf inspector.AccumulativeBuffer) error {
	var r testobj.TestObject1
	switch src.(type) {
	case testobj.TestObject1:
		r = src.(testobj.TestObject1)
	case *testobj.TestObject1:
		r = *src.(*testobj.TestObject1)
	case **testobj.TestObject1:
		r = **src.(**testobj.TestObject1)
	default:
		return inspector.ErrUnsupportedType
	}
	var l *testobj.TestObject1
	switch dst.(type) {
	case testobj.TestObject1:
		return inspector.ErrMustPointerType
	case *testobj.TestObject1:
		l = dst.(*testobj.TestObject1)
	case **testobj.TestObject1:
		l = *dst.(**testobj.TestObject1)
	default:
		return inspector.ErrUnsupportedType
	}
	bb := buf.AcquireBytes()
	var err error
	if bb, err = i6.cpy(bb, l, &r); err != nil {
		return err
	}
	buf.ReleaseBytes(bb)
	return nil
}

func (i6 TestObject1Inspector) countBytes(x *testobj.TestObject1) (c int) {
	c += len(x.ByteSlice)
	if x.ByteSlicePtr != nil {
		c += len(*x.ByteSlicePtr)
	}
	for i1 := 0; i1 < len(x.StructSlice); i1++ {
		x1 := &(x.StructSlice)[i1]
		c += len(x1.S)
		c += len(x1.B)
	}
	for i1 := 0; i1 < len(x.StructPtrSlice); i1++ {
		x1 := (x.StructPtrSlice)[i1]
		c += len(x1.S)
		c += len(x1.B)
	}
	if x.StructSlicePtr != nil {
		for i1 := 0; i1 < len(*x.StructSlicePtr); i1++ {
			x1 := &(*x.StructSlicePtr)[i1]
			c += len(x1.S)
			c += len(x1.B)
		}
	}
	if x.StructPtrSlicePtr != nil {
		for i1 := 0; i1 < len(*x.StructPtrSlicePtr); i1++ {
			x1 := (*x.StructPtrSlicePtr)[i1]
			c += len(x1.S)
			c += len(x1.B)
		}
	}
	for i1 := 0; i1 < len(x.StructSliceLiteral); i1++ {
		x1 := (x.StructSliceLiteral)[i1]
		c += len(x1.S)
		c += len(x1.B)
	}
	for k1, v1 := range x.IntStringMap {
		_, _ = k1, v1
		c += len(v1)
	}
	for k1, v1 := range x.IntStringPtrMap {
		_, _ = k1, v1
		c += len(*v1)
	}
	if x.IntStringMapPtr != nil {
		for k1, v1 := range *x.IntStringMapPtr {
			_, _ = k1, v1
			c += len(v1)
		}
	}
	if x.IntStringPtrMapPtr != nil {
		for k1, v1 := range *x.IntStringPtrMapPtr {
			_, _ = k1, v1
			c += len(*v1)
		}
	}
	if x.IntPtrStringPtrMapPtr != nil {
		for k1, v1 := range *x.IntPtrStringPtrMapPtr {
			_, _ = k1, v1
			c += len(*v1)
		}
	}
	for k1, v1 := range x.StringFloatMap {
		_, _ = k1, v1
		c += len(k1)
	}
	for k1, v1 := range x.StringFloatPtrMap {
		_, _ = k1, v1
		c += len(k1)
	}
	if x.StringFloatMapPtr != nil {
		for k1, v1 := range *x.StringFloatMapPtr {
			_, _ = k1, v1
			c += len(k1)
		}
	}
	if x.StringFloatPtrMapPtr != nil {
		for k1, v1 := range *x.StringFloatPtrMapPtr {
			_, _ = k1, v1
			c += len(k1)
		}
	}
	if x.StringPtrFloatPtrMapPtr != nil {
		for k1, v1 := range *x.StringPtrFloatPtrMapPtr {
			_, _ = k1, v1
			c += len(*k1)
		}
	}
	for k1, v1 := range x.FloatStructMap {
		_, _ = k1, v1
		c += len(v1.S)
		c += len(v1.B)
	}
	for k1, v1 := range x.FloatStructPtrMap {
		_, _ = k1, v1
		c += len(v1.S)
		c += len(v1.B)
	}
	for k1, v1 := range x.FloatPtrStructMap {
		_, _ = k1, v1
		c += len(v1.S)
		c += len(v1.B)
	}
	for k1, v1 := range x.FloatPtrStructPtrMap {
		_, _ = k1, v1
		c += len(v1.S)
		c += len(v1.B)
	}
	if x.FloatPtrStructPtrMapPtr != nil {
		for k1, v1 := range *x.FloatPtrStructPtrMapPtr {
			_, _ = k1, v1
			c += len(v1.S)
			c += len(v1.B)
		}
	}
	c += len(x.NestedStruct.S)
	c += len(x.NestedStruct.B)
	if x.NestedStructPtr != nil {
		c += len(x.NestedStructPtr.S)
		c += len(x.NestedStructPtr.B)
	}
	return c
}

func (i6 TestObject1Inspector) cpy(buf []byte, l, r *testobj.TestObject1) ([]byte, error) {
	if len(r.IntSlice) > 0 {
		buf1 := (l.IntSlice)
		if buf1 == nil {
			buf1 = make([]int32, 0, len(r.IntSlice))
		}
		for i1 := 0; i1 < len(r.IntSlice); i1++ {
			var b1 int32
			x1 := (r.IntSlice)[i1]
			b1 = x1
			buf1 = append(buf1, b1)
		}
		l.IntSlice = buf1
	}
	if len(r.IntPtrSlice) > 0 {
		buf1 := (l.IntPtrSlice)
		if buf1 == nil {
			buf1 = make([]*int32, 0, len(r.IntPtrSlice))
		}
		for i1 := 0; i1 < len(r.IntPtrSlice); i1++ {
			var b1 *int32
			x1 := (r.IntPtrSlice)[i1]
			b1 = x1
			buf1 = append(buf1, b1)
		}
		l.IntPtrSlice = buf1
	}
	if r.IntSlicePtr != nil {
		if len(*r.IntSlicePtr) > 0 {
			buf1 := (*l.IntSlicePtr)
			if buf1 == nil {
				buf1 = make([]int32, 0, len(*r.IntSlicePtr))
			}
			for i1 := 0; i1 < len(*r.IntSlicePtr); i1++ {
				var b1 int32
				x1 := (*r.IntSlicePtr)[i1]
				b1 = x1
				buf1 = append(buf1, b1)
			}
			l.IntSlicePtr = &buf1
		}
	}
	if r.IntPtrSlicePtr != nil {
		if len(*r.IntPtrSlicePtr) > 0 {
			buf1 := (*l.IntPtrSlicePtr)
			if buf1 == nil {
				buf1 = make([]*int32, 0, len(*r.IntPtrSlicePtr))
			}
			for i1 := 0; i1 < len(*r.IntPtrSlicePtr); i1++ {
				var b1 *int32
				x1 := (*r.IntPtrSlicePtr)[i1]
				b1 = x1
				buf1 = append(buf1, b1)
			}
			l.IntPtrSlicePtr = &buf1
		}
	}
	buf, l.ByteSlice = inspector.Bufferize(buf, r.ByteSlice)
	if len(r.BytePtrSlice) > 0 {
		buf1 := (l.BytePtrSlice)
		if buf1 == nil {
			buf1 = make([]*byte, 0, len(r.BytePtrSlice))
		}
		for i1 := 0; i1 < len(r.BytePtrSlice); i1++ {
			var b1 *byte
			x1 := (r.BytePtrSlice)[i1]
			b1 = x1
			buf1 = append(buf1, b1)
		}
		l.BytePtrSlice = buf1
	}
	if r.ByteSlicePtr != nil {
		buf, *l.ByteSlicePtr = inspector.Bufferize(buf, *r.ByteSlicePtr)
	}
	if r.BytePtrSlicePtr != nil {
		if len(*r.BytePtrSlicePtr) > 0 {
			buf1 := (*l.BytePtrSlicePtr)
			if buf1 == nil {
				buf1 = make([]*byte, 0, len(*r.BytePtrSlicePtr))
			}
			for i1 := 0; i1 < len(*r.BytePtrSlicePtr); i1++ {
				var b1 *byte
				x1 := (*r.BytePtrSlicePtr)[i1]
				b1 = x1
				buf1 = append(buf1, b1)
			}
			l.BytePtrSlicePtr = &buf1
		}
	}
	if len(r.FloatSlice) > 0 {
		buf1 := (l.FloatSlice)
		if buf1 == nil {
			buf1 = make(testobj.TestFloatSlice, 0, len(r.FloatSlice))
		}
		for i1 := 0; i1 < len(r.FloatSlice); i1++ {
			var b1 float32
			x1 := (r.FloatSlice)[i1]
			b1 = x1
			buf1 = append(buf1, b1)
		}
		l.FloatSlice = buf1
	}
	if len(r.FloatPtrSlice) > 0 {
		buf1 := (l.FloatPtrSlice)
		if buf1 == nil {
			buf1 = make(testobj.TestFloatPtrSlice, 0, len(r.FloatPtrSlice))
		}
		for i1 := 0; i1 < len(r.FloatPtrSlice); i1++ {
			var b1 *float32
			x1 := (r.FloatPtrSlice)[i1]
			b1 = x1
			buf1 = append(buf1, b1)
		}
		l.FloatPtrSlice = buf1
	}
	if r.FloatSlicePtr != nil {
		if len(*r.FloatSlicePtr) > 0 {
			buf1 := (*l.FloatSlicePtr)
			if buf1 == nil {
				buf1 = make(testobj.TestFloatSlice, 0, len(*r.FloatSlicePtr))
			}
			for i1 := 0; i1 < len(*r.FloatSlicePtr); i1++ {
				var b1 float32
				x1 := (*r.FloatSlicePtr)[i1]
				b1 = x1
				buf1 = append(buf1, b1)
			}
			l.FloatSlicePtr = &buf1
		}
	}
	if r.FloatPtrSlicePtr != nil {
		if len(*r.FloatPtrSlicePtr) > 0 {
			buf1 := (*l.FloatPtrSlicePtr)
			if buf1 == nil {
				buf1 = make(testobj.TestFloatPtrSlice, 0, len(*r.FloatPtrSlicePtr))
			}
			for i1 := 0; i1 < len(*r.FloatPtrSlicePtr); i1++ {
				var b1 *float32
				x1 := (*r.FloatPtrSlicePtr)[i1]
				b1 = x1
				buf1 = append(buf1, b1)
			}
			l.FloatPtrSlicePtr = &buf1
		}
	}
	if len(r.StructSlice) > 0 {
		buf1 := (l.StructSlice)
		if buf1 == nil {
			buf1 = make([]testobj.TestStruct, 0, len(r.StructSlice))
		}
		for i1 := 0; i1 < len(r.StructSlice); i1++ {
			var b1 testobj.TestStruct
			x1 := &(r.StructSlice)[i1]
			b1.A = x1.A
			buf, b1.S = inspector.BufferizeString(buf, x1.S)
			buf, b1.B = inspector.Bufferize(buf, x1.B)
			b1.I = x1.I
			b1.I8 = x1.I8
			b1.I16 = x1.I16
			b1.I32 = x1.I32
			b1.I64 = x1.I64
			b1.U = x1.U
			b1.U8 = x1.U8
			b1.U16 = x1.U16
			b1.U32 = x1.U32
			b1.U64 = x1.U64
			b1.F = x1.F
			b1.D = x1.D
			buf1 = append(buf1, b1)
		}
		l.StructSlice = buf1
	}
	if len(r.StructPtrSlice) > 0 {
		buf1 := (l.StructPtrSlice)
		if buf1 == nil {
			buf1 = make([]*testobj.TestStruct, 0, len(r.StructPtrSlice))
		}
		for i1 := 0; i1 < len(r.StructPtrSlice); i1++ {
			var b1 testobj.TestStruct
			x1 := (r.StructPtrSlice)[i1]
			b1.A = x1.A
			buf, b1.S = inspector.BufferizeString(buf, x1.S)
			buf, b1.B = inspector.Bufferize(buf, x1.B)
			b1.I = x1.I
			b1.I8 = x1.I8
			b1.I16 = x1.I16
			b1.I32 = x1.I32
			b1.I64 = x1.I64
			b1.U = x1.U
			b1.U8 = x1.U8
			b1.U16 = x1.U16
			b1.U32 = x1.U32
			b1.U64 = x1.U64
			b1.F = x1.F
			b1.D = x1.D
			buf1 = append(buf1, &b1)
		}
		l.StructPtrSlice = buf1
	}
	if r.StructSlicePtr != nil {
		if len(*r.StructSlicePtr) > 0 {
			buf1 := (*l.StructSlicePtr)
			if buf1 == nil {
				buf1 = make([]testobj.TestStruct, 0, len(*r.StructSlicePtr))
			}
			for i1 := 0; i1 < len(*r.StructSlicePtr); i1++ {
				var b1 testobj.TestStruct
				x1 := &(*r.StructSlicePtr)[i1]
				b1.A = x1.A
				buf, b1.S = inspector.BufferizeString(buf, x1.S)
				buf, b1.B = inspector.Bufferize(buf, x1.B)
				b1.I = x1.I
				b1.I8 = x1.I8
				b1.I16 = x1.I16
				b1.I32 = x1.I32
				b1.I64 = x1.I64
				b1.U = x1.U
				b1.U8 = x1.U8
				b1.U16 = x1.U16
				b1.U32 = x1.U32
				b1.U64 = x1.U64
				b1.F = x1.F
				b1.D = x1.D
				buf1 = append(buf1, b1)
			}
			l.StructSlicePtr = &buf1
		}
	}
	if r.StructPtrSlicePtr != nil {
		if len(*r.StructPtrSlicePtr) > 0 {
			buf1 := (*l.StructPtrSlicePtr)
			if buf1 == nil {
				buf1 = make([]*testobj.TestStruct, 0, len(*r.StructPtrSlicePtr))
			}
			for i1 := 0; i1 < len(*r.StructPtrSlicePtr); i1++ {
				var b1 testobj.TestStruct
				x1 := (*r.StructPtrSlicePtr)[i1]
				b1.A = x1.A
				buf, b1.S = inspector.BufferizeString(buf, x1.S)
				buf, b1.B = inspector.Bufferize(buf, x1.B)
				b1.I = x1.I
				b1.I8 = x1.I8
				b1.I16 = x1.I16
				b1.I32 = x1.I32
				b1.I64 = x1.I64
				b1.U = x1.U
				b1.U8 = x1.U8
				b1.U16 = x1.U16
				b1.U32 = x1.U32
				b1.U64 = x1.U64
				b1.F = x1.F
				b1.D = x1.D
				buf1 = append(buf1, &b1)
			}
			l.StructPtrSlicePtr = &buf1
		}
	}
	if len(r.StructSliceLiteral) > 0 {
		buf1 := (l.StructSliceLiteral)
		if buf1 == nil {
			buf1 = make(testobj.TestStructSliceLiteral, 0, len(r.StructSliceLiteral))
		}
		for i1 := 0; i1 < len(r.StructSliceLiteral); i1++ {
			var b1 testobj.TestStruct
			x1 := (r.StructSliceLiteral)[i1]
			b1.A = x1.A
			buf, b1.S = inspector.BufferizeString(buf, x1.S)
			buf, b1.B = inspector.Bufferize(buf, x1.B)
			b1.I = x1.I
			b1.I8 = x1.I8
			b1.I16 = x1.I16
			b1.I32 = x1.I32
			b1.I64 = x1.I64
			b1.U = x1.U
			b1.U8 = x1.U8
			b1.U16 = x1.U16
			b1.U32 = x1.U32
			b1.U64 = x1.U64
			b1.F = x1.F
			b1.D = x1.D
			buf1 = append(buf1, &b1)
		}
		l.StructSliceLiteral = buf1
	}
	if len(r.IntStringMap) > 0 {
		if l.IntStringMap == nil {
			buf1 := make(map[int]string, len(r.IntStringMap))
			l.IntStringMap = buf1
		}
		for rk1, rv1 := range r.IntStringMap {
			_, _ = rk1, rv1
			var lk1 int
			lk1 = rk1
			var lv1 string
			buf, lv1 = inspector.BufferizeString(buf, rv1)
			(l.IntStringMap)[lk1] = lv1
		}
	}
	if len(r.IntStringPtrMap) > 0 {
		if l.IntStringPtrMap == nil {
			buf1 := make(map[int]*string, len(r.IntStringPtrMap))
			l.IntStringPtrMap = buf1
		}
		for rk1, rv1 := range r.IntStringPtrMap {
			_, _ = rk1, rv1
			var lk1 int
			lk1 = rk1
			var lv1 *string
			buf, *lv1 = inspector.BufferizeString(buf, *rv1)
			(l.IntStringPtrMap)[lk1] = lv1
		}
	}
	if r.IntStringMapPtr != nil {
		if len(*r.IntStringMapPtr) > 0 {
			if l.IntStringMapPtr == nil {
				buf1 := make(map[int]string, len(*r.IntStringMapPtr))
				l.IntStringMapPtr = &buf1
			}
			for rk1, rv1 := range *r.IntStringMapPtr {
				_, _ = rk1, rv1
				var lk1 int
				lk1 = rk1
				var lv1 string
				buf, lv1 = inspector.BufferizeString(buf, rv1)
				(*l.IntStringMapPtr)[lk1] = lv1
			}
		}
	}
	if r.IntStringPtrMapPtr != nil {
		if len(*r.IntStringPtrMapPtr) > 0 {
			if l.IntStringPtrMapPtr == nil {
				buf1 := make(map[int]*string, len(*r.IntStringPtrMapPtr))
				l.IntStringPtrMapPtr = &buf1
			}
			for rk1, rv1 := range *r.IntStringPtrMapPtr {
				_, _ = rk1, rv1
				var lk1 int
				lk1 = rk1
				var lv1 *string
				buf, *lv1 = inspector.BufferizeString(buf, *rv1)
				(*l.IntStringPtrMapPtr)[lk1] = lv1
			}
		}
	}
	if r.IntPtrStringPtrMapPtr != nil {
		if len(*r.IntPtrStringPtrMapPtr) > 0 {
			if l.IntPtrStringPtrMapPtr == nil {
				buf1 := make(map[*int]*string, len(*r.IntPtrStringPtrMapPtr))
				l.IntPtrStringPtrMapPtr = &buf1
			}
			for rk1, rv1 := range *r.IntPtrStringPtrMapPtr {
				_, _ = rk1, rv1
				var lk1 *int
				lk1 = rk1
				var lv1 *string
				buf, *lv1 = inspector.BufferizeString(buf, *rv1)
				(*l.IntPtrStringPtrMapPtr)[lk1] = lv1
			}
		}
	}
	if len(r.IntIntMapMap) > 0 {
		if l.IntIntMapMap == nil {
			buf1 := make(map[int32]map[int32]int32, len(r.IntIntMapMap))
			l.IntIntMapMap = buf1
		}
		for rk1, rv1 := range r.IntIntMapMap {
			_, _ = rk1, rv1
			var lk1 int32
			lk1 = rk1
			var lv1 map[int32]int32
			if len(rv1) > 0 {
				if lv1 == nil {
					buf2 := make(map[int32]int32, len(rv1))
					lv1 = buf2
				}
				for rk2, rv2 := range rv1 {
					_, _ = rk2, rv2
					var lk2 int32
					lk2 = rk2
					var lv2 int32
					lv2 = rv2
					(lv1)[lk2] = lv2
				}
			}
			(l.IntIntMapMap)[lk1] = lv1
		}
	}
	if len(r.StringFloatMap) > 0 {
		if l.StringFloatMap == nil {
			buf1 := make(testobj.TestStringFloatMap, len(r.StringFloatMap))
			l.StringFloatMap = buf1
		}
		for rk1, rv1 := range r.StringFloatMap {
			_, _ = rk1, rv1
			var lk1 string
			buf, lk1 = inspector.BufferizeString(buf, rk1)
			var lv1 float64
			lv1 = rv1
			(l.StringFloatMap)[lk1] = lv1
		}
	}
	if len(r.StringFloatPtrMap) > 0 {
		if l.StringFloatPtrMap == nil {
			buf1 := make(testobj.TestStringFloatPtrMap, len(r.StringFloatPtrMap))
			l.StringFloatPtrMap = buf1
		}
		for rk1, rv1 := range r.StringFloatPtrMap {
			_, _ = rk1, rv1
			var lk1 string
			buf, lk1 = inspector.BufferizeString(buf, rk1)
			var lv1 *float64
			lv1 = rv1
			(l.StringFloatPtrMap)[lk1] = lv1
		}
	}
	if r.StringFloatMapPtr != nil {
		if len(*r.StringFloatMapPtr) > 0 {
			if l.StringFloatMapPtr == nil {
				buf1 := make(testobj.TestStringFloatMap, len(*r.StringFloatMapPtr))
				l.StringFloatMapPtr = &buf1
			}
			for rk1, rv1 := range *r.StringFloatMapPtr {
				_, _ = rk1, rv1
				var lk1 string
				buf, lk1 = inspector.BufferizeString(buf, rk1)
				var lv1 float64
				lv1 = rv1
				(*l.StringFloatMapPtr)[lk1] = lv1
			}
		}
	}
	if r.StringFloatPtrMapPtr != nil {
		if len(*r.StringFloatPtrMapPtr) > 0 {
			if l.StringFloatPtrMapPtr == nil {
				buf1 := make(testobj.TestStringFloatPtrMap, len(*r.StringFloatPtrMapPtr))
				l.StringFloatPtrMapPtr = &buf1
			}
			for rk1, rv1 := range *r.StringFloatPtrMapPtr {
				_, _ = rk1, rv1
				var lk1 string
				buf, lk1 = inspector.BufferizeString(buf, rk1)
				var lv1 *float64
				lv1 = rv1
				(*l.StringFloatPtrMapPtr)[lk1] = lv1
			}
		}
	}
	if r.StringPtrFloatPtrMapPtr != nil {
		if len(*r.StringPtrFloatPtrMapPtr) > 0 {
			if l.StringPtrFloatPtrMapPtr == nil {
				buf1 := make(testobj.TestStringPtrFloatPtrMap, len(*r.StringPtrFloatPtrMapPtr))
				l.StringPtrFloatPtrMapPtr = &buf1
			}
			for rk1, rv1 := range *r.StringPtrFloatPtrMapPtr {
				_, _ = rk1, rv1
				var lk1 *string
				buf, *lk1 = inspector.BufferizeString(buf, *rk1)
				var lv1 *float64
				lv1 = rv1
				(*l.StringPtrFloatPtrMapPtr)[lk1] = lv1
			}
		}
	}
	if len(r.FloatStructMap) > 0 {
		if l.FloatStructMap == nil {
			buf1 := make(map[float64]testobj.TestStruct, len(r.FloatStructMap))
			l.FloatStructMap = buf1
		}
		for rk1, rv1 := range r.FloatStructMap {
			_, _ = rk1, rv1
			var lk1 float64
			lk1 = rk1
			var lv1 testobj.TestStruct
			lv1.A = rv1.A
			buf, lv1.S = inspector.BufferizeString(buf, rv1.S)
			buf, lv1.B = inspector.Bufferize(buf, rv1.B)
			lv1.I = rv1.I
			lv1.I8 = rv1.I8
			lv1.I16 = rv1.I16
			lv1.I32 = rv1.I32
			lv1.I64 = rv1.I64
			lv1.U = rv1.U
			lv1.U8 = rv1.U8
			lv1.U16 = rv1.U16
			lv1.U32 = rv1.U32
			lv1.U64 = rv1.U64
			lv1.F = rv1.F
			lv1.D = rv1.D
			(l.FloatStructMap)[lk1] = lv1
		}
	}
	if len(r.FloatStructPtrMap) > 0 {
		if l.FloatStructPtrMap == nil {
			buf1 := make(map[float64]*testobj.TestStruct, len(r.FloatStructPtrMap))
			l.FloatStructPtrMap = buf1
		}
		for rk1, rv1 := range r.FloatStructPtrMap {
			_, _ = rk1, rv1
			var lk1 float64
			lk1 = rk1
			var lv1 testobj.TestStruct
			lv1.A = rv1.A
			buf, lv1.S = inspector.BufferizeString(buf, rv1.S)
			buf, lv1.B = inspector.Bufferize(buf, rv1.B)
			lv1.I = rv1.I
			lv1.I8 = rv1.I8
			lv1.I16 = rv1.I16
			lv1.I32 = rv1.I32
			lv1.I64 = rv1.I64
			lv1.U = rv1.U
			lv1.U8 = rv1.U8
			lv1.U16 = rv1.U16
			lv1.U32 = rv1.U32
			lv1.U64 = rv1.U64
			lv1.F = rv1.F
			lv1.D = rv1.D
			(l.FloatStructPtrMap)[lk1] = &lv1
		}
	}
	if len(r.FloatPtrStructMap) > 0 {
		if l.FloatPtrStructMap == nil {
			buf1 := make(map[*float64]testobj.TestStruct, len(r.FloatPtrStructMap))
			l.FloatPtrStructMap = buf1
		}
		for rk1, rv1 := range r.FloatPtrStructMap {
			_, _ = rk1, rv1
			var lk1 *float64
			lk1 = rk1
			var lv1 testobj.TestStruct
			lv1.A = rv1.A
			buf, lv1.S = inspector.BufferizeString(buf, rv1.S)
			buf, lv1.B = inspector.Bufferize(buf, rv1.B)
			lv1.I = rv1.I
			lv1.I8 = rv1.I8
			lv1.I16 = rv1.I16
			lv1.I32 = rv1.I32
			lv1.I64 = rv1.I64
			lv1.U = rv1.U
			lv1.U8 = rv1.U8
			lv1.U16 = rv1.U16
			lv1.U32 = rv1.U32
			lv1.U64 = rv1.U64
			lv1.F = rv1.F
			lv1.D = rv1.D
			(l.FloatPtrStructMap)[lk1] = lv1
		}
	}
	if len(r.FloatPtrStructPtrMap) > 0 {
		if l.FloatPtrStructPtrMap == nil {
			buf1 := make(map[*float64]*testobj.TestStruct, len(r.FloatPtrStructPtrMap))
			l.FloatPtrStructPtrMap = buf1
		}
		for rk1, rv1 := range r.FloatPtrStructPtrMap {
			_, _ = rk1, rv1
			var lk1 *float64
			lk1 = rk1
			var lv1 testobj.TestStruct
			lv1.A = rv1.A
			buf, lv1.S = inspector.BufferizeString(buf, rv1.S)
			buf, lv1.B = inspector.Bufferize(buf, rv1.B)
			lv1.I = rv1.I
			lv1.I8 = rv1.I8
			lv1.I16 = rv1.I16
			lv1.I32 = rv1.I32
			lv1.I64 = rv1.I64
			lv1.U = rv1.U
			lv1.U8 = rv1.U8
			lv1.U16 = rv1.U16
			lv1.U32 = rv1.U32
			lv1.U64 = rv1.U64
			lv1.F = rv1.F
			lv1.D = rv1.D
			(l.FloatPtrStructPtrMap)[lk1] = &lv1
		}
	}
	if r.FloatPtrStructPtrMapPtr != nil {
		if len(*r.FloatPtrStructPtrMapPtr) > 0 {
			if l.FloatPtrStructPtrMapPtr == nil {
				buf1 := make(map[*float64]*testobj.TestStruct, len(*r.FloatPtrStructPtrMapPtr))
				l.FloatPtrStructPtrMapPtr = &buf1
			}
			for rk1, rv1 := range *r.FloatPtrStructPtrMapPtr {
				_, _ = rk1, rv1
				var lk1 *float64
				lk1 = rk1
				var lv1 testobj.TestStruct
				lv1.A = rv1.A
				buf, lv1.S = inspector.BufferizeString(buf, rv1.S)
				buf, lv1.B = inspector.Bufferize(buf, rv1.B)
				lv1.I = rv1.I
				lv1.I8 = rv1.I8
				lv1.I16 = rv1.I16
				lv1.I32 = rv1.I32
				lv1.I64 = rv1.I64
				lv1.U = rv1.U
				lv1.U8 = rv1.U8
				lv1.U16 = rv1.U16
				lv1.U32 = rv1.U32
				lv1.U64 = rv1.U64
				lv1.F = rv1.F
				lv1.D = rv1.D
				(*l.FloatPtrStructPtrMapPtr)[lk1] = &lv1
			}
		}
	}
	l.NestedStruct.A = r.NestedStruct.A
	buf, l.NestedStruct.S = inspector.BufferizeString(buf, r.NestedStruct.S)
	buf, l.NestedStruct.B = inspector.Bufferize(buf, r.NestedStruct.B)
	l.NestedStruct.I = r.NestedStruct.I
	l.NestedStruct.I8 = r.NestedStruct.I8
	l.NestedStruct.I16 = r.NestedStruct.I16
	l.NestedStruct.I32 = r.NestedStruct.I32
	l.NestedStruct.I64 = r.NestedStruct.I64
	l.NestedStruct.U = r.NestedStruct.U
	l.NestedStruct.U8 = r.NestedStruct.U8
	l.NestedStruct.U16 = r.NestedStruct.U16
	l.NestedStruct.U32 = r.NestedStruct.U32
	l.NestedStruct.U64 = r.NestedStruct.U64
	l.NestedStruct.F = r.NestedStruct.F
	l.NestedStruct.D = r.NestedStruct.D
	if r.NestedStructPtr != nil {
		if l.NestedStructPtr == nil {
			l.NestedStructPtr = &testobj.TestStruct{}
		}
		l.NestedStructPtr.A = r.NestedStructPtr.A
		buf, l.NestedStructPtr.S = inspector.BufferizeString(buf, r.NestedStructPtr.S)
		buf, l.NestedStructPtr.B = inspector.Bufferize(buf, r.NestedStructPtr.B)
		l.NestedStructPtr.I = r.NestedStructPtr.I
		l.NestedStructPtr.I8 = r.NestedStructPtr.I8
		l.NestedStructPtr.I16 = r.NestedStructPtr.I16
		l.NestedStructPtr.I32 = r.NestedStructPtr.I32
		l.NestedStructPtr.I64 = r.NestedStructPtr.I64
		l.NestedStructPtr.U = r.NestedStructPtr.U
		l.NestedStructPtr.U8 = r.NestedStructPtr.U8
		l.NestedStructPtr.U16 = r.NestedStructPtr.U16
		l.NestedStructPtr.U32 = r.NestedStructPtr.U32
		l.NestedStructPtr.U64 = r.NestedStructPtr.U64
		l.NestedStructPtr.F = r.NestedStructPtr.F
		l.NestedStructPtr.D = r.NestedStructPtr.D
	}
	return buf, nil
}

func (i6 TestObject1Inspector) Length(src any, result *int, path ...string) error {
	if src == nil {
		return nil
	}
	var x *testobj.TestObject1
	_ = x
	if p, ok := src.(**testobj.TestObject1); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestObject1); ok {
		x = p
	} else if v, ok := src.(testobj.TestObject1); ok {
		x = &v
	} else {
		return inspector.ErrUnsupportedType
	}

	*result = 0
	if len(path) == 0 {
		return nil
	}
	if path[0] == "IntSlice" {
	}
	if path[0] == "IntPtrSlice" {
	}
	if path[0] == "IntSlicePtr" {
		if x.IntSlicePtr != nil {
			if x.IntSlicePtr == nil {
				return nil
			}
		}
	}
	if path[0] == "IntPtrSlicePtr" {
		if x.IntPtrSlicePtr != nil {
			if x.IntPtrSlicePtr == nil {
				return nil
			}
		}
	}
	if path[0] == "ByteSlice" {
		*result = len(x.ByteSlice)
		return nil
	}
	if path[0] == "BytePtrSlice" {
	}
	if path[0] == "ByteSlicePtr" {
		if x.ByteSlicePtr != nil {
			if x.ByteSlicePtr == nil {
				return nil
			}
			*result = len(*x.ByteSlicePtr)
			return nil
		}
	}
	if path[0] == "BytePtrSlicePtr" {
		if x.BytePtrSlicePtr != nil {
			if x.BytePtrSlicePtr == nil {
				return nil
			}
		}
	}
	if path[0] == "FloatSlice" {
	}
	if path[0] == "FloatPtrSlice" {
	}
	if path[0] == "FloatSlicePtr" {
		if x.FloatSlicePtr != nil {
			if x.FloatSlicePtr == nil {
				return nil
			}
		}
	}
	if path[0] == "FloatPtrSlicePtr" {
		if x.FloatPtrSlicePtr != nil {
			if x.FloatPtrSlicePtr == nil {
				return nil
			}
		}
	}
	if path[0] == "StructSlice" {
		if len(path) == 1 {
			*result = len(x.StructSlice)
			return nil
		}
		if len(path) < 2 {
			return nil
		}
		var i int
		t324, err324 := strconv.ParseInt(path[1], 0, 0)
		if err324 != nil {
			return err324
		}
		i = int(t324)
		if len(x.StructSlice) > i {
			x1 := &(x.StructSlice)[i]
			_ = x1
			if len(path) < 3 {
				return nil
			}
			if path[2] == "S" {
				*result = len(x1.S)
				return nil
			}
			if path[2] == "B" {
				*result = len(x1.B)
				return nil
			}
		}
	}
	if path[0] == "StructPtrSlice" {
		if len(path) == 1 {
			*result = len(x.StructPtrSlice)
			return nil
		}
		if len(path) < 2 {
			return nil
		}
		var i int
		t325, err325 := strconv.ParseInt(path[1], 0, 0)
		if err325 != nil {
			return err325
		}
		i = int(t325)
		if len(x.StructPtrSlice) > i {
			x1 := (x.StructPtrSlice)[i]
			_ = x1
			if len(path) < 3 {
				return nil
			}
			if x1 == nil {
				return nil
			}
			if path[2] == "S" {
				*result = len(x1.S)
				return nil
			}
			if path[2] == "B" {
				*result = len(x1.B)
				return nil
			}
		}
	}
	if path[0] == "StructSlicePtr" {
		if x.StructSlicePtr != nil {
			if x.StructSlicePtr == nil {
				return nil
			}
			if len(path) == 1 {
				*result = len(*x.StructSlicePtr)
				return nil
			}
			if len(path) < 2 {
				return nil
			}
			var i int
			t326, err326 := strconv.ParseInt(path[1], 0, 0)
			if err326 != nil {
				return err326
			}
			i = int(t326)
			if len(*x.StructSlicePtr) > i {
				x1 := &(*x.StructSlicePtr)[i]
				_ = x1
				if len(path) < 3 {
					return nil
				}
				if path[2] == "S" {
					*result = len(x1.S)
					return nil
				}
				if path[2] == "B" {
					*result = len(x1.B)
					return nil
				}
			}
		}
	}
	if path[0] == "StructPtrSlicePtr" {
		if x.StructPtrSlicePtr != nil {
			if x.StructPtrSlicePtr == nil {
				return nil
			}
			if len(path) == 1 {
				*result = len(*x.StructPtrSlicePtr)
				return nil
			}
			if len(path) < 2 {
				return nil
			}
			var i int
			t327, err327 := strconv.ParseInt(path[1], 0, 0)
			if err327 != nil {
				return err327
			}
			i = int(t327)
			if len(*x.StructPtrSlicePtr) > i {
				x1 := (*x.StructPtrSlicePtr)[i]
				_ = x1
				if len(path) < 3 {
					return nil
				}
				if x1 == nil {
					return nil
				}
				if path[2] == "S" {
					*result = len(x1.S)
					return nil
				}
				if path[2] == "B" {
					*result = len(x1.B)
					return nil
				}
			}
		}
	}
	if path[0] == "StructSliceLiteral" {
		if len(path) == 1 {
			*result = len(x.StructSliceLiteral)
			return nil
		}
		if len(path) < 2 {
			return nil
		}
		var i int
		t328, err328 := strconv.ParseInt(path[1], 0, 0)
		if err328 != nil {
			return err328
		}
		i = int(t328)
		if len(x.StructSliceLiteral) > i {
			x1 := (x.StructSliceLiteral)[i]
			_ = x1
			if len(path) < 3 {
				return nil
			}
			if x1 == nil {
				return nil
			}
			if path[2] == "S" {
				*result = len(x1.S)
				return nil
			}
			if path[2] == "B" {
				*result = len(x1.B)
				return nil
			}
		}
	}
	if path[0] == "IntStringMap" {
		if len(path) == 1 {
			*result = len(x.IntStringMap)
			return nil
		}
		if len(path) < 2 {
			return nil
		}
		var k int
		t329, err329 := strconv.ParseInt(path[1], 0, 0)
		if err329 != nil {
			return err329
		}
		k = int(t329)
		x1 := (x.IntStringMap)[k]
		_ = x1
		*result = len(x1)
		return nil
	}
	if path[0] == "IntStringPtrMap" {
		if len(path) == 1 {
			*result = len(x.IntStringPtrMap)
			return nil
		}
		if len(path) < 2 {
			return nil
		}
		var k int
		t330, err330 := strconv.ParseInt(path[1], 0, 0)
		if err330 != nil {
			return err330
		}
		k = int(t330)
		x1 := (x.IntStringPtrMap)[k]
		_ = x1
		if x1 == nil {
			return nil
		}
		*result = len(*x1)
		return nil
	}
	if path[0] == "IntStringMapPtr" {
		if x.IntStringMapPtr != nil {
			if x.IntStringMapPtr == nil {
				return nil
			}
			if len(path) == 1 {
				*result = len(*x.IntStringMapPtr)
				return nil
			}
			if len(path) < 2 {
				return nil
			}
			var k int
			t331, err331 := strconv.ParseInt(path[1], 0, 0)
			if err331 != nil {
				return err331
			}
			k = int(t331)
			x1 := (*x.IntStringMapPtr)[k]
			_ = x1
			*result = len(x1)
			return nil
		}
	}
	if path[0] == "IntStringPtrMapPtr" {
		if x.IntStringPtrMapPtr != nil {
			if x.IntStringPtrMapPtr == nil {
				return nil
			}
			if len(path) == 1 {
				*result = len(*x.IntStringPtrMapPtr)
				return nil
			}
			if len(path) < 2 {
				return nil
			}
			var k int
			t332, err332 := strconv.ParseInt(path[1], 0, 0)
			if err332 != nil {
				return err332
			}
			k = int(t332)
			x1 := (*x.IntStringPtrMapPtr)[k]
			_ = x1
			if x1 == nil {
				return nil
			}
			*result = len(*x1)
			return nil
		}
	}
	if path[0] == "IntPtrStringPtrMapPtr" {
		if x.IntPtrStringPtrMapPtr != nil {
			if x.IntPtrStringPtrMapPtr == nil {
				return nil
			}
			if len(path) == 1 {
				*result = len(*x.IntPtrStringPtrMapPtr)
				return nil
			}
			if len(path) < 2 {
				return nil
			}
			var k int
			t333, err333 := strconv.ParseInt(path[1], 0, 0)
			if err333 != nil {
				return err333
			}
			k = int(t333)
			x1 := (*x.IntPtrStringPtrMapPtr)[&k]
			_ = x1
			if x1 == nil {
				return nil
			}
			*result = len(*x1)
			return nil
		}
	}
	if path[0] == "IntIntMapMap" {
		if len(path) == 1 {
			*result = len(x.IntIntMapMap)
			return nil
		}
		if len(path) < 2 {
			return nil
		}
		var k int32
		t334, err334 := strconv.ParseInt(path[1], 0, 0)
		if err334 != nil {
			return err334
		}
		k = int32(t334)
		x1 := (x.IntIntMapMap)[k]
		_ = x1
		if len(path) < 3 {
			return nil
		}
		if len(path) == 2 {
			*result = len(x1)
			return nil
		}
	}
	if path[0] == "StringFloatMap" {
		if len(path) == 1 {
			*result = len(x.StringFloatMap)
			return nil
		}
	}
	if path[0] == "StringFloatPtrMap" {
		if len(path) == 1 {
			*result = len(x.StringFloatPtrMap)
			return nil
		}
	}
	if path[0] == "StringFloatMapPtr" {
		if x.StringFloatMapPtr != nil {
			if x.StringFloatMapPtr == nil {
				return nil
			}
			if len(path) == 1 {
				*result = len(*x.StringFloatMapPtr)
				return nil
			}
		}
	}
	if path[0] == "StringFloatPtrMapPtr" {
		if x.StringFloatPtrMapPtr != nil {
			if x.StringFloatPtrMapPtr == nil {
				return nil
			}
			if len(path) == 1 {
				*result = len(*x.StringFloatPtrMapPtr)
				return nil
			}
		}
	}
	if path[0] == "StringPtrFloatPtrMapPtr" {
		if x.StringPtrFloatPtrMapPtr != nil {
			if x.StringPtrFloatPtrMapPtr == nil {
				return nil
			}
			if len(path) == 1 {
				*result = len(*x.StringPtrFloatPtrMapPtr)
				return nil
			}
		}
	}
	if path[0] == "FloatStructMap" {
		if len(path) == 1 {
			*result = len(x.FloatStructMap)
			return nil
		}
		if len(path) < 2 {
			return nil
		}
		var k float64
		t335, err335 := strconv.ParseFloat(path[1], 0)
		if err335 != nil {
			return err335
		}
		k = float64(t335)
		x1 := (x.FloatStructMap)[k]
		_ = x1
		if len(path) < 3 {
			return nil
		}
		if path[2] == "S" {
			*result = len(x1.S)
			return nil
		}
		if path[2] == "B" {
			*result = len(x1.B)
			return nil
		}
	}
	if path[0] == "FloatStructPtrMap" {
		if len(path) == 1 {
			*result = len(x.FloatStructPtrMap)
			return nil
		}
		if len(path) < 2 {
			return nil
		}
		var k float64
		t336, err336 := strconv.ParseFloat(path[1], 0)
		if err336 != nil {
			return err336
		}
		k = float64(t336)
		x1 := (x.FloatStructPtrMap)[k]
		_ = x1
		if len(path) < 3 {
			return nil
		}
		if x1 == nil {
			return nil
		}
		if path[2] == "S" {
			*result = len(x1.S)
			return nil
		}
		if path[2] == "B" {
			*result = len(x1.B)
			return nil
		}
	}
	if path[0] == "FloatPtrStructMap" {
		if len(path) == 1 {
			*result = len(x.FloatPtrStructMap)
			return nil
		}
		if len(path) < 2 {
			return nil
		}
		var k float64
		t337, err337 := strconv.ParseFloat(path[1], 0)
		if err337 != nil {
			return err337
		}
		k = float64(t337)
		x1 := (x.FloatPtrStructMap)[&k]
		_ = x1
		if len(path) < 3 {
			return nil
		}
		if path[2] == "S" {
			*result = len(x1.S)
			return nil
		}
		if path[2] == "B" {
			*result = len(x1.B)
			return nil
		}
	}
	if path[0] == "FloatPtrStructPtrMap" {
		if len(path) == 1 {
			*result = len(x.FloatPtrStructPtrMap)
			return nil
		}
		if len(path) < 2 {
			return nil
		}
		var k float64
		t338, err338 := strconv.ParseFloat(path[1], 0)
		if err338 != nil {
			return err338
		}
		k = float64(t338)
		x1 := (x.FloatPtrStructPtrMap)[&k]
		_ = x1
		if len(path) < 3 {
			return nil
		}
		if x1 == nil {
			return nil
		}
		if path[2] == "S" {
			*result = len(x1.S)
			return nil
		}
		if path[2] == "B" {
			*result = len(x1.B)
			return nil
		}
	}
	if path[0] == "FloatPtrStructPtrMapPtr" {
		if x.FloatPtrStructPtrMapPtr != nil {
			if x.FloatPtrStructPtrMapPtr == nil {
				return nil
			}
			if len(path) == 1 {
				*result = len(*x.FloatPtrStructPtrMapPtr)
				return nil
			}
			if len(path) < 2 {
				return nil
			}
			var k float64
			t339, err339 := strconv.ParseFloat(path[1], 0)
			if err339 != nil {
				return err339
			}
			k = float64(t339)
			x1 := (*x.FloatPtrStructPtrMapPtr)[&k]
			_ = x1
			if len(path) < 3 {
				return nil
			}
			if x1 == nil {
				return nil
			}
			if path[2] == "S" {
				*result = len(x1.S)
				return nil
			}
			if path[2] == "B" {
				*result = len(x1.B)
				return nil
			}
		}
	}
	if path[0] == "NestedStruct" {
		if path[1] == "S" {
			*result = len(x.NestedStruct.S)
			return nil
		}
		if path[1] == "B" {
			*result = len(x.NestedStruct.B)
			return nil
		}
	}
	if path[0] == "NestedStructPtr" {
		if x.NestedStructPtr != nil {
			if x.NestedStructPtr == nil {
				return nil
			}
			if path[1] == "S" {
				*result = len(x.NestedStructPtr.S)
				return nil
			}
			if path[1] == "B" {
				*result = len(x.NestedStructPtr.B)
				return nil
			}
		}
	}
	return nil
}

func (i6 TestObject1Inspector) Capacity(src any, result *int, path ...string) error {
	if src == nil {
		return nil
	}
	var x *testobj.TestObject1
	_ = x
	if p, ok := src.(**testobj.TestObject1); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestObject1); ok {
		x = p
	} else if v, ok := src.(testobj.TestObject1); ok {
		x = &v
	} else {
		return inspector.ErrUnsupportedType
	}

	*result = 0
	if len(path) == 0 {
		return nil
	}
	if path[0] == "IntSlice" {
	}
	if path[0] == "IntPtrSlice" {
	}
	if path[0] == "IntSlicePtr" {
		if x.IntSlicePtr != nil {
			if x.IntSlicePtr == nil {
				return nil
			}
		}
	}
	if path[0] == "IntPtrSlicePtr" {
		if x.IntPtrSlicePtr != nil {
			if x.IntPtrSlicePtr == nil {
				return nil
			}
		}
	}
	if path[0] == "ByteSlice" {
		*result = cap(x.ByteSlice)
		return nil
	}
	if path[0] == "BytePtrSlice" {
	}
	if path[0] == "ByteSlicePtr" {
		if x.ByteSlicePtr != nil {
			if x.ByteSlicePtr == nil {
				return nil
			}
			*result = cap(*x.ByteSlicePtr)
			return nil
		}
	}
	if path[0] == "BytePtrSlicePtr" {
		if x.BytePtrSlicePtr != nil {
			if x.BytePtrSlicePtr == nil {
				return nil
			}
		}
	}
	if path[0] == "FloatSlice" {
	}
	if path[0] == "FloatPtrSlice" {
	}
	if path[0] == "FloatSlicePtr" {
		if x.FloatSlicePtr != nil {
			if x.FloatSlicePtr == nil {
				return nil
			}
		}
	}
	if path[0] == "FloatPtrSlicePtr" {
		if x.FloatPtrSlicePtr != nil {
			if x.FloatPtrSlicePtr == nil {
				return nil
			}
		}
	}
	if path[0] == "StructSlice" {
		if len(path) == 1 {
			*result = cap(x.StructSlice)
			return nil
		}
		if len(path) < 2 {
			return nil
		}
		var i int
		t340, err340 := strconv.ParseInt(path[1], 0, 0)
		if err340 != nil {
			return err340
		}
		i = int(t340)
		if len(x.StructSlice) > i {
			x1 := &(x.StructSlice)[i]
			_ = x1
			if len(path) < 3 {
				return nil
			}
			if path[2] == "S" {
			}
			if path[2] == "B" {
				*result = cap(x1.B)
				return nil
			}
		}
	}
	if path[0] == "StructPtrSlice" {
		if len(path) == 1 {
			*result = cap(x.StructPtrSlice)
			return nil
		}
		if len(path) < 2 {
			return nil
		}
		var i int
		t341, err341 := strconv.ParseInt(path[1], 0, 0)
		if err341 != nil {
			return err341
		}
		i = int(t341)
		if len(x.StructPtrSlice) > i {
			x1 := (x.StructPtrSlice)[i]
			_ = x1
			if len(path) < 3 {
				return nil
			}
			if x1 == nil {
				return nil
			}
			if path[2] == "S" {
			}
			if path[2] == "B" {
				*result = cap(x1.B)
				return nil
			}
		}
	}
	if path[0] == "StructSlicePtr" {
		if x.StructSlicePtr != nil {
			if x.StructSlicePtr == nil {
				return nil
			}
			if len(path) == 1 {
				*result = cap(*x.StructSlicePtr)
				return nil
			}
			if len(path) < 2 {
				return nil
			}
			var i int
			t342, err342 := strconv.ParseInt(path[1], 0, 0)
			if err342 != nil {
				return err342
			}
			i = int(t342)
			if len(*x.StructSlicePtr) > i {
				x1 := &(*x.StructSlicePtr)[i]
				_ = x1
				if len(path) < 3 {
					return nil
				}
				if path[2] == "S" {
				}
				if path[2] == "B" {
					*result = cap(x1.B)
					return nil
				}
			}
		}
	}
	if path[0] == "StructPtrSlicePtr" {
		if x.StructPtrSlicePtr != nil {
			if x.StructPtrSlicePtr == nil {
				return nil
			}
			if len(path) == 1 {
				*result = cap(*x.StructPtrSlicePtr)
				return nil
			}
			if len(path) < 2 {
				return nil
			}
			var i int
			t343, err343 := strconv.ParseInt(path[1], 0, 0)
			if err343 != nil {
				return err343
			}
			i = int(t343)
			if len(*x.StructPtrSlicePtr) > i {
				x1 := (*x.StructPtrSlicePtr)[i]
				_ = x1
				if len(path) < 3 {
					return nil
				}
				if x1 == nil {
					return nil
				}
				if path[2] == "S" {
				}
				if path[2] == "B" {
					*result = cap(x1.B)
					return nil
				}
			}
		}
	}
	if path[0] == "StructSliceLiteral" {
		if len(path) == 1 {
			*result = cap(x.StructSliceLiteral)
			return nil
		}
		if len(path) < 2 {
			return nil
		}
		var i int
		t344, err344 := strconv.ParseInt(path[1], 0, 0)
		if err344 != nil {
			return err344
		}
		i = int(t344)
		if len(x.StructSliceLiteral) > i {
			x1 := (x.StructSliceLiteral)[i]
			_ = x1
			if len(path) < 3 {
				return nil
			}
			if x1 == nil {
				return nil
			}
			if path[2] == "S" {
			}
			if path[2] == "B" {
				*result = cap(x1.B)
				return nil
			}
		}
	}
	if path[0] == "IntStringMap" {
		if len(path) < 2 {
			return nil
		}
		var k int
		t345, err345 := strconv.ParseInt(path[1], 0, 0)
		if err345 != nil {
			return err345
		}
		k = int(t345)
		x1 := (x.IntStringMap)[k]
		_ = x1
	}
	if path[0] == "IntStringPtrMap" {
		if len(path) < 2 {
			return nil
		}
		var k int
		t346, err346 := strconv.ParseInt(path[1], 0, 0)
		if err346 != nil {
			return err346
		}
		k = int(t346)
		x1 := (x.IntStringPtrMap)[k]
		_ = x1
		if x1 == nil {
			return nil
		}
	}
	if path[0] == "IntStringMapPtr" {
		if x.IntStringMapPtr != nil {
			if x.IntStringMapPtr == nil {
				return nil
			}
			if len(path) < 2 {
				return nil
			}
			var k int
			t347, err347 := strconv.ParseInt(path[1], 0, 0)
			if err347 != nil {
				return err347
			}
			k = int(t347)
			x1 := (*x.IntStringMapPtr)[k]
			_ = x1
		}
	}
	if path[0] == "IntStringPtrMapPtr" {
		if x.IntStringPtrMapPtr != nil {
			if x.IntStringPtrMapPtr == nil {
				return nil
			}
			if len(path) < 2 {
				return nil
			}
			var k int
			t348, err348 := strconv.ParseInt(path[1], 0, 0)
			if err348 != nil {
				return err348
			}
			k = int(t348)
			x1 := (*x.IntStringPtrMapPtr)[k]
			_ = x1
			if x1 == nil {
				return nil
			}
		}
	}
	if path[0] == "IntPtrStringPtrMapPtr" {
		if x.IntPtrStringPtrMapPtr != nil {
			if x.IntPtrStringPtrMapPtr == nil {
				return nil
			}
			if len(path) < 2 {
				return nil
			}
			var k int
			t349, err349 := strconv.ParseInt(path[1], 0, 0)
			if err349 != nil {
				return err349
			}
			k = int(t349)
			x1 := (*x.IntPtrStringPtrMapPtr)[&k]
			_ = x1
			if x1 == nil {
				return nil
			}
		}
	}
	if path[0] == "IntIntMapMap" {
		if len(path) < 2 {
			return nil
		}
		var k int32
		t350, err350 := strconv.ParseInt(path[1], 0, 0)
		if err350 != nil {
			return err350
		}
		k = int32(t350)
		x1 := (x.IntIntMapMap)[k]
		_ = x1
		if len(path) < 3 {
			return nil
		}
	}
	if path[0] == "StringFloatMap" {
	}
	if path[0] == "StringFloatPtrMap" {
	}
	if path[0] == "StringFloatMapPtr" {
		if x.StringFloatMapPtr != nil {
			if x.StringFloatMapPtr == nil {
				return nil
			}
		}
	}
	if path[0] == "StringFloatPtrMapPtr" {
		if x.StringFloatPtrMapPtr != nil {
			if x.StringFloatPtrMapPtr == nil {
				return nil
			}
		}
	}
	if path[0] == "StringPtrFloatPtrMapPtr" {
		if x.StringPtrFloatPtrMapPtr != nil {
			if x.StringPtrFloatPtrMapPtr == nil {
				return nil
			}
		}
	}
	if path[0] == "FloatStructMap" {
		if len(path) < 2 {
			return nil
		}
		var k float64
		t351, err351 := strconv.ParseFloat(path[1], 0)
		if err351 != nil {
			return err351
		}
		k = float64(t351)
		x1 := (x.FloatStructMap)[k]
		_ = x1
		if len(path) < 3 {
			return nil
		}
		if path[2] == "S" {
		}
		if path[2] == "B" {
			*result = cap(x1.B)
			return nil
		}
	}
	if path[0] == "FloatStructPtrMap" {
		if len(path) < 2 {
			return nil
		}
		var k float64
		t352, err352 := strconv.ParseFloat(path[1], 0)
		if err352 != nil {
			return err352
		}
		k = float64(t352)
		x1 := (x.FloatStructPtrMap)[k]
		_ = x1
		if len(path) < 3 {
			return nil
		}
		if x1 == nil {
			return nil
		}
		if path[2] == "S" {
		}
		if path[2] == "B" {
			*result = cap(x1.B)
			return nil
		}
	}
	if path[0] == "FloatPtrStructMap" {
		if len(path) < 2 {
			return nil
		}
		var k float64
		t353, err353 := strconv.ParseFloat(path[1], 0)
		if err353 != nil {
			return err353
		}
		k = float64(t353)
		x1 := (x.FloatPtrStructMap)[&k]
		_ = x1
		if len(path) < 3 {
			return nil
		}
		if path[2] == "S" {
		}
		if path[2] == "B" {
			*result = cap(x1.B)
			return nil
		}
	}
	if path[0] == "FloatPtrStructPtrMap" {
		if len(path) < 2 {
			return nil
		}
		var k float64
		t354, err354 := strconv.ParseFloat(path[1], 0)
		if err354 != nil {
			return err354
		}
		k = float64(t354)
		x1 := (x.FloatPtrStructPtrMap)[&k]
		_ = x1
		if len(path) < 3 {
			return nil
		}
		if x1 == nil {
			return nil
		}
		if path[2] == "S" {
		}
		if path[2] == "B" {
			*result = cap(x1.B)
			return nil
		}
	}
	if path[0] == "FloatPtrStructPtrMapPtr" {
		if x.FloatPtrStructPtrMapPtr != nil {
			if x.FloatPtrStructPtrMapPtr == nil {
				return nil
			}
			if len(path) < 2 {
				return nil
			}
			var k float64
			t355, err355 := strconv.ParseFloat(path[1], 0)
			if err355 != nil {
				return err355
			}
			k = float64(t355)
			x1 := (*x.FloatPtrStructPtrMapPtr)[&k]
			_ = x1
			if len(path) < 3 {
				return nil
			}
			if x1 == nil {
				return nil
			}
			if path[2] == "S" {
			}
			if path[2] == "B" {
				*result = cap(x1.B)
				return nil
			}
		}
	}
	if path[0] == "NestedStruct" {
		if path[1] == "S" {
		}
		if path[1] == "B" {
			*result = cap(x.NestedStruct.B)
			return nil
		}
	}
	if path[0] == "NestedStructPtr" {
		if x.NestedStructPtr != nil {
			if x.NestedStructPtr == nil {
				return nil
			}
			if path[1] == "S" {
			}
			if path[1] == "B" {
				*result = cap(x.NestedStructPtr.B)
				return nil
			}
		}
	}
	return nil
}

func (i6 TestObject1Inspector) Append(src, value any, path ...string) (any, error) {
	_, _, _ = src, value, path
	if src == nil {
		return src, nil
	}
	var x *testobj.TestObject1
	_ = x
	if p, ok := src.(**testobj.TestObject1); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestObject1); ok {
		x = p
	} else if v, ok := src.(testobj.TestObject1); ok {
		x = &v
	} else {
		return src, nil
	}

	if path[0] == "IntSlice" {
		if len(path) == 1 {
			var raw *int32
			var ok bool
			switch y := value.(type) {
			case int32:
				raw = &y
				ok = true
			case *int32:
				raw = y
				ok = true
			}
			if ok {
				x.IntSlice = append(x.IntSlice, *raw)
				return &x.IntSlice, nil
			}
		}
	}
	if path[0] == "IntPtrSlice" {
		if len(path) == 1 {
			var raw *int32
			var ok bool
			switch y := value.(type) {
			case *int32:
				raw = y
				ok = true
			case **int32:
				raw = *y
				ok = true
			}
			if ok {
				x.IntPtrSlice = append(x.IntPtrSlice, raw)
				return &x.IntPtrSlice, nil
			}
		}
	}
	if path[0] == "IntSlicePtr" {
		if len(path) == 1 {
			var raw *int32
			var ok bool
			switch y := value.(type) {
			case int32:
				raw = &y
				ok = true
			case *int32:
				raw = y
				ok = true
			}
			if ok {
				*x.IntSlicePtr = append(*x.IntSlicePtr, *raw)
				return x.IntSlicePtr, nil
			}
		}
	}
	if path[0] == "IntPtrSlicePtr" {
		if len(path) == 1 {
			var raw *int32
			var ok bool
			switch y := value.(type) {
			case *int32:
				raw = y
				ok = true
			case **int32:
				raw = *y
				ok = true
			}
			if ok {
				*x.IntPtrSlicePtr = append(*x.IntPtrSlicePtr, raw)
				return x.IntPtrSlicePtr, nil
			}
		}
	}
	if path[0] == "ByteSlice" {
		if len(path) == 1 {
			var raw *byte
			var ok bool
			switch y := value.(type) {
			case byte:
				raw = &y
				ok = true
			case *byte:
				raw = y
				ok = true
			}
			if ok {
				x.ByteSlice = append(x.ByteSlice, *raw)
				return &x.ByteSlice, nil
			}
		}
	}
	if path[0] == "BytePtrSlice" {
		if len(path) == 1 {
			var raw *byte
			var ok bool
			switch y := value.(type) {
			case *byte:
				raw = y
				ok = true
			case **byte:
				raw = *y
				ok = true
			}
			if ok {
				x.BytePtrSlice = append(x.BytePtrSlice, raw)
				return &x.BytePtrSlice, nil
			}
		}
	}
	if path[0] == "ByteSlicePtr" {
		if len(path) == 1 {
			var raw *byte
			var ok bool
			switch y := value.(type) {
			case byte:
				raw = &y
				ok = true
			case *byte:
				raw = y
				ok = true
			}
			if ok {
				*x.ByteSlicePtr = append(*x.ByteSlicePtr, *raw)
				return x.ByteSlicePtr, nil
			}
		}
	}
	if path[0] == "BytePtrSlicePtr" {
		if len(path) == 1 {
			var raw *byte
			var ok bool
			switch y := value.(type) {
			case *byte:
				raw = y
				ok = true
			case **byte:
				raw = *y
				ok = true
			}
			if ok {
				*x.BytePtrSlicePtr = append(*x.BytePtrSlicePtr, raw)
				return x.BytePtrSlicePtr, nil
			}
		}
	}
	if path[0] == "FloatSlice" {
		if len(path) == 1 {
			var raw *float32
			var ok bool
			switch y := value.(type) {
			case float32:
				raw = &y
				ok = true
			case *float32:
				raw = y
				ok = true
			}
			if ok {
				x.FloatSlice = append(x.FloatSlice, *raw)
				return &x.FloatSlice, nil
			}
		}
	}
	if path[0] == "FloatPtrSlice" {
		if len(path) == 1 {
			var raw *float32
			var ok bool
			switch y := value.(type) {
			case *float32:
				raw = y
				ok = true
			case **float32:
				raw = *y
				ok = true
			}
			if ok {
				x.FloatPtrSlice = append(x.FloatPtrSlice, raw)
				return &x.FloatPtrSlice, nil
			}
		}
	}
	if path[0] == "FloatSlicePtr" {
		if len(path) == 1 {
			var raw *float32
			var ok bool
			switch y := value.(type) {
			case float32:
				raw = &y
				ok = true
			case *float32:
				raw = y
				ok = true
			}
			if ok {
				*x.FloatSlicePtr = append(*x.FloatSlicePtr, *raw)
				return x.FloatSlicePtr, nil
			}
		}
	}
	if path[0] == "FloatPtrSlicePtr" {
		if len(path) == 1 {
			var raw *float32
			var ok bool
			switch y := value.(type) {
			case *float32:
				raw = y
				ok = true
			case **float32:
				raw = *y
				ok = true
			}
			if ok {
				*x.FloatPtrSlicePtr = append(*x.FloatPtrSlicePtr, raw)
				return x.FloatPtrSlicePtr, nil
			}
		}
	}
	if path[0] == "StructSlice" {
		if len(path) == 1 {
			var raw *testobj.TestStruct
			var ok bool
			switch y := value.(type) {
			case testobj.TestStruct:
				raw = &y
				ok = true
			case *testobj.TestStruct:
				raw = y
				ok = true
			}
			if ok {
				x.StructSlice = append(x.StructSlice, *raw)
				return &x.StructSlice, nil
			}
		}
		if len(path) < 2 {
			return src, nil
		}
		var i int
		t356, err356 := strconv.ParseInt(path[1], 0, 0)
		if err356 != nil {
			return src, err356
		}
		i = int(t356)
		if len(x.StructSlice) > i {
			x1 := &(x.StructSlice)[i]
			_ = x1
			if path[2] == "B" {
				if len(path) == 3 {
					var raw *byte
					var ok bool
					switch y := value.(type) {
					case byte:
						raw = &y
						ok = true
					case *byte:
						raw = y
						ok = true
					}
					if ok {
						x1.B = append(x1.B, *raw)
						return &x1.B, nil
					}
				}
			}
		}
	}
	if path[0] == "StructPtrSlice" {
		if len(path) == 1 {
			var raw *testobj.TestStruct
			var ok bool
			switch y := value.(type) {
			case *testobj.TestStruct:
				raw = y
				ok = true
			case **testobj.TestStruct:
				raw = *y
				ok = true
			}
			if ok {
				x.StructPtrSlice = append(x.StructPtrSlice, raw)
				return &x.StructPtrSlice, nil
			}
		}
		if len(path) < 2 {
			return src, nil
		}
		var i int
		t357, err357 := strconv.ParseInt(path[1], 0, 0)
		if err357 != nil {
			return src, err357
		}
		i = int(t357)
		if len(x.StructPtrSlice) > i {
			x1 := (x.StructPtrSlice)[i]
			_ = x1
			if x1 == nil {
				x1 = new(testobj.TestStruct)
			}
			if path[2] == "B" {
				if len(path) == 3 {
					var raw *byte
					var ok bool
					switch y := value.(type) {
					case byte:
						raw = &y
						ok = true
					case *byte:
						raw = y
						ok = true
					}
					if ok {
						x1.B = append(x1.B, *raw)
						return &x1.B, nil
					}
				}
			}
		}
	}
	if path[0] == "StructSlicePtr" {
		if len(path) == 1 {
			var raw *testobj.TestStruct
			var ok bool
			switch y := value.(type) {
			case testobj.TestStruct:
				raw = &y
				ok = true
			case *testobj.TestStruct:
				raw = y
				ok = true
			}
			if ok {
				*x.StructSlicePtr = append(*x.StructSlicePtr, *raw)
				return x.StructSlicePtr, nil
			}
		}
		if len(path) < 2 {
			return src, nil
		}
		var i int
		t358, err358 := strconv.ParseInt(path[1], 0, 0)
		if err358 != nil {
			return src, err358
		}
		i = int(t358)
		if len(*x.StructSlicePtr) > i {
			x1 := &(*x.StructSlicePtr)[i]
			_ = x1
			if path[2] == "B" {
				if len(path) == 3 {
					var raw *byte
					var ok bool
					switch y := value.(type) {
					case byte:
						raw = &y
						ok = true
					case *byte:
						raw = y
						ok = true
					}
					if ok {
						x1.B = append(x1.B, *raw)
						return &x1.B, nil
					}
				}
			}
		}
	}
	if path[0] == "StructPtrSlicePtr" {
		if len(path) == 1 {
			var raw *testobj.TestStruct
			var ok bool
			switch y := value.(type) {
			case *testobj.TestStruct:
				raw = y
				ok = true
			case **testobj.TestStruct:
				raw = *y
				ok = true
			}
			if ok {
				*x.StructPtrSlicePtr = append(*x.StructPtrSlicePtr, raw)
				return x.StructPtrSlicePtr, nil
			}
		}
		if len(path) < 2 {
			return src, nil
		}
		var i int
		t359, err359 := strconv.ParseInt(path[1], 0, 0)
		if err359 != nil {
			return src, err359
		}
		i = int(t359)
		if len(*x.StructPtrSlicePtr) > i {
			x1 := (*x.StructPtrSlicePtr)[i]
			_ = x1
			if x1 == nil {
				x1 = new(testobj.TestStruct)
			}
			if path[2] == "B" {
				if len(path) == 3 {
					var raw *byte
					var ok bool
					switch y := value.(type) {
					case byte:
						raw = &y
						ok = true
					case *byte:
						raw = y
						ok = true
					}
					if ok {
						x1.B = append(x1.B, *raw)
						return &x1.B, nil
					}
				}
			}
		}
	}
	if path[0] == "StructSliceLiteral" {
		if len(path) == 1 {
			var raw *testobj.TestStruct
			var ok bool
			switch y := value.(type) {
			case *testobj.TestStruct:
				raw = y
				ok = true
			case **testobj.TestStruct:
				raw = *y
				ok = true
			}
			if ok {
				x.StructSliceLiteral = append(x.StructSliceLiteral, raw)
				return &x.StructSliceLiteral, nil
			}
		}
		if len(path) < 2 {
			return src, nil
		}
		var i int
		t360, err360 := strconv.ParseInt(path[1], 0, 0)
		if err360 != nil {
			return src, err360
		}
		i = int(t360)
		if len(x.StructSliceLiteral) > i {
			x1 := (x.StructSliceLiteral)[i]
			_ = x1
			if x1 == nil {
				x1 = new(testobj.TestStruct)
			}
			if path[2] == "B" {
				if len(path) == 3 {
					var raw *byte
					var ok bool
					switch y := value.(type) {
					case byte:
						raw = &y
						ok = true
					case *byte:
						raw = y
						ok = true
					}
					if ok {
						x1.B = append(x1.B, *raw)
						return &x1.B, nil
					}
				}
			}
		}
	}
	if path[0] == "FloatStructMap" {
		if len(path) < 2 {
			return src, nil
		}
		var k float64
		t361, err361 := strconv.ParseFloat(path[1], 0)
		if err361 != nil {
			return src, err361
		}
		k = float64(t361)
		x1 := (x.FloatStructMap)[k]
		_ = x1
		if path[2] == "B" {
			if len(path) == 3 {
				var raw *byte
				var ok bool
				switch y := value.(type) {
				case byte:
					raw = &y
					ok = true
				case *byte:
					raw = y
					ok = true
				}
				if ok {
					x1.B = append(x1.B, *raw)
					return &x1.B, nil
				}
			}
		}
	}
	if path[0] == "FloatStructPtrMap" {
		if len(path) < 2 {
			return src, nil
		}
		var k float64
		t362, err362 := strconv.ParseFloat(path[1], 0)
		if err362 != nil {
			return src, err362
		}
		k = float64(t362)
		x1 := (x.FloatStructPtrMap)[k]
		_ = x1
		if x1 == nil {
			x1 = new(testobj.TestStruct)
		}
		if path[2] == "B" {
			if len(path) == 3 {
				var raw *byte
				var ok bool
				switch y := value.(type) {
				case byte:
					raw = &y
					ok = true
				case *byte:
					raw = y
					ok = true
				}
				if ok {
					x1.B = append(x1.B, *raw)
					return &x1.B, nil
				}
			}
		}
	}
	if path[0] == "FloatPtrStructMap" {
		if len(path) < 2 {
			return src, nil
		}
		var k float64
		t363, err363 := strconv.ParseFloat(path[1], 0)
		if err363 != nil {
			return src, err363
		}
		k = float64(t363)
		x1 := (x.FloatPtrStructMap)[&k]
		_ = x1
		if path[2] == "B" {
			if len(path) == 3 {
				var raw *byte
				var ok bool
				switch y := value.(type) {
				case byte:
					raw = &y
					ok = true
				case *byte:
					raw = y
					ok = true
				}
				if ok {
					x1.B = append(x1.B, *raw)
					return &x1.B, nil
				}
			}
		}
	}
	if path[0] == "FloatPtrStructPtrMap" {
		if len(path) < 2 {
			return src, nil
		}
		var k float64
		t364, err364 := strconv.ParseFloat(path[1], 0)
		if err364 != nil {
			return src, err364
		}
		k = float64(t364)
		x1 := (x.FloatPtrStructPtrMap)[&k]
		_ = x1
		if x1 == nil {
			x1 = new(testobj.TestStruct)
		}
		if path[2] == "B" {
			if len(path) == 3 {
				var raw *byte
				var ok bool
				switch y := value.(type) {
				case byte:
					raw = &y
					ok = true
				case *byte:
					raw = y
					ok = true
				}
				if ok {
					x1.B = append(x1.B, *raw)
					return &x1.B, nil
				}
			}
		}
	}
	if path[0] == "FloatPtrStructPtrMapPtr" {
		if x.FloatPtrStructPtrMapPtr == nil {
			x.FloatPtrStructPtrMapPtr = new(map[*float64]*testobj.TestStruct)
		}
		if len(path) < 2 {
			return src, nil
		}
		var k float64
		t365, err365 := strconv.ParseFloat(path[1], 0)
		if err365 != nil {
			return src, err365
		}
		k = float64(t365)
		x1 := (*x.FloatPtrStructPtrMapPtr)[&k]
		_ = x1
		if x1 == nil {
			x1 = new(testobj.TestStruct)
		}
		if path[2] == "B" {
			if len(path) == 3 {
				var raw *byte
				var ok bool
				switch y := value.(type) {
				case byte:
					raw = &y
					ok = true
				case *byte:
					raw = y
					ok = true
				}
				if ok {
					x1.B = append(x1.B, *raw)
					return &x1.B, nil
				}
			}
		}
	}
	if path[0] == "NestedStruct" {
		if path[1] == "B" {
			if len(path) == 2 {
				var raw *byte
				var ok bool
				switch y := value.(type) {
				case byte:
					raw = &y
					ok = true
				case *byte:
					raw = y
					ok = true
				}
				if ok {
					x.NestedStruct.B = append(x.NestedStruct.B, *raw)
					return &x.NestedStruct.B, nil
				}
			}
		}
	}
	if path[0] == "NestedStructPtr" {
		if x.NestedStructPtr == nil {
			x.NestedStructPtr = new(testobj.TestStruct)
		}
		if path[1] == "B" {
			if len(path) == 2 {
				var raw *byte
				var ok bool
				switch y := value.(type) {
				case byte:
					raw = &y
					ok = true
				case *byte:
					raw = y
					ok = true
				}
				if ok {
					x.NestedStructPtr.B = append(x.NestedStructPtr.B, *raw)
					return &x.NestedStructPtr.B, nil
				}
			}
		}
	}
	return src, nil
}

func (i6 TestObject1Inspector) Reset(x any, path ...string) error {
	var origin *testobj.TestObject1
	_ = origin
	switch x.(type) {
	case testobj.TestObject1:
		return inspector.ErrMustPointerType
	case *testobj.TestObject1:
		origin = x.(*testobj.TestObject1)
	case **testobj.TestObject1:
		origin = *x.(**testobj.TestObject1)
	default:
		return inspector.ErrUnsupportedType
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "IntSlice") {
		if l := len((origin.IntSlice)); l > 0 {
			var i1 int = -1
			_ = i1
			if len(path) == 1 && i1 == -1 {
				(origin.IntSlice) = (origin.IntSlice)[:0]
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "IntPtrSlice") {
		if l := len((origin.IntPtrSlice)); l > 0 {
			var i1 int = -1
			_ = i1
			if len(path) == 1 && i1 == -1 {
				(origin.IntPtrSlice) = (origin.IntPtrSlice)[:0]
			}
		}
	}
	if origin.IntSlicePtr != nil {
		if len(path) == 0 || (len(path) > 0 && path[0] == "IntSlicePtr") {
			if l := len((*origin.IntSlicePtr)); l > 0 {
				var i1 int = -1
				_ = i1
				if len(path) == 1 && i1 == -1 {
					(*origin.IntSlicePtr) = (*origin.IntSlicePtr)[:0]
				}
			}
		}
	}
	if origin.IntPtrSlicePtr != nil {
		if len(path) == 0 || (len(path) > 0 && path[0] == "IntPtrSlicePtr") {
			if l := len((*origin.IntPtrSlicePtr)); l > 0 {
				var i1 int = -1
				_ = i1
				if len(path) == 1 && i1 == -1 {
					(*origin.IntPtrSlicePtr) = (*origin.IntPtrSlicePtr)[:0]
				}
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "ByteSlice") {
		if l := len((origin.ByteSlice)); l > 0 {
			(origin.ByteSlice) = (origin.ByteSlice)[:0]
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "BytePtrSlice") {
		if l := len((origin.BytePtrSlice)); l > 0 {
			var i1 int = -1
			_ = i1
			if len(path) == 1 && i1 == -1 {
				(origin.BytePtrSlice) = (origin.BytePtrSlice)[:0]
			}
		}
	}
	if origin.ByteSlicePtr != nil {
		if len(path) == 0 || (len(path) > 0 && path[0] == "ByteSlicePtr") {
			if l := len((*origin.ByteSlicePtr)); l > 0 {
				(*origin.ByteSlicePtr) = (*origin.ByteSlicePtr)[:0]
			}
		}
	}
	if origin.BytePtrSlicePtr != nil {
		if len(path) == 0 || (len(path) > 0 && path[0] == "BytePtrSlicePtr") {
			if l := len((*origin.BytePtrSlicePtr)); l > 0 {
				var i1 int = -1
				_ = i1
				if len(path) == 1 && i1 == -1 {
					(*origin.BytePtrSlicePtr) = (*origin.BytePtrSlicePtr)[:0]
				}
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "FloatSlice") {
		if l := len((origin.FloatSlice)); l > 0 {
			var i1 int = -1
			_ = i1
			if len(path) == 1 && i1 == -1 {
				(origin.FloatSlice) = (origin.FloatSlice)[:0]
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "FloatPtrSlice") {
		if l := len((origin.FloatPtrSlice)); l > 0 {
			var i1 int = -1
			_ = i1
			if len(path) == 1 && i1 == -1 {
				(origin.FloatPtrSlice) = (origin.FloatPtrSlice)[:0]
			}
		}
	}
	if origin.FloatSlicePtr != nil {
		if len(path) == 0 || (len(path) > 0 && path[0] == "FloatSlicePtr") {
			if l := len((*origin.FloatSlicePtr)); l > 0 {
				var i1 int = -1
				_ = i1
				if len(path) == 1 && i1 == -1 {
					(*origin.FloatSlicePtr) = (*origin.FloatSlicePtr)[:0]
				}
			}
		}
	}
	if origin.FloatPtrSlicePtr != nil {
		if len(path) == 0 || (len(path) > 0 && path[0] == "FloatPtrSlicePtr") {
			if l := len((*origin.FloatPtrSlicePtr)); l > 0 {
				var i1 int = -1
				_ = i1
				if len(path) == 1 && i1 == -1 {
					(*origin.FloatPtrSlicePtr) = (*origin.FloatPtrSlicePtr)[:0]
				}
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "StructSlice") {
		if l := len((origin.StructSlice)); l > 0 {
			var i1 int = -1
			_ = i1
			_ = (origin.StructSlice)[l-1]
			if len(path) > 1 {
				t366, err366 := strconv.ParseInt(path[1], 0, 0)
				if err366 != nil {
					return err366
				}
				i1 = int(t366)
			}
			_ = i1
			for i := 0; i < l; i++ {
				if len(path) == 1 && i1 != i {
					continue
				}
				x1 := &(origin.StructSlice)[i]
				if len(path) == 2 || (len(path) > 2 && path[2] == "A") {
					x1.A = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "S") {
					x1.S = ""
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "B") {
					if l := len((x1.B)); l > 0 {
						(x1.B) = (x1.B)[:0]
					}
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "I") {
					x1.I = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "I8") {
					x1.I8 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "I16") {
					x1.I16 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "I32") {
					x1.I32 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "I64") {
					x1.I64 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "U") {
					x1.U = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "U8") {
					x1.U8 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "U16") {
					x1.U16 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "U32") {
					x1.U32 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "U64") {
					x1.U64 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "F") {
					x1.F = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "D") {
					x1.D = 0
				}
			}
			if len(path) == 1 && i1 == -1 {
				(origin.StructSlice) = (origin.StructSlice)[:0]
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "StructPtrSlice") {
		if l := len((origin.StructPtrSlice)); l > 0 {
			var i1 int = -1
			_ = i1
			_ = (origin.StructPtrSlice)[l-1]
			if len(path) > 1 {
				t367, err367 := strconv.ParseInt(path[1], 0, 0)
				if err367 != nil {
					return err367
				}
				i1 = int(t367)
			}
			_ = i1
			for i := 0; i < l; i++ {
				if len(path) == 1 && i1 != i {
					continue
				}
				x1 := (origin.StructPtrSlice)[i]
				if len(path) == 2 || (len(path) > 2 && path[2] == "A") {
					x1.A = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "S") {
					x1.S = ""
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "B") {
					if l := len((x1.B)); l > 0 {
						(x1.B) = (x1.B)[:0]
					}
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "I") {
					x1.I = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "I8") {
					x1.I8 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "I16") {
					x1.I16 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "I32") {
					x1.I32 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "I64") {
					x1.I64 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "U") {
					x1.U = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "U8") {
					x1.U8 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "U16") {
					x1.U16 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "U32") {
					x1.U32 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "U64") {
					x1.U64 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "F") {
					x1.F = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "D") {
					x1.D = 0
				}
			}
			if len(path) == 1 && i1 == -1 {
				(origin.StructPtrSlice) = (origin.StructPtrSlice)[:0]
			}
		}
	}
	if origin.StructSlicePtr != nil {
		if len(path) == 0 || (len(path) > 0 && path[0] == "StructSlicePtr") {
			if l := len((*origin.StructSlicePtr)); l > 0 {
				var i1 int = -1
				_ = i1
				_ = (*origin.StructSlicePtr)[l-1]
				if len(path) > 1 {
					t368, err368 := strconv.ParseInt(path[1], 0, 0)
					if err368 != nil {
						return err368
					}
					i1 = int(t368)
				}
				_ = i1
				for i := 0; i < l; i++ {
					if len(path) == 1 && i1 != i {
						continue
					}
					x1 := &(*origin.StructSlicePtr)[i]
					if len(path) == 2 || (len(path) > 2 && path[2] == "A") {
						x1.A = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "S") {
						x1.S = ""
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "B") {
						if l := len((x1.B)); l > 0 {
							(x1.B) = (x1.B)[:0]
						}
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "I") {
						x1.I = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "I8") {
						x1.I8 = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "I16") {
						x1.I16 = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "I32") {
						x1.I32 = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "I64") {
						x1.I64 = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "U") {
						x1.U = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "U8") {
						x1.U8 = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "U16") {
						x1.U16 = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "U32") {
						x1.U32 = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "U64") {
						x1.U64 = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "F") {
						x1.F = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "D") {
						x1.D = 0
					}
				}
				if len(path) == 1 && i1 == -1 {
					(*origin.StructSlicePtr) = (*origin.StructSlicePtr)[:0]
				}
			}
		}
	}
	if origin.StructPtrSlicePtr != nil {
		if len(path) == 0 || (len(path) > 0 && path[0] == "StructPtrSlicePtr") {
			if l := len((*origin.StructPtrSlicePtr)); l > 0 {
				var i1 int = -1
				_ = i1
				_ = (*origin.StructPtrSlicePtr)[l-1]
				if len(path) > 1 {
					t369, err369 := strconv.ParseInt(path[1], 0, 0)
					if err369 != nil {
						return err369
					}
					i1 = int(t369)
				}
				_ = i1
				for i := 0; i < l; i++ {
					if len(path) == 1 && i1 != i {
						continue
					}
					x1 := (*origin.StructPtrSlicePtr)[i]
					if len(path) == 2 || (len(path) > 2 && path[2] == "A") {
						x1.A = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "S") {
						x1.S = ""
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "B") {
						if l := len((x1.B)); l > 0 {
							(x1.B) = (x1.B)[:0]
						}
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "I") {
						x1.I = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "I8") {
						x1.I8 = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "I16") {
						x1.I16 = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "I32") {
						x1.I32 = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "I64") {
						x1.I64 = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "U") {
						x1.U = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "U8") {
						x1.U8 = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "U16") {
						x1.U16 = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "U32") {
						x1.U32 = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "U64") {
						x1.U64 = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "F") {
						x1.F = 0
					}
					if len(path) == 2 || (len(path) > 2 && path[2] == "D") {
						x1.D = 0
					}
				}
				if len(path) == 1 && i1 == -1 {
					(*origin.StructPtrSlicePtr) = (*origin.StructPtrSlicePtr)[:0]
				}
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "StructSliceLiteral") {
		if l := len((origin.StructSliceLiteral)); l > 0 {
			var i1 int = -1
			_ = i1
			_ = (origin.StructSliceLiteral)[l-1]
			if len(path) > 1 {
				t370, err370 := strconv.ParseInt(path[1], 0, 0)
				if err370 != nil {
					return err370
				}
				i1 = int(t370)
			}
			_ = i1
			for i := 0; i < l; i++ {
				if len(path) == 1 && i1 != i {
					continue
				}
				x1 := (origin.StructSliceLiteral)[i]
				if len(path) == 2 || (len(path) > 2 && path[2] == "A") {
					x1.A = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "S") {
					x1.S = ""
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "B") {
					if l := len((x1.B)); l > 0 {
						(x1.B) = (x1.B)[:0]
					}
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "I") {
					x1.I = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "I8") {
					x1.I8 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "I16") {
					x1.I16 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "I32") {
					x1.I32 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "I64") {
					x1.I64 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "U") {
					x1.U = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "U8") {
					x1.U8 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "U16") {
					x1.U16 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "U32") {
					x1.U32 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "U64") {
					x1.U64 = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "F") {
					x1.F = 0
				}
				if len(path) == 2 || (len(path) > 2 && path[2] == "D") {
					x1.D = 0
				}
			}
			if len(path) == 1 && i1 == -1 {
				(origin.StructSliceLiteral) = (origin.StructSliceLiteral)[:0]
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "IntStringMap") {
		if l := len((origin.IntStringMap)); l > 0 {
			var k1 int
			_ = k1
			if len(path) > 1 {
				t371, err371 := strconv.ParseInt(path[1], 0, 0)
				if err371 != nil {
					return err371
				}
				k1 = int(t371)
			}
			for k, _ := range origin.IntStringMap {
				if len(path) == 1 || k1 == (k) {
					delete((origin.IntStringMap), k)
				}
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "IntStringPtrMap") {
		if l := len((origin.IntStringPtrMap)); l > 0 {
			var k1 int
			_ = k1
			if len(path) > 1 {
				t372, err372 := strconv.ParseInt(path[1], 0, 0)
				if err372 != nil {
					return err372
				}
				k1 = int(t372)
			}
			for k, _ := range origin.IntStringPtrMap {
				if len(path) == 1 || k1 == (k) {
					delete((origin.IntStringPtrMap), k)
				}
			}
		}
	}
	if origin.IntStringMapPtr != nil {
		if len(path) == 0 || (len(path) > 0 && path[0] == "IntStringMapPtr") {
			if l := len((*origin.IntStringMapPtr)); l > 0 {
				var k1 int
				_ = k1
				if len(path) > 1 {
					t373, err373 := strconv.ParseInt(path[1], 0, 0)
					if err373 != nil {
						return err373
					}
					k1 = int(t373)
				}
				for k, _ := range *origin.IntStringMapPtr {
					if len(path) == 1 || k1 == (k) {
						delete((*origin.IntStringMapPtr), k)
					}
				}
			}
		}
	}
	if origin.IntStringPtrMapPtr != nil {
		if len(path) == 0 || (len(path) > 0 && path[0] == "IntStringPtrMapPtr") {
			if l := len((*origin.IntStringPtrMapPtr)); l > 0 {
				var k1 int
				_ = k1
				if len(path) > 1 {
					t374, err374 := strconv.ParseInt(path[1], 0, 0)
					if err374 != nil {
						return err374
					}
					k1 = int(t374)
				}
				for k, _ := range *origin.IntStringPtrMapPtr {
					if len(path) == 1 || k1 == (k) {
						delete((*origin.IntStringPtrMapPtr), k)
					}
				}
			}
		}
	}
	if origin.IntPtrStringPtrMapPtr != nil {
		if len(path) == 0 || (len(path) > 0 && path[0] == "IntPtrStringPtrMapPtr") {
			if l := len((*origin.IntPtrStringPtrMapPtr)); l > 0 {
				var k1 int
				_ = k1
				if len(path) > 1 {
					t375, err375 := strconv.ParseInt(path[1], 0, 0)
					if err375 != nil {
						return err375
					}
					k1 = int(t375)
				}
				for k, _ := range *origin.IntPtrStringPtrMapPtr {
					if len(path) == 1 || k1 == (*k) {
						delete((*origin.IntPtrStringPtrMapPtr), k)
					}
				}
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "IntIntMapMap") {
		if l := len((origin.IntIntMapMap)); l > 0 {
			var k1 int32
			_ = k1
			if len(path) > 1 {
				t376, err376 := strconv.ParseInt(path[1], 0, 0)
				if err376 != nil {
					return err376
				}
				k1 = int32(t376)
			}
			for k, _ := range origin.IntIntMapMap {
				if len(path) == 1 || k1 == (k) {
					delete((origin.IntIntMapMap), k)
				}
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "StringFloatMap") {
		if l := len((origin.StringFloatMap)); l > 0 {
			var k1 string
			_ = k1
			if len(path) > 1 {
				k1 = path[1]
			}
			for k, _ := range origin.StringFloatMap {
				if len(path) == 1 || k1 == (k) {
					delete((origin.StringFloatMap), k)
				}
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "StringFloatPtrMap") {
		if l := len((origin.StringFloatPtrMap)); l > 0 {
			var k1 string
			_ = k1
			if len(path) > 1 {
				k1 = path[1]
			}
			for k, _ := range origin.StringFloatPtrMap {
				if len(path) == 1 || k1 == (k) {
					delete((origin.StringFloatPtrMap), k)
				}
			}
		}
	}
	if origin.StringFloatMapPtr != nil {
		if len(path) == 0 || (len(path) > 0 && path[0] == "StringFloatMapPtr") {
			if l := len((*origin.StringFloatMapPtr)); l > 0 {
				var k1 string
				_ = k1
				if len(path) > 1 {
					k1 = path[1]
				}
				for k, _ := range *origin.StringFloatMapPtr {
					if len(path) == 1 || k1 == (k) {
						delete((*origin.StringFloatMapPtr), k)
					}
				}
			}
		}
	}
	if origin.StringFloatPtrMapPtr != nil {
		if len(path) == 0 || (len(path) > 0 && path[0] == "StringFloatPtrMapPtr") {
			if l := len((*origin.StringFloatPtrMapPtr)); l > 0 {
				var k1 string
				_ = k1
				if len(path) > 1 {
					k1 = path[1]
				}
				for k, _ := range *origin.StringFloatPtrMapPtr {
					if len(path) == 1 || k1 == (k) {
						delete((*origin.StringFloatPtrMapPtr), k)
					}
				}
			}
		}
	}
	if origin.StringPtrFloatPtrMapPtr != nil {
		if len(path) == 0 || (len(path) > 0 && path[0] == "StringPtrFloatPtrMapPtr") {
			if l := len((*origin.StringPtrFloatPtrMapPtr)); l > 0 {
				var k1 string
				_ = k1
				if len(path) > 1 {
					k1 = path[1]
				}
				for k, _ := range *origin.StringPtrFloatPtrMapPtr {
					if len(path) == 1 || k1 == (*k) {
						delete((*origin.StringPtrFloatPtrMapPtr), k)
					}
				}
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "FloatStructMap") {
		if l := len((origin.FloatStructMap)); l > 0 {
			var k1 float64
			_ = k1
			if len(path) > 1 {
				t377, err377 := strconv.ParseFloat(path[1], 0)
				if err377 != nil {
					return err377
				}
				k1 = float64(t377)
			}
			for k, _ := range origin.FloatStructMap {
				if len(path) == 1 || k1 == (k) {
					delete((origin.FloatStructMap), k)
				}
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "FloatStructPtrMap") {
		if l := len((origin.FloatStructPtrMap)); l > 0 {
			var k1 float64
			_ = k1
			if len(path) > 1 {
				t378, err378 := strconv.ParseFloat(path[1], 0)
				if err378 != nil {
					return err378
				}
				k1 = float64(t378)
			}
			for k, _ := range origin.FloatStructPtrMap {
				if len(path) == 1 || k1 == (k) {
					delete((origin.FloatStructPtrMap), k)
				}
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "FloatPtrStructMap") {
		if l := len((origin.FloatPtrStructMap)); l > 0 {
			var k1 float64
			_ = k1
			if len(path) > 1 {
				t379, err379 := strconv.ParseFloat(path[1], 0)
				if err379 != nil {
					return err379
				}
				k1 = float64(t379)
			}
			for k, _ := range origin.FloatPtrStructMap {
				if len(path) == 1 || k1 == (*k) {
					delete((origin.FloatPtrStructMap), k)
				}
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "FloatPtrStructPtrMap") {
		if l := len((origin.FloatPtrStructPtrMap)); l > 0 {
			var k1 float64
			_ = k1
			if len(path) > 1 {
				t380, err380 := strconv.ParseFloat(path[1], 0)
				if err380 != nil {
					return err380
				}
				k1 = float64(t380)
			}
			for k, _ := range origin.FloatPtrStructPtrMap {
				if len(path) == 1 || k1 == (*k) {
					delete((origin.FloatPtrStructPtrMap), k)
				}
			}
		}
	}
	if origin.FloatPtrStructPtrMapPtr != nil {
		if len(path) == 0 || (len(path) > 0 && path[0] == "FloatPtrStructPtrMapPtr") {
			if l := len((*origin.FloatPtrStructPtrMapPtr)); l > 0 {
				var k1 float64
				_ = k1
				if len(path) > 1 {
					t381, err381 := strconv.ParseFloat(path[1], 0)
					if err381 != nil {
						return err381
					}
					k1 = float64(t381)
				}
				for k, _ := range *origin.FloatPtrStructPtrMapPtr {
					if len(path) == 1 || k1 == (*k) {
						delete((*origin.FloatPtrStructPtrMapPtr), k)
					}
				}
			}
		}
	}
	if len(path) == 0 || (len(path) > 0 && path[0] == "NestedStruct") {
		if len(path) == 1 || (len(path) > 1 && path[1] == "A") {
			origin.NestedStruct.A = 0
		}
		if len(path) == 1 || (len(path) > 1 && path[1] == "S") {
			origin.NestedStruct.S = ""
		}
		if len(path) == 1 || (len(path) > 1 && path[1] == "B") {
			if l := len((origin.NestedStruct.B)); l > 0 {
				(origin.NestedStruct.B) = (origin.NestedStruct.B)[:0]
			}
		}
		if len(path) == 1 || (len(path) > 1 && path[1] == "I") {
			origin.NestedStruct.I = 0
		}
		if len(path) == 1 || (len(path) > 1 && path[1] == "I8") {
			origin.NestedStruct.I8 = 0
		}
		if len(path) == 1 || (len(path) > 1 && path[1] == "I16") {
			origin.NestedStruct.I16 = 0
		}
		if len(path) == 1 || (len(path) > 1 && path[1] == "I32") {
			origin.NestedStruct.I32 = 0
		}
		if len(path) == 1 || (len(path) > 1 && path[1] == "I64") {
			origin.NestedStruct.I64 = 0
		}
		if len(path) == 1 || (len(path) > 1 && path[1] == "U") {
			origin.NestedStruct.U = 0
		}
		if len(path) == 1 || (len(path) > 1 && path[1] == "U8") {
			origin.NestedStruct.U8 = 0
		}
		if len(path) == 1 || (len(path) > 1 && path[1] == "U16") {
			origin.NestedStruct.U16 = 0
		}
		if len(path) == 1 || (len(path) > 1 && path[1] == "U32") {
			origin.NestedStruct.U32 = 0
		}
		if len(path) == 1 || (len(path) > 1 && path[1] == "U64") {
			origin.NestedStruct.U64 = 0
		}
		if len(path) == 1 || (len(path) > 1 && path[1] == "F") {
			origin.NestedStruct.F = 0
		}
		if len(path) == 1 || (len(path) > 1 && path[1] == "D") {
			origin.NestedStruct.D = 0
		}
	}
	if origin.NestedStructPtr != nil {
		if len(path) == 0 || (len(path) > 0 && path[0] == "NestedStructPtr") {
			if len(path) == 1 || (len(path) > 1 && path[1] == "A") {
				origin.NestedStructPtr.A = 0
			}
			if len(path) == 1 || (len(path) > 1 && path[1] == "S") {
				origin.NestedStructPtr.S = ""
			}
			if len(path) == 1 || (len(path) > 1 && path[1] == "B") {
				if l := len((origin.NestedStructPtr.B)); l > 0 {
					(origin.NestedStructPtr.B) = (origin.NestedStructPtr.B)[:0]
				}
			}
			if len(path) == 1 || (len(path) > 1 && path[1] == "I") {
				origin.NestedStructPtr.I = 0
			}
			if len(path) == 1 || (len(path) > 1 && path[1] == "I8") {
				origin.NestedStructPtr.I8 = 0
			}
			if len(path) == 1 || (len(path) > 1 && path[1] == "I16") {
				origin.NestedStructPtr.I16 = 0
			}
			if len(path) == 1 || (len(path) > 1 && path[1] == "I32") {
				origin.NestedStructPtr.I32 = 0
			}
			if len(path) == 1 || (len(path) > 1 && path[1] == "I64") {
				origin.NestedStructPtr.I64 = 0
			}
			if len(path) == 1 || (len(path) > 1 && path[1] == "U") {
				origin.NestedStructPtr.U = 0
			}
			if len(path) == 1 || (len(path) > 1 && path[1] == "U8") {
				origin.NestedStructPtr.U8 = 0
			}
			if len(path) == 1 || (len(path) > 1 && path[1] == "U16") {
				origin.NestedStructPtr.U16 = 0
			}
			if len(path) == 1 || (len(path) > 1 && path[1] == "U32") {
				origin.NestedStructPtr.U32 = 0
			}
			if len(path) == 1 || (len(path) > 1 && path[1] == "U64") {
				origin.NestedStructPtr.U64 = 0
			}
			if len(path) == 1 || (len(path) > 1 && path[1] == "F") {
				origin.NestedStructPtr.F = 0
			}
			if len(path) == 1 || (len(path) > 1 && path[1] == "D") {
				origin.NestedStructPtr.D = 0
			}
		}
	}
	return nil
}
