// Code generated by inspc. DO NOT EDIT.
// source: github.com/koykov/inspector/testobj

package testobj_ins

import (
	"encoding/json"
	"github.com/koykov/inspector"
	"github.com/koykov/inspector/testobj"
)

func init() {
	inspector.RegisterInspector("TestStringFloatPtrMap", TestStringFloatPtrMapInspector{})
}

type TestStringFloatPtrMapInspector struct {
	inspector.BaseInspector
}

func (i9 TestStringFloatPtrMapInspector) TypeName() string {
	return "TestStringFloatPtrMap"
}

func (i9 TestStringFloatPtrMapInspector) Instance(ptr bool) any {
	if ptr {
		return &testobj.TestStringFloatPtrMap{}
	}
	return testobj.TestStringFloatPtrMap{}
}

func (i9 TestStringFloatPtrMapInspector) Get(src any, path ...string) (any, error) {
	var buf any
	err := i9.GetTo(src, &buf, path...)
	return buf, err
}

func (i9 TestStringFloatPtrMapInspector) GetTo(src any, buf *any, path ...string) (err error) {
	if src == nil {
		return
	}
	var x *testobj.TestStringFloatPtrMap
	_ = x
	if p, ok := src.(**testobj.TestStringFloatPtrMap); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestStringFloatPtrMap); ok {
		x = p
	} else if v, ok := src.(testobj.TestStringFloatPtrMap); ok {
		x = &v
	} else {
		return
	}
	if len(path) == 0 {
		*buf = &(*x)
		return
	}

	if len(path) > 0 {
		if x0, ok := (*x)[path[0]]; ok {
			_ = x0
			if x0 == nil {
				return
			}
			*buf = &x0
			return
		}
	}
	return
}

func (i9 TestStringFloatPtrMapInspector) Compare(src any, cond inspector.Op, right string, result *bool, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *testobj.TestStringFloatPtrMap
	_ = x
	if p, ok := src.(**testobj.TestStringFloatPtrMap); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestStringFloatPtrMap); ok {
		x = p
	} else if v, ok := src.(testobj.TestStringFloatPtrMap); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
		if x0, ok := (*x)[path[0]]; ok {
			_ = x0
			if x0 == nil {
				return
			}
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			return
		}
	}
	return
}

func (i9 TestStringFloatPtrMapInspector) Loop(src any, l inspector.Iterator, buf *[]byte, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *testobj.TestStringFloatPtrMap
	_ = x
	if p, ok := src.(**testobj.TestStringFloatPtrMap); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestStringFloatPtrMap); ok {
		x = p
	} else if v, ok := src.(testobj.TestStringFloatPtrMap); ok {
		x = &v
	} else {
		return
	}

	for k := range *x {
		if l.RequireKey() {
			*buf = append((*buf)[:0], k...)
			l.SetKey(buf, &inspector.StaticInspector{})
		}
		l.SetVal((*x)[k], &inspector.StaticInspector{})
		ctl := l.Iterate()
		if ctl == inspector.LoopCtlBrk {
			break
		}
		if ctl == inspector.LoopCtlCnt {
			continue
		}
	}
	return
	return
}

func (i9 TestStringFloatPtrMapInspector) SetWithBuffer(dst, value any, buf inspector.AccumulativeBuffer, path ...string) error {
	if len(path) == 0 {
		return nil
	}
	if dst == nil {
		return nil
	}
	var x *testobj.TestStringFloatPtrMap
	_ = x
	if p, ok := dst.(**testobj.TestStringFloatPtrMap); ok {
		x = *p
	} else if p, ok := dst.(*testobj.TestStringFloatPtrMap); ok {
		x = p
	} else if v, ok := dst.(testobj.TestStringFloatPtrMap); ok {
		x = &v
	} else {
		return nil
	}

	if len(path) > 0 {
		x0 := (*x)[path[0]]
		_ = x0
		if x0 == nil {
			return nil
		}
		inspector.AssignBuf(x0, value, buf)
		(*x)[path[0]] = x0
		return nil
	}
	return nil
}

func (i9 TestStringFloatPtrMapInspector) Set(dst, value any, path ...string) error {
	return i9.SetWithBuffer(dst, value, nil, path...)
}

func (i9 TestStringFloatPtrMapInspector) DeepEqual(l, r any) bool {
	return i9.DeepEqualWithOptions(l, r, nil)
}

func (i9 TestStringFloatPtrMapInspector) DeepEqualWithOptions(l, r any, opts *inspector.DEQOptions) bool {
	var (
		lx, rx   *testobj.TestStringFloatPtrMap
		leq, req bool
	)
	_, _, _, _ = lx, rx, leq, req
	if lp, ok := l.(**testobj.TestStringFloatPtrMap); ok {
		lx, leq = *lp, true
	} else if lp, ok := l.(*testobj.TestStringFloatPtrMap); ok {
		lx, leq = lp, true
	} else if lp, ok := l.(testobj.TestStringFloatPtrMap); ok {
		lx, leq = &lp, true
	}
	if rp, ok := r.(**testobj.TestStringFloatPtrMap); ok {
		rx, req = *rp, true
	} else if rp, ok := r.(*testobj.TestStringFloatPtrMap); ok {
		rx, req = rp, true
	} else if rp, ok := r.(testobj.TestStringFloatPtrMap); ok {
		rx, req = &rp, true
	}
	if !leq || !req {
		return false
	}
	if lx == nil && rx == nil {
		return true
	}
	if (lx == nil && rx != nil) || (lx != nil && rx == nil) {
		return false
	}

	if len(*lx) != len(*rx) {
		return false
	}
	for k := range *lx {
		lx1 := (*lx)[k]
		rx1, ok1 := (*rx)[k]
		_, _, _ = lx1, rx1, ok1
		if !ok1 {
			return false
		}
		if (lx1 == nil && rx1 != nil) || (lx1 != nil && rx1 == nil) {
			return false
		}
		if lx1 != nil && rx1 != nil {
			if *lx1 != *rx1 {
				return false
			}
		}
	}
	return true
}

func (i9 TestStringFloatPtrMapInspector) Unmarshal(p []byte, typ inspector.Encoding) (any, error) {
	var x testobj.TestStringFloatPtrMap
	switch typ {
	case inspector.EncodingJSON:
		err := json.Unmarshal(p, &x)
		return &x, err
	default:
		return nil, inspector.ErrUnknownEncodingType
	}
}

func (i9 TestStringFloatPtrMapInspector) Copy(x any) (any, error) {
	var r testobj.TestStringFloatPtrMap
	switch x.(type) {
	case testobj.TestStringFloatPtrMap:
		r = x.(testobj.TestStringFloatPtrMap)
	case *testobj.TestStringFloatPtrMap:
		r = *x.(*testobj.TestStringFloatPtrMap)
	case **testobj.TestStringFloatPtrMap:
		r = **x.(**testobj.TestStringFloatPtrMap)
	default:
		return nil, inspector.ErrUnsupportedType
	}
	bc := i9.countBytes(&r)
	var l testobj.TestStringFloatPtrMap
	err := i9.CopyTo(&r, &l, inspector.NewByteBuffer(bc))
	return &l, err
}

func (i9 TestStringFloatPtrMapInspector) CopyTo(src, dst any, buf inspector.AccumulativeBuffer) error {
	var r testobj.TestStringFloatPtrMap
	switch src.(type) {
	case testobj.TestStringFloatPtrMap:
		r = src.(testobj.TestStringFloatPtrMap)
	case *testobj.TestStringFloatPtrMap:
		r = *src.(*testobj.TestStringFloatPtrMap)
	case **testobj.TestStringFloatPtrMap:
		r = **src.(**testobj.TestStringFloatPtrMap)
	default:
		return inspector.ErrUnsupportedType
	}
	var l *testobj.TestStringFloatPtrMap
	switch dst.(type) {
	case testobj.TestStringFloatPtrMap:
		return inspector.ErrMustPointerType
	case *testobj.TestStringFloatPtrMap:
		l = dst.(*testobj.TestStringFloatPtrMap)
	case **testobj.TestStringFloatPtrMap:
		l = *dst.(**testobj.TestStringFloatPtrMap)
	default:
		return inspector.ErrUnsupportedType
	}
	bb := buf.AcquireBytes()
	var err error
	if bb, err = i9.cpy(bb, l, &r); err != nil {
		return err
	}
	buf.ReleaseBytes(bb)
	return nil
}

func (i9 TestStringFloatPtrMapInspector) countBytes(x *testobj.TestStringFloatPtrMap) (c int) {
	for k0, v0 := range *x {
		_, _ = k0, v0
		c += len(k0)
	}
	return c
}

func (i9 TestStringFloatPtrMapInspector) cpy(buf []byte, l, r *testobj.TestStringFloatPtrMap) ([]byte, error) {
	if len(*r) > 0 {
		if l == nil {
			buf0 := make(testobj.TestStringFloatPtrMap, len(*r))
			l = &buf0
		}
		for rk0, rv0 := range *r {
			_, _ = rk0, rv0
			var lk0 string
			buf, lk0 = inspector.BufferizeString(buf, rk0)
			var lv0 *float64
			lv0 = rv0
			(*l)[lk0] = lv0
		}
	}
	return buf, nil
}

func (i9 TestStringFloatPtrMapInspector) Length(src any, result *int, path ...string) error {
	if src == nil {
		return nil
	}
	var x *testobj.TestStringFloatPtrMap
	_ = x
	if p, ok := src.(**testobj.TestStringFloatPtrMap); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestStringFloatPtrMap); ok {
		x = p
	} else if v, ok := src.(testobj.TestStringFloatPtrMap); ok {
		x = &v
	} else {
		return inspector.ErrUnsupportedType
	}

	*result = 0
	if len(path) == 0 {
		return nil
	}
	if len(path) == 0 {
		*result = len(*x)
		return nil
	}
	return nil
}

func (i9 TestStringFloatPtrMapInspector) Capacity(src any, result *int, path ...string) error {
	if src == nil {
		return nil
	}
	var x *testobj.TestStringFloatPtrMap
	_ = x
	if p, ok := src.(**testobj.TestStringFloatPtrMap); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestStringFloatPtrMap); ok {
		x = p
	} else if v, ok := src.(testobj.TestStringFloatPtrMap); ok {
		x = &v
	} else {
		return inspector.ErrUnsupportedType
	}

	*result = 0
	if x == nil {
		return nil
	}
	if len(path) == 0 {
		return nil
	}
	return nil
}

func (i9 TestStringFloatPtrMapInspector) Append(src, value any, path ...string) (any, error) {
	_, _, _ = src, value, path
	if src == nil {
		return src, nil
	}
	var x *testobj.TestStringFloatPtrMap
	_ = x
	if p, ok := src.(**testobj.TestStringFloatPtrMap); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestStringFloatPtrMap); ok {
		x = p
	} else if v, ok := src.(testobj.TestStringFloatPtrMap); ok {
		x = &v
	} else {
		return src, nil
	}

	return src, nil
}

func (i9 TestStringFloatPtrMapInspector) Reset(x any, path ...string) error {
	if len(path) == 0 {
		return i9.reset1(x, path...)
	} else {
		return i9.reset2(x, path...)
	}
}

func (i9 TestStringFloatPtrMapInspector) reset1(x any, path ...string) error {
	var origin *testobj.TestStringFloatPtrMap
	_ = origin
	switch x.(type) {
	case testobj.TestStringFloatPtrMap:
		return inspector.ErrMustPointerType
	case *testobj.TestStringFloatPtrMap:
		origin = x.(*testobj.TestStringFloatPtrMap)
	case **testobj.TestStringFloatPtrMap:
		origin = *x.(**testobj.TestStringFloatPtrMap)
	default:
		return inspector.ErrUnsupportedType
	}
	if l := len((*origin)); l > 0 {
		for k, _ := range *origin {
			delete((*origin), k)
		}
	}
	return nil
}

func (i9 TestStringFloatPtrMapInspector) reset2(x any, path ...string) error {
	var origin *testobj.TestStringFloatPtrMap
	_ = origin
	switch x.(type) {
	case testobj.TestStringFloatPtrMap:
		return inspector.ErrMustPointerType
	case *testobj.TestStringFloatPtrMap:
		origin = x.(*testobj.TestStringFloatPtrMap)
	case **testobj.TestStringFloatPtrMap:
		origin = *x.(**testobj.TestStringFloatPtrMap)
	default:
		return inspector.ErrUnsupportedType
	}
	if len(path) > 0 {
		if l := len((*origin)); l > 0 {
			var k0 string
			_ = k0
			k0 = path[0]
			x0 := (*origin)[k0]
			_ = x0
			*x0 = 0
			(*origin)[k0] = x0
		}
		return nil
	}
	return nil
}
