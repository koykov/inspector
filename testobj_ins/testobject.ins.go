// Code generated by inspc. DO NOT EDIT.
// source: github.com/koykov/inspector/testobj

package testobj_ins

import (
	"bytes"
	"github.com/koykov/fastconv"
	"github.com/koykov/inspector"
	"github.com/koykov/inspector/testobj"
	"strconv"
)

type TestObjectInspector struct {
	inspector.BaseInspector
}

func (i3 *TestObjectInspector) Get(src interface{}, path ...string) (interface{}, error) {
	var buf interface{}
	err := i3.GetTo(src, &buf, path...)
	return buf, err
}

func (i3 *TestObjectInspector) GetTo(src interface{}, buf *interface{}, path ...string) (err error) {
	if src == nil {
		return
	}
	var x *testobj.TestObject
	_ = x
	if p, ok := src.(**testobj.TestObject); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestObject); ok {
		x = p
	} else if v, ok := src.(testobj.TestObject); ok {
		x = &v
	} else {
		return
	}
	if len(path) == 0 {
		*buf = &(*x)
		return
	}

	if len(path) > 0 {
		if path[0] == "Id" {
			*buf = &x.Id
			return
		}
		if path[0] == "Name" {
			*buf = &x.Name
			return
		}
		if path[0] == "Status" {
			*buf = &x.Status
			return
		}
		if path[0] == "Cost" {
			*buf = &x.Cost
			return
		}
		if path[0] == "Permission" {
			x0 := x.Permission
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var k int32
				t14, err14 := strconv.ParseInt(path[1], 0, 0)
				if err14 != nil {
					return err14
				}
				k = int32(t14)
				x1 := (*x0)[k]
				_ = x1
				*buf = &x1
				return
			}
			*buf = &x.Permission
			return
		}
		if path[0] == "HistoryTree" {
			x0 := x.HistoryTree
			_ = x0
			if len(path) > 1 {
				if x1, ok := (x0)[path[1]]; ok {
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return
						}
						if path[2] == "DateUnix" {
							*buf = &x1.DateUnix
							return
						}
						if path[2] == "Cost" {
							*buf = &x1.Cost
							return
						}
						if path[2] == "Comment" {
							*buf = &x1.Comment
							return
						}
					}
					*buf = &x1
				}
			}
			*buf = &x.HistoryTree
			return
		}
		if path[0] == "Flags" {
			x0 := x.Flags
			_ = x0
			if len(path) > 1 {
				if x1, ok := (x0)[path[1]]; ok {
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.Flags
			return
		}
		if path[0] == "Finance" {
			x0 := x.Finance
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if path[1] == "MoneyIn" {
					*buf = &x0.MoneyIn
					return
				}
				if path[1] == "MoneyOut" {
					*buf = &x0.MoneyOut
					return
				}
				if path[1] == "Balance" {
					*buf = &x0.Balance
					return
				}
				if path[1] == "AllowBuy" {
					*buf = &x0.AllowBuy
					return
				}
				if path[1] == "History" {
					x1 := x0.History
					_ = x1
					if len(path) > 2 {
						var i int
						t15, err15 := strconv.ParseInt(path[2], 0, 0)
						if err15 != nil {
							return err15
						}
						i = int(t15)
						if len(x1) > i {
							x2 := &(x1)[i]
							_ = x2
							if len(path) > 3 {
								if path[3] == "DateUnix" {
									*buf = &x2.DateUnix
									return
								}
								if path[3] == "Cost" {
									*buf = &x2.Cost
									return
								}
								if path[3] == "Comment" {
									*buf = &x2.Comment
									return
								}
							}
							*buf = x2
						}
					}
					*buf = &x0.History
					return
				}
			}
			*buf = &x.Finance
			return
		}
	}
	*buf = &(*x)
	return
}

func (i3 *TestObjectInspector) Cmp(src interface{}, cond inspector.Op, right string, result *bool, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *testobj.TestObject
	_ = x
	if p, ok := src.(**testobj.TestObject); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestObject); ok {
		x = p
	} else if v, ok := src.(testobj.TestObject); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
		if path[0] == "Id" {
			var rightExact string
			rightExact = right

			switch cond {
			case inspector.OpEq:
				*result = x.Id == rightExact
			case inspector.OpNq:
				*result = x.Id != rightExact
			case inspector.OpGt:
				*result = x.Id > rightExact
			case inspector.OpGtq:
				*result = x.Id >= rightExact
			case inspector.OpLt:
				*result = x.Id < rightExact
			case inspector.OpLtq:
				*result = x.Id <= rightExact
			}
			return
		}
		if path[0] == "Name" {
			var rightExact []byte
			rightExact = fastconv.S2B(right)

			if cond == inspector.OpEq {
				*result = bytes.Equal(x.Name, rightExact)
			} else {
				*result = !bytes.Equal(x.Name, rightExact)
			}
			return
		}
		if path[0] == "Status" {
			var rightExact int32
			t18, err18 := strconv.ParseInt(right, 0, 0)
			if err18 != nil {
				return err18
			}
			rightExact = int32(t18)
			switch cond {
			case inspector.OpEq:
				*result = x.Status == rightExact
			case inspector.OpNq:
				*result = x.Status != rightExact
			case inspector.OpGt:
				*result = x.Status > rightExact
			case inspector.OpGtq:
				*result = x.Status >= rightExact
			case inspector.OpLt:
				*result = x.Status < rightExact
			case inspector.OpLtq:
				*result = x.Status <= rightExact
			}
			return
		}
		if path[0] == "Cost" {
			var rightExact float64
			t19, err19 := strconv.ParseFloat(right, 0)
			if err19 != nil {
				return err19
			}
			rightExact = float64(t19)
			switch cond {
			case inspector.OpEq:
				*result = x.Cost == rightExact
			case inspector.OpNq:
				*result = x.Cost != rightExact
			case inspector.OpGt:
				*result = x.Cost > rightExact
			case inspector.OpGtq:
				*result = x.Cost >= rightExact
			case inspector.OpLt:
				*result = x.Cost < rightExact
			case inspector.OpLtq:
				*result = x.Cost <= rightExact
			}
			return
		}
		if path[0] == "Permission" {
			x0 := x.Permission
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var k int32
				t20, err20 := strconv.ParseInt(path[1], 0, 0)
				if err20 != nil {
					return err20
				}
				k = int32(t20)
				x1 := (*x0)[k]
				_ = x1
				var rightExact bool
				t21, err21 := strconv.ParseBool(right)
				if err21 != nil {
					return err21
				}
				rightExact = bool(t21)
				if cond == inspector.OpEq {
					*result = x1 == rightExact
				} else {
					*result = x1 != rightExact
				}
				return
			}
		}
		if path[0] == "HistoryTree" {
			x0 := x.HistoryTree
			_ = x0
			if len(path) > 1 {
				if x1, ok := (x0)[path[1]]; ok {
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return
						}
						if path[2] == "DateUnix" {
							var rightExact int64
							t22, err22 := strconv.ParseInt(right, 0, 0)
							if err22 != nil {
								return err22
							}
							rightExact = int64(t22)
							switch cond {
							case inspector.OpEq:
								*result = x1.DateUnix == rightExact
							case inspector.OpNq:
								*result = x1.DateUnix != rightExact
							case inspector.OpGt:
								*result = x1.DateUnix > rightExact
							case inspector.OpGtq:
								*result = x1.DateUnix >= rightExact
							case inspector.OpLt:
								*result = x1.DateUnix < rightExact
							case inspector.OpLtq:
								*result = x1.DateUnix <= rightExact
							}
							return
						}
						if path[2] == "Cost" {
							var rightExact float64
							t23, err23 := strconv.ParseFloat(right, 0)
							if err23 != nil {
								return err23
							}
							rightExact = float64(t23)
							switch cond {
							case inspector.OpEq:
								*result = x1.Cost == rightExact
							case inspector.OpNq:
								*result = x1.Cost != rightExact
							case inspector.OpGt:
								*result = x1.Cost > rightExact
							case inspector.OpGtq:
								*result = x1.Cost >= rightExact
							case inspector.OpLt:
								*result = x1.Cost < rightExact
							case inspector.OpLtq:
								*result = x1.Cost <= rightExact
							}
							return
						}
						if path[2] == "Comment" {
							var rightExact []byte
							rightExact = fastconv.S2B(right)

							if cond == inspector.OpEq {
								*result = bytes.Equal(x1.Comment, rightExact)
							} else {
								*result = !bytes.Equal(x1.Comment, rightExact)
							}
							return
						}
					}
				}
			}
		}
		if path[0] == "Flags" {
			x0 := x.Flags
			_ = x0
			if len(path) > 1 {
				if x1, ok := (x0)[path[1]]; ok {
					_ = x1
					var rightExact int32
					t25, err25 := strconv.ParseInt(right, 0, 0)
					if err25 != nil {
						return err25
					}
					rightExact = int32(t25)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "Finance" {
			x0 := x.Finance
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if path[1] == "MoneyIn" {
					var rightExact float64
					t26, err26 := strconv.ParseFloat(right, 0)
					if err26 != nil {
						return err26
					}
					rightExact = float64(t26)
					switch cond {
					case inspector.OpEq:
						*result = x0.MoneyIn == rightExact
					case inspector.OpNq:
						*result = x0.MoneyIn != rightExact
					case inspector.OpGt:
						*result = x0.MoneyIn > rightExact
					case inspector.OpGtq:
						*result = x0.MoneyIn >= rightExact
					case inspector.OpLt:
						*result = x0.MoneyIn < rightExact
					case inspector.OpLtq:
						*result = x0.MoneyIn <= rightExact
					}
					return
				}
				if path[1] == "MoneyOut" {
					var rightExact float64
					t27, err27 := strconv.ParseFloat(right, 0)
					if err27 != nil {
						return err27
					}
					rightExact = float64(t27)
					switch cond {
					case inspector.OpEq:
						*result = x0.MoneyOut == rightExact
					case inspector.OpNq:
						*result = x0.MoneyOut != rightExact
					case inspector.OpGt:
						*result = x0.MoneyOut > rightExact
					case inspector.OpGtq:
						*result = x0.MoneyOut >= rightExact
					case inspector.OpLt:
						*result = x0.MoneyOut < rightExact
					case inspector.OpLtq:
						*result = x0.MoneyOut <= rightExact
					}
					return
				}
				if path[1] == "Balance" {
					var rightExact float64
					t28, err28 := strconv.ParseFloat(right, 0)
					if err28 != nil {
						return err28
					}
					rightExact = float64(t28)
					switch cond {
					case inspector.OpEq:
						*result = x0.Balance == rightExact
					case inspector.OpNq:
						*result = x0.Balance != rightExact
					case inspector.OpGt:
						*result = x0.Balance > rightExact
					case inspector.OpGtq:
						*result = x0.Balance >= rightExact
					case inspector.OpLt:
						*result = x0.Balance < rightExact
					case inspector.OpLtq:
						*result = x0.Balance <= rightExact
					}
					return
				}
				if path[1] == "AllowBuy" {
					var rightExact bool
					t29, err29 := strconv.ParseBool(right)
					if err29 != nil {
						return err29
					}
					rightExact = bool(t29)
					if cond == inspector.OpEq {
						*result = x0.AllowBuy == rightExact
					} else {
						*result = x0.AllowBuy != rightExact
					}
					return
				}
				if path[1] == "History" {
					x1 := x0.History
					_ = x1
					if len(path) > 2 {
						var i int
						t30, err30 := strconv.ParseInt(path[2], 0, 0)
						if err30 != nil {
							return err30
						}
						i = int(t30)
						if len(x1) > i {
							x2 := &(x1)[i]
							_ = x2
							if len(path) > 3 {
								if path[3] == "DateUnix" {
									var rightExact int64
									t31, err31 := strconv.ParseInt(right, 0, 0)
									if err31 != nil {
										return err31
									}
									rightExact = int64(t31)
									switch cond {
									case inspector.OpEq:
										*result = x2.DateUnix == rightExact
									case inspector.OpNq:
										*result = x2.DateUnix != rightExact
									case inspector.OpGt:
										*result = x2.DateUnix > rightExact
									case inspector.OpGtq:
										*result = x2.DateUnix >= rightExact
									case inspector.OpLt:
										*result = x2.DateUnix < rightExact
									case inspector.OpLtq:
										*result = x2.DateUnix <= rightExact
									}
									return
								}
								if path[3] == "Cost" {
									var rightExact float64
									t32, err32 := strconv.ParseFloat(right, 0)
									if err32 != nil {
										return err32
									}
									rightExact = float64(t32)
									switch cond {
									case inspector.OpEq:
										*result = x2.Cost == rightExact
									case inspector.OpNq:
										*result = x2.Cost != rightExact
									case inspector.OpGt:
										*result = x2.Cost > rightExact
									case inspector.OpGtq:
										*result = x2.Cost >= rightExact
									case inspector.OpLt:
										*result = x2.Cost < rightExact
									case inspector.OpLtq:
										*result = x2.Cost <= rightExact
									}
									return
								}
								if path[3] == "Comment" {
									var rightExact []byte
									rightExact = fastconv.S2B(right)

									if cond == inspector.OpEq {
										*result = bytes.Equal(x2.Comment, rightExact)
									} else {
										*result = !bytes.Equal(x2.Comment, rightExact)
									}
									return
								}
							}
						}
					}
				}
			}
		}
	}
	return
}

func (i3 *TestObjectInspector) Loop(src interface{}, l inspector.Looper, buf *[]byte, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *testobj.TestObject
	_ = x
	if p, ok := src.(**testobj.TestObject); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestObject); ok {
		x = p
	} else if v, ok := src.(testobj.TestObject); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
		if path[0] == "Permission" {
			x0 := x.Permission
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "HistoryTree" {
			x0 := x.HistoryTree
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = append((*buf)[:0], k...)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((x0)[k], &TestHistoryInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "Flags" {
			x0 := x.Flags
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = append((*buf)[:0], k...)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "Finance" {
			x0 := x.Finance
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if path[1] == "History" {
					x1 := x0.History
					_ = x1
					for k := range x1 {
						if l.RequireKey() {
							*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
							l.SetKey(buf, &inspector.StaticInspector{})
						}
						l.SetVal(&(x1)[k], &TestHistoryInspector{})
						ctl := l.Iterate()
						if ctl == inspector.LoopCtlBrk {
							break
						}
						if ctl == inspector.LoopCtlCnt {
							continue
						}
					}
					return
				}
			}
		}
	}
	return
}

func (i3 *TestObjectInspector) Set(dst, value interface{}, path ...string) error {
	if len(path) == 0 {
		return nil
	}
	if dst == nil {
		return nil
	}
	var x *testobj.TestObject
	_ = x
	if p, ok := dst.(**testobj.TestObject); ok {
		x = *p
	} else if p, ok := dst.(*testobj.TestObject); ok {
		x = p
	} else if v, ok := dst.(testobj.TestObject); ok {
		x = &v
	} else {
		return nil
	}

	if len(path) > 0 {
		if path[0] == "Id" {
			inspector.Assign(&x.Id, value)
			return nil
		}
		if path[0] == "Name" {
			inspector.Assign(&x.Name, value)
			return nil
		}
		if path[0] == "Status" {
			inspector.Assign(&x.Status, value)
			return nil
		}
		if path[0] == "Cost" {
			inspector.Assign(&x.Cost, value)
			return nil
		}
		if path[0] == "Permission" {
			x0 := x.Permission
			if uvalue, ok := value.(*testobj.TestPermission); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(testobj.TestPermission)
				x0 = &z
				x.Permission = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var k int32
				t34, err34 := strconv.ParseInt(path[1], 0, 0)
				if err34 != nil {
					return err34
				}
				k = int32(t34)
				x1 := (*x0)[k]
				_ = x1
				inspector.Assign(&x1, value)
				(*x0)[k] = x1
				return nil
			}
			x.Permission = x0
		}
		if path[0] == "HistoryTree" {
			x0 := x.HistoryTree
			if uvalue, ok := value.(*map[string]*testobj.TestHistory); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(map[string]*testobj.TestHistory)
				x0 = z
				x.HistoryTree = x0
			}
			_ = x0
			if len(path) > 1 {
				x1 := (x0)[path[1]]
				_ = x1
				if len(path) > 2 {
					if x1 == nil {
						return nil
					}
					if path[2] == "DateUnix" {
						inspector.Assign(&x1.DateUnix, value)
						return nil
					}
					if path[2] == "Cost" {
						inspector.Assign(&x1.Cost, value)
						return nil
					}
					if path[2] == "Comment" {
						inspector.Assign(&x1.Comment, value)
						return nil
					}
				}
				(x0)[path[1]] = x1
				return nil
			}
			x.HistoryTree = x0
		}
		if path[0] == "Flags" {
			x0 := x.Flags
			if uvalue, ok := value.(*testobj.TestFlag); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(testobj.TestFlag)
				x0 = z
				x.Flags = x0
			}
			_ = x0
			if len(path) > 1 {
				x1 := (x0)[path[1]]
				_ = x1
				inspector.Assign(&x1, value)
				(x0)[path[1]] = x1
				return nil
			}
			x.Flags = x0
		}
		if path[0] == "Finance" {
			x0 := x.Finance
			if uvalue, ok := value.(*testobj.TestFinance); ok {
				x0 = uvalue
			}
			if x0 == nil {
				x0 = &testobj.TestFinance{}
				x.Finance = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				if path[1] == "MoneyIn" {
					inspector.Assign(&x0.MoneyIn, value)
					return nil
				}
				if path[1] == "MoneyOut" {
					inspector.Assign(&x0.MoneyOut, value)
					return nil
				}
				if path[1] == "Balance" {
					inspector.Assign(&x0.Balance, value)
					return nil
				}
				if path[1] == "AllowBuy" {
					inspector.Assign(&x0.AllowBuy, value)
					return nil
				}
				if path[1] == "History" {
					x1 := x0.History
					if uvalue, ok := value.(*[]testobj.TestHistory); ok {
						x1 = *uvalue
					}
					if x1 == nil {
						z := make([]testobj.TestHistory, 0)
						x1 = z
						x0.History = x1
					}
					_ = x1
					if len(path) > 2 {
						var i int
						t35, err35 := strconv.ParseInt(path[2], 0, 0)
						if err35 != nil {
							return err35
						}
						i = int(t35)
						if len(x1) > i {
							x2 := &(x1)[i]
							_ = x2
							if len(path) > 3 {
								if path[3] == "DateUnix" {
									inspector.Assign(&x2.DateUnix, value)
									return nil
								}
								if path[3] == "Cost" {
									inspector.Assign(&x2.Cost, value)
									return nil
								}
								if path[3] == "Comment" {
									inspector.Assign(&x2.Comment, value)
									return nil
								}
							}
							(x1)[i] = *x2
							return nil
						}
					}
					x0.History = x1
				}
			}
			x.Finance = x0
		}
	}
	return nil
}
