// Code generated by inspc. DO NOT EDIT.
// source: github.com/koykov/inspector/testobj

package testobj_ins

import (
	"encoding/json"
	"github.com/koykov/inspector"
	"github.com/koykov/inspector/testobj"
	"strconv"
)

type TestObject1Inspector struct {
	inspector.BaseInspector
}

func (i6 TestObject1Inspector) TypeName() string {
	return "TestObject1"
}

func (i6 TestObject1Inspector) Get(src interface{}, path ...string) (interface{}, error) {
	var buf interface{}
	err := i6.GetTo(src, &buf, path...)
	return buf, err
}

func (i6 TestObject1Inspector) GetTo(src interface{}, buf *interface{}, path ...string) (err error) {
	if src == nil {
		return
	}
	var x *testobj.TestObject1
	_ = x
	if p, ok := src.(**testobj.TestObject1); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestObject1); ok {
		x = p
	} else if v, ok := src.(testobj.TestObject1); ok {
		x = &v
	} else {
		return
	}
	if len(path) == 0 {
		*buf = &(*x)
		return
	}

	if len(path) > 0 {
		if path[0] == "IntSlice" {
			x0 := x.IntSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t44, err44 := strconv.ParseInt(path[1], 0, 0)
				if err44 != nil {
					return err44
				}
				i = int(t44)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.IntSlice
			return
		}
		if path[0] == "IntPtrSlice" {
			x0 := x.IntPtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t45, err45 := strconv.ParseInt(path[1], 0, 0)
				if err45 != nil {
					return err45
				}
				i = int(t45)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.IntPtrSlice
			return
		}
		if path[0] == "IntSlicePtr" {
			x0 := x.IntSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t46, err46 := strconv.ParseInt(path[1], 0, 0)
				if err46 != nil {
					return err46
				}
				i = int(t46)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.IntSlicePtr
			return
		}
		if path[0] == "IntPtrSlicePtr" {
			x0 := x.IntPtrSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t47, err47 := strconv.ParseInt(path[1], 0, 0)
				if err47 != nil {
					return err47
				}
				i = int(t47)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.IntPtrSlicePtr
			return
		}
		if path[0] == "FloatSlice" {
			x0 := x.FloatSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t48, err48 := strconv.ParseInt(path[1], 0, 0)
				if err48 != nil {
					return err48
				}
				i = int(t48)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.FloatSlice
			return
		}
		if path[0] == "FloatPtrSlice" {
			x0 := x.FloatPtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t49, err49 := strconv.ParseInt(path[1], 0, 0)
				if err49 != nil {
					return err49
				}
				i = int(t49)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.FloatPtrSlice
			return
		}
		if path[0] == "FloatSlicePtr" {
			x0 := x.FloatSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t50, err50 := strconv.ParseInt(path[1], 0, 0)
				if err50 != nil {
					return err50
				}
				i = int(t50)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.FloatSlicePtr
			return
		}
		if path[0] == "FloatPtrSlicePtr" {
			x0 := x.FloatPtrSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t51, err51 := strconv.ParseInt(path[1], 0, 0)
				if err51 != nil {
					return err51
				}
				i = int(t51)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.FloatPtrSlicePtr
			return
		}
	}
	return
}

func (i6 TestObject1Inspector) Cmp(src interface{}, cond inspector.Op, right string, result *bool, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *testobj.TestObject1
	_ = x
	if p, ok := src.(**testobj.TestObject1); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestObject1); ok {
		x = p
	} else if v, ok := src.(testobj.TestObject1); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
		if path[0] == "IntSlice" {
			x0 := x.IntSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t52, err52 := strconv.ParseInt(path[1], 0, 0)
				if err52 != nil {
					return err52
				}
				i = int(t52)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					var rightExact int32
					t53, err53 := strconv.ParseInt(right, 0, 0)
					if err53 != nil {
						return err53
					}
					rightExact = int32(t53)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "IntPtrSlice" {
			x0 := x.IntPtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t54, err54 := strconv.ParseInt(path[1], 0, 0)
				if err54 != nil {
					return err54
				}
				i = int(t54)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "IntSlicePtr" {
			x0 := x.IntSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t55, err55 := strconv.ParseInt(path[1], 0, 0)
				if err55 != nil {
					return err55
				}
				i = int(t55)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					var rightExact int32
					t56, err56 := strconv.ParseInt(right, 0, 0)
					if err56 != nil {
						return err56
					}
					rightExact = int32(t56)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "IntPtrSlicePtr" {
			x0 := x.IntPtrSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t57, err57 := strconv.ParseInt(path[1], 0, 0)
				if err57 != nil {
					return err57
				}
				i = int(t57)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "FloatSlice" {
			x0 := x.FloatSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t58, err58 := strconv.ParseInt(path[1], 0, 0)
				if err58 != nil {
					return err58
				}
				i = int(t58)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					var rightExact float32
					t59, err59 := strconv.ParseFloat(right, 0)
					if err59 != nil {
						return err59
					}
					rightExact = float32(t59)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "FloatPtrSlice" {
			x0 := x.FloatPtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t60, err60 := strconv.ParseInt(path[1], 0, 0)
				if err60 != nil {
					return err60
				}
				i = int(t60)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "FloatSlicePtr" {
			x0 := x.FloatSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t61, err61 := strconv.ParseInt(path[1], 0, 0)
				if err61 != nil {
					return err61
				}
				i = int(t61)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					var rightExact float32
					t62, err62 := strconv.ParseFloat(right, 0)
					if err62 != nil {
						return err62
					}
					rightExact = float32(t62)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "FloatPtrSlicePtr" {
			x0 := x.FloatPtrSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t63, err63 := strconv.ParseInt(path[1], 0, 0)
				if err63 != nil {
					return err63
				}
				i = int(t63)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
	}
	return
}

func (i6 TestObject1Inspector) Loop(src interface{}, l inspector.Looper, buf *[]byte, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *testobj.TestObject1
	_ = x
	if p, ok := src.(**testobj.TestObject1); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestObject1); ok {
		x = p
	} else if v, ok := src.(testobj.TestObject1); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
		if path[0] == "IntSlice" {
			x0 := x.IntSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntPtrSlice" {
			x0 := x.IntPtrSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntSlicePtr" {
			x0 := x.IntSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntPtrSlicePtr" {
			x0 := x.IntPtrSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatSlice" {
			x0 := x.FloatSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatPtrSlice" {
			x0 := x.FloatPtrSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatSlicePtr" {
			x0 := x.FloatSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatPtrSlicePtr" {
			x0 := x.FloatPtrSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
	}
	return
}

func (i6 TestObject1Inspector) SetWB(dst, value interface{}, buf inspector.AccumulativeBuffer, path ...string) error {
	if len(path) == 0 {
		return nil
	}
	if dst == nil {
		return nil
	}
	var x *testobj.TestObject1
	_ = x
	if p, ok := dst.(**testobj.TestObject1); ok {
		x = *p
	} else if p, ok := dst.(*testobj.TestObject1); ok {
		x = p
	} else if v, ok := dst.(testobj.TestObject1); ok {
		x = &v
	} else {
		return nil
	}

	if len(path) > 0 {
		if path[0] == "IntSlice" {
			x0 := x.IntSlice
			if uvalue, ok := value.(*[]int32); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make([]int32, 0)
				x0 = z
				x.IntSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t64, err64 := strconv.ParseInt(path[1], 0, 0)
				if err64 != nil {
					return err64
				}
				i = int(t64)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					inspector.AssignBuf(&x1, value, buf)
					return nil
					(x0)[i] = x1
					return nil
				}
			}
			x.IntSlice = x0
		}
		if path[0] == "IntPtrSlice" {
			x0 := x.IntPtrSlice
			if uvalue, ok := value.(*[]*int32); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make([]*int32, 0)
				x0 = z
				x.IntPtrSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t65, err65 := strconv.ParseInt(path[1], 0, 0)
				if err65 != nil {
					return err65
				}
				i = int(t65)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return nil
					}
					inspector.AssignBuf(x1, value, buf)
					return nil
					(x0)[i] = x1
					return nil
				}
			}
			x.IntPtrSlice = x0
		}
		if path[0] == "IntSlicePtr" {
			x0 := x.IntSlicePtr
			if uvalue, ok := value.(*[]int32); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make([]int32, 0)
				x0 = &z
				x.IntSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t66, err66 := strconv.ParseInt(path[1], 0, 0)
				if err66 != nil {
					return err66
				}
				i = int(t66)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					inspector.AssignBuf(&x1, value, buf)
					return nil
					(*x0)[i] = x1
					return nil
				}
			}
			x.IntSlicePtr = x0
		}
		if path[0] == "IntPtrSlicePtr" {
			x0 := x.IntPtrSlicePtr
			if uvalue, ok := value.(*[]*int32); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make([]*int32, 0)
				x0 = &z
				x.IntPtrSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t67, err67 := strconv.ParseInt(path[1], 0, 0)
				if err67 != nil {
					return err67
				}
				i = int(t67)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return nil
					}
					inspector.AssignBuf(x1, value, buf)
					return nil
					(*x0)[i] = x1
					return nil
				}
			}
			x.IntPtrSlicePtr = x0
		}
		if path[0] == "FloatSlice" {
			x0 := x.FloatSlice
			if uvalue, ok := value.(*testobj.TestFloatSlice); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(testobj.TestFloatSlice, 0)
				x0 = z
				x.FloatSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t68, err68 := strconv.ParseInt(path[1], 0, 0)
				if err68 != nil {
					return err68
				}
				i = int(t68)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					inspector.AssignBuf(&x1, value, buf)
					return nil
					(x0)[i] = x1
					return nil
				}
			}
			x.FloatSlice = x0
		}
		if path[0] == "FloatPtrSlice" {
			x0 := x.FloatPtrSlice
			if uvalue, ok := value.(*testobj.TestFloatPtrSlice); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(testobj.TestFloatPtrSlice, 0)
				x0 = z
				x.FloatPtrSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t69, err69 := strconv.ParseInt(path[1], 0, 0)
				if err69 != nil {
					return err69
				}
				i = int(t69)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return nil
					}
					inspector.AssignBuf(x1, value, buf)
					return nil
					(x0)[i] = x1
					return nil
				}
			}
			x.FloatPtrSlice = x0
		}
		if path[0] == "FloatSlicePtr" {
			x0 := x.FloatSlicePtr
			if uvalue, ok := value.(*testobj.TestFloatSlice); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(testobj.TestFloatSlice, 0)
				x0 = &z
				x.FloatSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t70, err70 := strconv.ParseInt(path[1], 0, 0)
				if err70 != nil {
					return err70
				}
				i = int(t70)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					inspector.AssignBuf(&x1, value, buf)
					return nil
					(*x0)[i] = x1
					return nil
				}
			}
			x.FloatSlicePtr = x0
		}
		if path[0] == "FloatPtrSlicePtr" {
			x0 := x.FloatPtrSlicePtr
			if uvalue, ok := value.(*testobj.TestFloatPtrSlice); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(testobj.TestFloatPtrSlice, 0)
				x0 = &z
				x.FloatPtrSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t71, err71 := strconv.ParseInt(path[1], 0, 0)
				if err71 != nil {
					return err71
				}
				i = int(t71)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return nil
					}
					inspector.AssignBuf(x1, value, buf)
					return nil
					(*x0)[i] = x1
					return nil
				}
			}
			x.FloatPtrSlicePtr = x0
		}
	}
	return nil
}

func (i6 TestObject1Inspector) Set(dst, value interface{}, path ...string) error {
	return i6.SetWB(dst, value, nil, path...)
}

func (i6 TestObject1Inspector) DeepEqual(l, r interface{}) bool {
	return i6.DeepEqualWithOptions(l, r, nil)
}

func (i6 TestObject1Inspector) DeepEqualWithOptions(l, r interface{}, opts *inspector.DEQOptions) bool {
	var (
		lx, rx   *testobj.TestObject1
		leq, req bool
	)
	_, _, _, _ = lx, rx, leq, req
	if lp, ok := l.(**testobj.TestObject1); ok {
		lx, leq = *lp, true
	} else if lp, ok := l.(*testobj.TestObject1); ok {
		lx, leq = lp, true
	} else if lp, ok := l.(testobj.TestObject1); ok {
		lx, leq = &lp, true
	}
	if rp, ok := r.(**testobj.TestObject1); ok {
		rx, req = *rp, true
	} else if rp, ok := r.(*testobj.TestObject1); ok {
		rx, req = rp, true
	} else if rp, ok := r.(testobj.TestObject1); ok {
		rx, req = &rp, true
	}
	if !leq || !req {
		return false
	}
	if lx == nil && rx == nil {
		return true
	}
	if (lx == nil && rx != nil) || (lx != nil && rx == nil) {
		return false
	}

	lx1 := lx.IntSlice
	rx1 := rx.IntSlice
	_, _ = lx1, rx1
	if inspector.DEQMustCheck("IntSlice", opts) {
		if len(lx1) != len(rx1) {
			return false
		}
		for i := 0; i < len(lx1); i++ {
			lx2 := (lx1)[i]
			rx2 := (rx1)[i]
			_, _ = lx2, rx2
			if lx2 != rx2 {
				return false
			}
		}
	}
	lx3 := lx.IntPtrSlice
	rx3 := rx.IntPtrSlice
	_, _ = lx3, rx3
	if inspector.DEQMustCheck("IntPtrSlice", opts) {
		if len(lx3) != len(rx3) {
			return false
		}
		for i := 0; i < len(lx3); i++ {
			lx4 := (lx3)[i]
			rx4 := (rx3)[i]
			_, _ = lx4, rx4
			if (lx4 == nil && rx4 != nil) || (lx4 != nil && rx4 == nil) {
				return false
			}
			if lx4 != nil && rx4 != nil {
				if *lx4 != *rx4 {
					return false
				}
			}
		}
	}
	lx5 := lx.IntSlicePtr
	rx5 := rx.IntSlicePtr
	_, _ = lx5, rx5
	if (lx5 == nil && rx5 != nil) || (lx5 != nil && rx5 == nil) {
		return false
	}
	if lx5 != nil && rx5 != nil {
		if inspector.DEQMustCheck("IntSlicePtr", opts) {
			if len(*lx5) != len(*rx5) {
				return false
			}
			for i := 0; i < len(*lx5); i++ {
				lx6 := (*lx5)[i]
				rx6 := (*rx5)[i]
				_, _ = lx6, rx6
				if lx6 != rx6 {
					return false
				}
			}
		}
	}
	lx7 := lx.IntPtrSlicePtr
	rx7 := rx.IntPtrSlicePtr
	_, _ = lx7, rx7
	if (lx7 == nil && rx7 != nil) || (lx7 != nil && rx7 == nil) {
		return false
	}
	if lx7 != nil && rx7 != nil {
		if inspector.DEQMustCheck("IntPtrSlicePtr", opts) {
			if len(*lx7) != len(*rx7) {
				return false
			}
			for i := 0; i < len(*lx7); i++ {
				lx8 := (*lx7)[i]
				rx8 := (*rx7)[i]
				_, _ = lx8, rx8
				if (lx8 == nil && rx8 != nil) || (lx8 != nil && rx8 == nil) {
					return false
				}
				if lx8 != nil && rx8 != nil {
					if *lx8 != *rx8 {
						return false
					}
				}
			}
		}
	}
	lx9 := lx.FloatSlice
	rx9 := rx.FloatSlice
	_, _ = lx9, rx9
	if inspector.DEQMustCheck("FloatSlice", opts) {
		if len(lx9) != len(rx9) {
			return false
		}
		for i := 0; i < len(lx9); i++ {
			lx10 := (lx9)[i]
			rx10 := (rx9)[i]
			_, _ = lx10, rx10
			if lx10 != rx10 {
				return false
			}
		}
	}
	lx11 := lx.FloatPtrSlice
	rx11 := rx.FloatPtrSlice
	_, _ = lx11, rx11
	if inspector.DEQMustCheck("FloatPtrSlice", opts) {
		if len(lx11) != len(rx11) {
			return false
		}
		for i := 0; i < len(lx11); i++ {
			lx12 := (lx11)[i]
			rx12 := (rx11)[i]
			_, _ = lx12, rx12
			if (lx12 == nil && rx12 != nil) || (lx12 != nil && rx12 == nil) {
				return false
			}
			if lx12 != nil && rx12 != nil {
				if *lx12 != *rx12 {
					return false
				}
			}
		}
	}
	lx13 := lx.FloatSlicePtr
	rx13 := rx.FloatSlicePtr
	_, _ = lx13, rx13
	if (lx13 == nil && rx13 != nil) || (lx13 != nil && rx13 == nil) {
		return false
	}
	if lx13 != nil && rx13 != nil {
		if inspector.DEQMustCheck("FloatSlicePtr", opts) {
			if len(*lx13) != len(*rx13) {
				return false
			}
			for i := 0; i < len(*lx13); i++ {
				lx14 := (*lx13)[i]
				rx14 := (*rx13)[i]
				_, _ = lx14, rx14
				if lx14 != rx14 {
					return false
				}
			}
		}
	}
	lx15 := lx.FloatPtrSlicePtr
	rx15 := rx.FloatPtrSlicePtr
	_, _ = lx15, rx15
	if (lx15 == nil && rx15 != nil) || (lx15 != nil && rx15 == nil) {
		return false
	}
	if lx15 != nil && rx15 != nil {
		if inspector.DEQMustCheck("FloatPtrSlicePtr", opts) {
			if len(*lx15) != len(*rx15) {
				return false
			}
			for i := 0; i < len(*lx15); i++ {
				lx16 := (*lx15)[i]
				rx16 := (*rx15)[i]
				_, _ = lx16, rx16
				if (lx16 == nil && rx16 != nil) || (lx16 != nil && rx16 == nil) {
					return false
				}
				if lx16 != nil && rx16 != nil {
					if *lx16 != *rx16 {
						return false
					}
				}
			}
		}
	}
	return true
}

func (i6 TestObject1Inspector) Unmarshal(p []byte, typ inspector.Encoding) (interface{}, error) {
	var x testobj.TestObject1
	switch typ {
	case inspector.EncodingJSON:
		err := json.Unmarshal(p, &x)
		return &x, err
	default:
		return nil, inspector.ErrUnknownEncodingType
	}
}

func (i6 TestObject1Inspector) Copy(x interface{}) (interface{}, error) {
	var origin, cpy testobj.TestObject1
	switch x.(type) {
	case testobj.TestObject1:
		origin = x.(testobj.TestObject1)
	case *testobj.TestObject1:
		origin = *x.(*testobj.TestObject1)
	case **testobj.TestObject1:
		origin = **x.(**testobj.TestObject1)
	default:
		return nil, inspector.ErrUnsupportedType
	}
	bc := i6.calcBytes(&origin)
	buf := make([]byte, 0, bc)
	if err := i6.cpy(buf, &cpy, &origin); err != nil {
		return nil, err
	}
	return cpy, nil
}

func (i6 TestObject1Inspector) calcBytes(x *testobj.TestObject1) (c int) {
	return c
}

func (i6 TestObject1Inspector) cpy(buf []byte, l, r *testobj.TestObject1) error {
	if len(r.IntSlice) > 0 {
		buf1 := make([]int32, 0, len(r.IntSlice))
		for i1 := 0; i1 < len(r.IntSlice); i1++ {
			var b1 int32
			x1 := (l.IntSlice)[i1]
			b1 = x1
			buf1 = append(buf1, b1)
		}
		l.IntSlice = buf1
	}
	if len(r.IntPtrSlice) > 0 {
		buf1 := make([]*int32, 0, len(r.IntPtrSlice))
		for i1 := 0; i1 < len(r.IntPtrSlice); i1++ {
			var b1 *int32
			x1 := (l.IntPtrSlice)[i1]
			b1 = x1
			buf1 = append(buf1, b1)
		}
		l.IntPtrSlice = buf1
	}
	if l.IntSlicePtr != nil {
		if len(*r.IntSlicePtr) > 0 {
			buf1 := make([]int32, 0, len(*r.IntSlicePtr))
			for i1 := 0; i1 < len(*r.IntSlicePtr); i1++ {
				var b1 int32
				x1 := (*l.IntSlicePtr)[i1]
				b1 = x1
				buf1 = append(buf1, b1)
			}
			l.IntSlicePtr = &buf1
		}
	}
	if l.IntPtrSlicePtr != nil {
		if len(*r.IntPtrSlicePtr) > 0 {
			buf1 := make([]*int32, 0, len(*r.IntPtrSlicePtr))
			for i1 := 0; i1 < len(*r.IntPtrSlicePtr); i1++ {
				var b1 *int32
				x1 := (*l.IntPtrSlicePtr)[i1]
				b1 = x1
				buf1 = append(buf1, b1)
			}
			l.IntPtrSlicePtr = &buf1
		}
	}
	if len(r.FloatSlice) > 0 {
		buf1 := make(testobj.TestFloatSlice, 0, len(r.FloatSlice))
		for i1 := 0; i1 < len(r.FloatSlice); i1++ {
			var b1 float32
			x1 := (l.FloatSlice)[i1]
			b1 = x1
			buf1 = append(buf1, b1)
		}
		l.FloatSlice = buf1
	}
	if len(r.FloatPtrSlice) > 0 {
		buf1 := make(testobj.TestFloatPtrSlice, 0, len(r.FloatPtrSlice))
		for i1 := 0; i1 < len(r.FloatPtrSlice); i1++ {
			var b1 *float32
			x1 := (l.FloatPtrSlice)[i1]
			b1 = x1
			buf1 = append(buf1, b1)
		}
		l.FloatPtrSlice = buf1
	}
	if l.FloatSlicePtr != nil {
		if len(*r.FloatSlicePtr) > 0 {
			buf1 := make(testobj.TestFloatSlice, 0, len(*r.FloatSlicePtr))
			for i1 := 0; i1 < len(*r.FloatSlicePtr); i1++ {
				var b1 float32
				x1 := (*l.FloatSlicePtr)[i1]
				b1 = x1
				buf1 = append(buf1, b1)
			}
			l.FloatSlicePtr = &buf1
		}
	}
	if l.FloatPtrSlicePtr != nil {
		if len(*r.FloatPtrSlicePtr) > 0 {
			buf1 := make(testobj.TestFloatPtrSlice, 0, len(*r.FloatPtrSlicePtr))
			for i1 := 0; i1 < len(*r.FloatPtrSlicePtr); i1++ {
				var b1 *float32
				x1 := (*l.FloatPtrSlicePtr)[i1]
				b1 = x1
				buf1 = append(buf1, b1)
			}
			l.FloatPtrSlicePtr = &buf1
		}
	}
	return nil
}
