// Code generated by inspc. DO NOT EDIT.
// source: github.com/koykov/inspector/testobj

package testobj_ins

import (
	"bytes"
	"encoding/json"
	"github.com/koykov/fastconv"
	"github.com/koykov/inspector"
	"github.com/koykov/inspector/testobj"
	"strconv"
)

type TestObject1Inspector struct {
	inspector.BaseInspector
}

func (i6 TestObject1Inspector) TypeName() string {
	return "TestObject1"
}

func (i6 TestObject1Inspector) Get(src interface{}, path ...string) (interface{}, error) {
	var buf interface{}
	err := i6.GetTo(src, &buf, path...)
	return buf, err
}

func (i6 TestObject1Inspector) GetTo(src interface{}, buf *interface{}, path ...string) (err error) {
	if src == nil {
		return
	}
	var x *testobj.TestObject1
	_ = x
	if p, ok := src.(**testobj.TestObject1); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestObject1); ok {
		x = p
	} else if v, ok := src.(testobj.TestObject1); ok {
		x = &v
	} else {
		return
	}
	if len(path) == 0 {
		*buf = &(*x)
		return
	}

	if len(path) > 0 {
		if path[0] == "IntSlice" {
			x0 := x.IntSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t44, err44 := strconv.ParseInt(path[1], 0, 0)
				if err44 != nil {
					return err44
				}
				i = int(t44)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.IntSlice
			return
		}
		if path[0] == "IntPtrSlice" {
			x0 := x.IntPtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t45, err45 := strconv.ParseInt(path[1], 0, 0)
				if err45 != nil {
					return err45
				}
				i = int(t45)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.IntPtrSlice
			return
		}
		if path[0] == "IntSlicePtr" {
			x0 := x.IntSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t46, err46 := strconv.ParseInt(path[1], 0, 0)
				if err46 != nil {
					return err46
				}
				i = int(t46)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.IntSlicePtr
			return
		}
		if path[0] == "IntPtrSlicePtr" {
			x0 := x.IntPtrSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t47, err47 := strconv.ParseInt(path[1], 0, 0)
				if err47 != nil {
					return err47
				}
				i = int(t47)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.IntPtrSlicePtr
			return
		}
		if path[0] == "ByteSlice" {
			*buf = &x.ByteSlice
			return
		}
		if path[0] == "BytePtrSlice" {
			x0 := x.BytePtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t48, err48 := strconv.ParseInt(path[1], 0, 0)
				if err48 != nil {
					return err48
				}
				i = int(t48)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.BytePtrSlice
			return
		}
		if path[0] == "ByteSlicePtr" {
			*buf = &x.ByteSlicePtr
			return
		}
		if path[0] == "BytePtrSlicePtr" {
			x0 := x.BytePtrSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t49, err49 := strconv.ParseInt(path[1], 0, 0)
				if err49 != nil {
					return err49
				}
				i = int(t49)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.BytePtrSlicePtr
			return
		}
		if path[0] == "FloatSlice" {
			x0 := x.FloatSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t50, err50 := strconv.ParseInt(path[1], 0, 0)
				if err50 != nil {
					return err50
				}
				i = int(t50)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.FloatSlice
			return
		}
		if path[0] == "FloatPtrSlice" {
			x0 := x.FloatPtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t51, err51 := strconv.ParseInt(path[1], 0, 0)
				if err51 != nil {
					return err51
				}
				i = int(t51)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.FloatPtrSlice
			return
		}
		if path[0] == "FloatSlicePtr" {
			x0 := x.FloatSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t52, err52 := strconv.ParseInt(path[1], 0, 0)
				if err52 != nil {
					return err52
				}
				i = int(t52)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.FloatSlicePtr
			return
		}
		if path[0] == "FloatPtrSlicePtr" {
			x0 := x.FloatPtrSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t53, err53 := strconv.ParseInt(path[1], 0, 0)
				if err53 != nil {
					return err53
				}
				i = int(t53)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.FloatPtrSlicePtr
			return
		}
		if path[0] == "StructSlice" {
			x0 := x.StructSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t54, err54 := strconv.ParseInt(path[1], 0, 0)
				if err54 != nil {
					return err54
				}
				i = int(t54)
				if len(x0) > i {
					x1 := &(x0)[i]
					_ = x1
					if len(path) > 2 {
						if path[2] == "A" {
							*buf = &x1.A
							return
						}
						if path[2] == "S" {
							*buf = &x1.S
							return
						}
						if path[2] == "B" {
							*buf = &x1.B
							return
						}
						if path[2] == "I" {
							*buf = &x1.I
							return
						}
						if path[2] == "I8" {
							*buf = &x1.I8
							return
						}
						if path[2] == "I16" {
							*buf = &x1.I16
							return
						}
						if path[2] == "I32" {
							*buf = &x1.I32
							return
						}
						if path[2] == "I64" {
							*buf = &x1.I64
							return
						}
						if path[2] == "U" {
							*buf = &x1.U
							return
						}
						if path[2] == "U8" {
							*buf = &x1.U8
							return
						}
						if path[2] == "U16" {
							*buf = &x1.U16
							return
						}
						if path[2] == "U32" {
							*buf = &x1.U32
							return
						}
						if path[2] == "U64" {
							*buf = &x1.U64
							return
						}
						if path[2] == "F" {
							*buf = &x1.F
							return
						}
						if path[2] == "D" {
							*buf = &x1.D
							return
						}
					}
					*buf = x1
				}
			}
			*buf = &x.StructSlice
			return
		}
		if path[0] == "StructPtrSlice" {
			x0 := x.StructPtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t55, err55 := strconv.ParseInt(path[1], 0, 0)
				if err55 != nil {
					return err55
				}
				i = int(t55)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return
						}
						if path[2] == "A" {
							*buf = &x1.A
							return
						}
						if path[2] == "S" {
							*buf = &x1.S
							return
						}
						if path[2] == "B" {
							*buf = &x1.B
							return
						}
						if path[2] == "I" {
							*buf = &x1.I
							return
						}
						if path[2] == "I8" {
							*buf = &x1.I8
							return
						}
						if path[2] == "I16" {
							*buf = &x1.I16
							return
						}
						if path[2] == "I32" {
							*buf = &x1.I32
							return
						}
						if path[2] == "I64" {
							*buf = &x1.I64
							return
						}
						if path[2] == "U" {
							*buf = &x1.U
							return
						}
						if path[2] == "U8" {
							*buf = &x1.U8
							return
						}
						if path[2] == "U16" {
							*buf = &x1.U16
							return
						}
						if path[2] == "U32" {
							*buf = &x1.U32
							return
						}
						if path[2] == "U64" {
							*buf = &x1.U64
							return
						}
						if path[2] == "F" {
							*buf = &x1.F
							return
						}
						if path[2] == "D" {
							*buf = &x1.D
							return
						}
					}
					*buf = x1
				}
			}
			*buf = &x.StructPtrSlice
			return
		}
		if path[0] == "StructSlicePtr" {
			x0 := x.StructSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t56, err56 := strconv.ParseInt(path[1], 0, 0)
				if err56 != nil {
					return err56
				}
				i = int(t56)
				if len(*x0) > i {
					x1 := &(*x0)[i]
					_ = x1
					if len(path) > 2 {
						if path[2] == "A" {
							*buf = &x1.A
							return
						}
						if path[2] == "S" {
							*buf = &x1.S
							return
						}
						if path[2] == "B" {
							*buf = &x1.B
							return
						}
						if path[2] == "I" {
							*buf = &x1.I
							return
						}
						if path[2] == "I8" {
							*buf = &x1.I8
							return
						}
						if path[2] == "I16" {
							*buf = &x1.I16
							return
						}
						if path[2] == "I32" {
							*buf = &x1.I32
							return
						}
						if path[2] == "I64" {
							*buf = &x1.I64
							return
						}
						if path[2] == "U" {
							*buf = &x1.U
							return
						}
						if path[2] == "U8" {
							*buf = &x1.U8
							return
						}
						if path[2] == "U16" {
							*buf = &x1.U16
							return
						}
						if path[2] == "U32" {
							*buf = &x1.U32
							return
						}
						if path[2] == "U64" {
							*buf = &x1.U64
							return
						}
						if path[2] == "F" {
							*buf = &x1.F
							return
						}
						if path[2] == "D" {
							*buf = &x1.D
							return
						}
					}
					*buf = x1
				}
			}
			*buf = &x.StructSlicePtr
			return
		}
		if path[0] == "StructPtrSlicePtr" {
			x0 := x.StructPtrSlicePtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t57, err57 := strconv.ParseInt(path[1], 0, 0)
				if err57 != nil {
					return err57
				}
				i = int(t57)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return
						}
						if path[2] == "A" {
							*buf = &x1.A
							return
						}
						if path[2] == "S" {
							*buf = &x1.S
							return
						}
						if path[2] == "B" {
							*buf = &x1.B
							return
						}
						if path[2] == "I" {
							*buf = &x1.I
							return
						}
						if path[2] == "I8" {
							*buf = &x1.I8
							return
						}
						if path[2] == "I16" {
							*buf = &x1.I16
							return
						}
						if path[2] == "I32" {
							*buf = &x1.I32
							return
						}
						if path[2] == "I64" {
							*buf = &x1.I64
							return
						}
						if path[2] == "U" {
							*buf = &x1.U
							return
						}
						if path[2] == "U8" {
							*buf = &x1.U8
							return
						}
						if path[2] == "U16" {
							*buf = &x1.U16
							return
						}
						if path[2] == "U32" {
							*buf = &x1.U32
							return
						}
						if path[2] == "U64" {
							*buf = &x1.U64
							return
						}
						if path[2] == "F" {
							*buf = &x1.F
							return
						}
						if path[2] == "D" {
							*buf = &x1.D
							return
						}
					}
					*buf = x1
				}
			}
			*buf = &x.StructPtrSlicePtr
			return
		}
		if path[0] == "IntStringMap" {
			x0 := x.IntStringMap
			_ = x0
			if len(path) > 1 {
				var k int
				t58, err58 := strconv.ParseInt(path[1], 0, 0)
				if err58 != nil {
					return err58
				}
				k = int(t58)
				x1 := (x0)[k]
				_ = x1
				*buf = &x1
				return
			}
			*buf = &x.IntStringMap
			return
		}
		if path[0] == "IntStringPtrMap" {
			x0 := x.IntStringPtrMap
			_ = x0
			if len(path) > 1 {
				var k int
				t59, err59 := strconv.ParseInt(path[1], 0, 0)
				if err59 != nil {
					return err59
				}
				k = int(t59)
				x1 := (x0)[k]
				_ = x1
				if x1 == nil {
					return
				}
				*buf = &x1
				return
			}
			*buf = &x.IntStringPtrMap
			return
		}
		if path[0] == "IntStringMapPtr" {
			x0 := x.IntStringMapPtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var k int
				t60, err60 := strconv.ParseInt(path[1], 0, 0)
				if err60 != nil {
					return err60
				}
				k = int(t60)
				x1 := (*x0)[k]
				_ = x1
				*buf = &x1
				return
			}
			*buf = &x.IntStringMapPtr
			return
		}
		if path[0] == "IntStringPtrMapPtr" {
			x0 := x.IntStringPtrMapPtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var k int
				t61, err61 := strconv.ParseInt(path[1], 0, 0)
				if err61 != nil {
					return err61
				}
				k = int(t61)
				x1 := (*x0)[k]
				_ = x1
				if x1 == nil {
					return
				}
				*buf = &x1
				return
			}
			*buf = &x.IntStringPtrMapPtr
			return
		}
		if path[0] == "IntPtrStringPtrMapPtr" {
			x0 := x.IntPtrStringPtrMapPtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var k int
				t62, err62 := strconv.ParseInt(path[1], 0, 0)
				if err62 != nil {
					return err62
				}
				k = int(t62)
				x1 := (*x0)[&k]
				_ = x1
				if x1 == nil {
					return
				}
				*buf = &x1
				return
			}
			*buf = &x.IntPtrStringPtrMapPtr
			return
		}
		if path[0] == "StringFloatMap" {
			x0 := x.StringFloatMap
			_ = x0
			if len(path) > 1 {
				if x1, ok := (x0)[path[1]]; ok {
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.StringFloatMap
			return
		}
		if path[0] == "StringFloatPtrMap" {
			x0 := x.StringFloatPtrMap
			_ = x0
			if len(path) > 1 {
				if x1, ok := (x0)[path[1]]; ok {
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.StringFloatPtrMap
			return
		}
		if path[0] == "StringFloatMapPtr" {
			x0 := x.StringFloatMapPtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if x1, ok := (*x0)[path[1]]; ok {
					_ = x1
					*buf = &x1
					return
				}
			}
			*buf = &x.StringFloatMapPtr
			return
		}
		if path[0] == "StringFloatPtrMapPtr" {
			x0 := x.StringFloatPtrMapPtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if x1, ok := (*x0)[path[1]]; ok {
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.StringFloatPtrMapPtr
			return
		}
		if path[0] == "StringPtrFloatPtrMapPtr" {
			x0 := x.StringPtrFloatPtrMapPtr
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if x1, ok := (*x0)[&path[1]]; ok {
					_ = x1
					if x1 == nil {
						return
					}
					*buf = &x1
					return
				}
			}
			*buf = &x.StringPtrFloatPtrMapPtr
			return
		}
	}
	return
}

func (i6 TestObject1Inspector) Cmp(src interface{}, cond inspector.Op, right string, result *bool, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *testobj.TestObject1
	_ = x
	if p, ok := src.(**testobj.TestObject1); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestObject1); ok {
		x = p
	} else if v, ok := src.(testobj.TestObject1); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
		if path[0] == "IntSlice" {
			x0 := x.IntSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t63, err63 := strconv.ParseInt(path[1], 0, 0)
				if err63 != nil {
					return err63
				}
				i = int(t63)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					var rightExact int32
					t64, err64 := strconv.ParseInt(right, 0, 0)
					if err64 != nil {
						return err64
					}
					rightExact = int32(t64)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "IntPtrSlice" {
			x0 := x.IntPtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t65, err65 := strconv.ParseInt(path[1], 0, 0)
				if err65 != nil {
					return err65
				}
				i = int(t65)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "IntSlicePtr" {
			x0 := x.IntSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t66, err66 := strconv.ParseInt(path[1], 0, 0)
				if err66 != nil {
					return err66
				}
				i = int(t66)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					var rightExact int32
					t67, err67 := strconv.ParseInt(right, 0, 0)
					if err67 != nil {
						return err67
					}
					rightExact = int32(t67)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "IntPtrSlicePtr" {
			x0 := x.IntPtrSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t68, err68 := strconv.ParseInt(path[1], 0, 0)
				if err68 != nil {
					return err68
				}
				i = int(t68)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "ByteSlice" {
			var rightExact []byte
			rightExact = fastconv.S2B(right)

			if cond == inspector.OpEq {
				*result = bytes.Equal(x.ByteSlice, rightExact)
			} else {
				*result = !bytes.Equal(x.ByteSlice, rightExact)
			}
			return
		}
		if path[0] == "BytePtrSlice" {
			x0 := x.BytePtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t70, err70 := strconv.ParseInt(path[1], 0, 0)
				if err70 != nil {
					return err70
				}
				i = int(t70)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "ByteSlicePtr" {
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x.ByteSlicePtr == nil
				} else {
					*result = x.ByteSlicePtr != nil
				}
				return
			}
			return
		}
		if path[0] == "BytePtrSlicePtr" {
			x0 := x.BytePtrSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t71, err71 := strconv.ParseInt(path[1], 0, 0)
				if err71 != nil {
					return err71
				}
				i = int(t71)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "FloatSlice" {
			x0 := x.FloatSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t72, err72 := strconv.ParseInt(path[1], 0, 0)
				if err72 != nil {
					return err72
				}
				i = int(t72)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					var rightExact float32
					t73, err73 := strconv.ParseFloat(right, 0)
					if err73 != nil {
						return err73
					}
					rightExact = float32(t73)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "FloatPtrSlice" {
			x0 := x.FloatPtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t74, err74 := strconv.ParseInt(path[1], 0, 0)
				if err74 != nil {
					return err74
				}
				i = int(t74)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "FloatSlicePtr" {
			x0 := x.FloatSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t75, err75 := strconv.ParseInt(path[1], 0, 0)
				if err75 != nil {
					return err75
				}
				i = int(t75)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					var rightExact float32
					t76, err76 := strconv.ParseFloat(right, 0)
					if err76 != nil {
						return err76
					}
					rightExact = float32(t76)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "FloatPtrSlicePtr" {
			x0 := x.FloatPtrSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t77, err77 := strconv.ParseInt(path[1], 0, 0)
				if err77 != nil {
					return err77
				}
				i = int(t77)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "StructSlice" {
			x0 := x.StructSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t78, err78 := strconv.ParseInt(path[1], 0, 0)
				if err78 != nil {
					return err78
				}
				i = int(t78)
				if len(x0) > i {
					x1 := &(x0)[i]
					_ = x1
					if len(path) > 2 {
						if path[2] == "A" {
							var rightExact byte
							t79 := fastconv.S2B(right)
							if len(t79) > 0 {
								rightExact = t79[0]
							}

							switch cond {
							case inspector.OpEq:
								*result = x1.A == rightExact
							case inspector.OpNq:
								*result = x1.A != rightExact
							case inspector.OpGt:
								*result = x1.A > rightExact
							case inspector.OpGtq:
								*result = x1.A >= rightExact
							case inspector.OpLt:
								*result = x1.A < rightExact
							case inspector.OpLtq:
								*result = x1.A <= rightExact
							}
							return
						}
						if path[2] == "S" {
							var rightExact string
							rightExact = right

							switch cond {
							case inspector.OpEq:
								*result = x1.S == rightExact
							case inspector.OpNq:
								*result = x1.S != rightExact
							case inspector.OpGt:
								*result = x1.S > rightExact
							case inspector.OpGtq:
								*result = x1.S >= rightExact
							case inspector.OpLt:
								*result = x1.S < rightExact
							case inspector.OpLtq:
								*result = x1.S <= rightExact
							}
							return
						}
						if path[2] == "B" {
							var rightExact []byte
							rightExact = fastconv.S2B(right)

							if cond == inspector.OpEq {
								*result = bytes.Equal(x1.B, rightExact)
							} else {
								*result = !bytes.Equal(x1.B, rightExact)
							}
							return
						}
						if path[2] == "I" {
							var rightExact int
							t82, err82 := strconv.ParseInt(right, 0, 0)
							if err82 != nil {
								return err82
							}
							rightExact = int(t82)
							switch cond {
							case inspector.OpEq:
								*result = x1.I == rightExact
							case inspector.OpNq:
								*result = x1.I != rightExact
							case inspector.OpGt:
								*result = x1.I > rightExact
							case inspector.OpGtq:
								*result = x1.I >= rightExact
							case inspector.OpLt:
								*result = x1.I < rightExact
							case inspector.OpLtq:
								*result = x1.I <= rightExact
							}
							return
						}
						if path[2] == "I8" {
							var rightExact int8
							t83, err83 := strconv.ParseInt(right, 0, 0)
							if err83 != nil {
								return err83
							}
							rightExact = int8(t83)
							switch cond {
							case inspector.OpEq:
								*result = x1.I8 == rightExact
							case inspector.OpNq:
								*result = x1.I8 != rightExact
							case inspector.OpGt:
								*result = x1.I8 > rightExact
							case inspector.OpGtq:
								*result = x1.I8 >= rightExact
							case inspector.OpLt:
								*result = x1.I8 < rightExact
							case inspector.OpLtq:
								*result = x1.I8 <= rightExact
							}
							return
						}
						if path[2] == "I16" {
							var rightExact int16
							t84, err84 := strconv.ParseInt(right, 0, 0)
							if err84 != nil {
								return err84
							}
							rightExact = int16(t84)
							switch cond {
							case inspector.OpEq:
								*result = x1.I16 == rightExact
							case inspector.OpNq:
								*result = x1.I16 != rightExact
							case inspector.OpGt:
								*result = x1.I16 > rightExact
							case inspector.OpGtq:
								*result = x1.I16 >= rightExact
							case inspector.OpLt:
								*result = x1.I16 < rightExact
							case inspector.OpLtq:
								*result = x1.I16 <= rightExact
							}
							return
						}
						if path[2] == "I32" {
							var rightExact int32
							t85, err85 := strconv.ParseInt(right, 0, 0)
							if err85 != nil {
								return err85
							}
							rightExact = int32(t85)
							switch cond {
							case inspector.OpEq:
								*result = x1.I32 == rightExact
							case inspector.OpNq:
								*result = x1.I32 != rightExact
							case inspector.OpGt:
								*result = x1.I32 > rightExact
							case inspector.OpGtq:
								*result = x1.I32 >= rightExact
							case inspector.OpLt:
								*result = x1.I32 < rightExact
							case inspector.OpLtq:
								*result = x1.I32 <= rightExact
							}
							return
						}
						if path[2] == "I64" {
							var rightExact int64
							t86, err86 := strconv.ParseInt(right, 0, 0)
							if err86 != nil {
								return err86
							}
							rightExact = int64(t86)
							switch cond {
							case inspector.OpEq:
								*result = x1.I64 == rightExact
							case inspector.OpNq:
								*result = x1.I64 != rightExact
							case inspector.OpGt:
								*result = x1.I64 > rightExact
							case inspector.OpGtq:
								*result = x1.I64 >= rightExact
							case inspector.OpLt:
								*result = x1.I64 < rightExact
							case inspector.OpLtq:
								*result = x1.I64 <= rightExact
							}
							return
						}
						if path[2] == "U" {
							var rightExact uint
							t87, err87 := strconv.ParseUint(right, 0, 0)
							if err87 != nil {
								return err87
							}
							rightExact = uint(t87)
							switch cond {
							case inspector.OpEq:
								*result = x1.U == rightExact
							case inspector.OpNq:
								*result = x1.U != rightExact
							case inspector.OpGt:
								*result = x1.U > rightExact
							case inspector.OpGtq:
								*result = x1.U >= rightExact
							case inspector.OpLt:
								*result = x1.U < rightExact
							case inspector.OpLtq:
								*result = x1.U <= rightExact
							}
							return
						}
						if path[2] == "U8" {
							var rightExact uint8
							t88, err88 := strconv.ParseUint(right, 0, 0)
							if err88 != nil {
								return err88
							}
							rightExact = uint8(t88)
							switch cond {
							case inspector.OpEq:
								*result = x1.U8 == rightExact
							case inspector.OpNq:
								*result = x1.U8 != rightExact
							case inspector.OpGt:
								*result = x1.U8 > rightExact
							case inspector.OpGtq:
								*result = x1.U8 >= rightExact
							case inspector.OpLt:
								*result = x1.U8 < rightExact
							case inspector.OpLtq:
								*result = x1.U8 <= rightExact
							}
							return
						}
						if path[2] == "U16" {
							var rightExact uint16
							t89, err89 := strconv.ParseUint(right, 0, 0)
							if err89 != nil {
								return err89
							}
							rightExact = uint16(t89)
							switch cond {
							case inspector.OpEq:
								*result = x1.U16 == rightExact
							case inspector.OpNq:
								*result = x1.U16 != rightExact
							case inspector.OpGt:
								*result = x1.U16 > rightExact
							case inspector.OpGtq:
								*result = x1.U16 >= rightExact
							case inspector.OpLt:
								*result = x1.U16 < rightExact
							case inspector.OpLtq:
								*result = x1.U16 <= rightExact
							}
							return
						}
						if path[2] == "U32" {
							var rightExact uint32
							t90, err90 := strconv.ParseUint(right, 0, 0)
							if err90 != nil {
								return err90
							}
							rightExact = uint32(t90)
							switch cond {
							case inspector.OpEq:
								*result = x1.U32 == rightExact
							case inspector.OpNq:
								*result = x1.U32 != rightExact
							case inspector.OpGt:
								*result = x1.U32 > rightExact
							case inspector.OpGtq:
								*result = x1.U32 >= rightExact
							case inspector.OpLt:
								*result = x1.U32 < rightExact
							case inspector.OpLtq:
								*result = x1.U32 <= rightExact
							}
							return
						}
						if path[2] == "U64" {
							var rightExact uint64
							t91, err91 := strconv.ParseUint(right, 0, 0)
							if err91 != nil {
								return err91
							}
							rightExact = uint64(t91)
							switch cond {
							case inspector.OpEq:
								*result = x1.U64 == rightExact
							case inspector.OpNq:
								*result = x1.U64 != rightExact
							case inspector.OpGt:
								*result = x1.U64 > rightExact
							case inspector.OpGtq:
								*result = x1.U64 >= rightExact
							case inspector.OpLt:
								*result = x1.U64 < rightExact
							case inspector.OpLtq:
								*result = x1.U64 <= rightExact
							}
							return
						}
						if path[2] == "F" {
							var rightExact float32
							t92, err92 := strconv.ParseFloat(right, 0)
							if err92 != nil {
								return err92
							}
							rightExact = float32(t92)
							switch cond {
							case inspector.OpEq:
								*result = x1.F == rightExact
							case inspector.OpNq:
								*result = x1.F != rightExact
							case inspector.OpGt:
								*result = x1.F > rightExact
							case inspector.OpGtq:
								*result = x1.F >= rightExact
							case inspector.OpLt:
								*result = x1.F < rightExact
							case inspector.OpLtq:
								*result = x1.F <= rightExact
							}
							return
						}
						if path[2] == "D" {
							var rightExact float64
							t93, err93 := strconv.ParseFloat(right, 0)
							if err93 != nil {
								return err93
							}
							rightExact = float64(t93)
							switch cond {
							case inspector.OpEq:
								*result = x1.D == rightExact
							case inspector.OpNq:
								*result = x1.D != rightExact
							case inspector.OpGt:
								*result = x1.D > rightExact
							case inspector.OpGtq:
								*result = x1.D >= rightExact
							case inspector.OpLt:
								*result = x1.D < rightExact
							case inspector.OpLtq:
								*result = x1.D <= rightExact
							}
							return
						}
					}
				}
			}
		}
		if path[0] == "StructPtrSlice" {
			x0 := x.StructPtrSlice
			_ = x0
			if len(path) > 1 {
				var i int
				t94, err94 := strconv.ParseInt(path[1], 0, 0)
				if err94 != nil {
					return err94
				}
				i = int(t94)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return
						}
						if path[2] == "A" {
							var rightExact byte
							t95 := fastconv.S2B(right)
							if len(t95) > 0 {
								rightExact = t95[0]
							}

							switch cond {
							case inspector.OpEq:
								*result = x1.A == rightExact
							case inspector.OpNq:
								*result = x1.A != rightExact
							case inspector.OpGt:
								*result = x1.A > rightExact
							case inspector.OpGtq:
								*result = x1.A >= rightExact
							case inspector.OpLt:
								*result = x1.A < rightExact
							case inspector.OpLtq:
								*result = x1.A <= rightExact
							}
							return
						}
						if path[2] == "S" {
							var rightExact string
							rightExact = right

							switch cond {
							case inspector.OpEq:
								*result = x1.S == rightExact
							case inspector.OpNq:
								*result = x1.S != rightExact
							case inspector.OpGt:
								*result = x1.S > rightExact
							case inspector.OpGtq:
								*result = x1.S >= rightExact
							case inspector.OpLt:
								*result = x1.S < rightExact
							case inspector.OpLtq:
								*result = x1.S <= rightExact
							}
							return
						}
						if path[2] == "B" {
							var rightExact []byte
							rightExact = fastconv.S2B(right)

							if cond == inspector.OpEq {
								*result = bytes.Equal(x1.B, rightExact)
							} else {
								*result = !bytes.Equal(x1.B, rightExact)
							}
							return
						}
						if path[2] == "I" {
							var rightExact int
							t98, err98 := strconv.ParseInt(right, 0, 0)
							if err98 != nil {
								return err98
							}
							rightExact = int(t98)
							switch cond {
							case inspector.OpEq:
								*result = x1.I == rightExact
							case inspector.OpNq:
								*result = x1.I != rightExact
							case inspector.OpGt:
								*result = x1.I > rightExact
							case inspector.OpGtq:
								*result = x1.I >= rightExact
							case inspector.OpLt:
								*result = x1.I < rightExact
							case inspector.OpLtq:
								*result = x1.I <= rightExact
							}
							return
						}
						if path[2] == "I8" {
							var rightExact int8
							t99, err99 := strconv.ParseInt(right, 0, 0)
							if err99 != nil {
								return err99
							}
							rightExact = int8(t99)
							switch cond {
							case inspector.OpEq:
								*result = x1.I8 == rightExact
							case inspector.OpNq:
								*result = x1.I8 != rightExact
							case inspector.OpGt:
								*result = x1.I8 > rightExact
							case inspector.OpGtq:
								*result = x1.I8 >= rightExact
							case inspector.OpLt:
								*result = x1.I8 < rightExact
							case inspector.OpLtq:
								*result = x1.I8 <= rightExact
							}
							return
						}
						if path[2] == "I16" {
							var rightExact int16
							t100, err100 := strconv.ParseInt(right, 0, 0)
							if err100 != nil {
								return err100
							}
							rightExact = int16(t100)
							switch cond {
							case inspector.OpEq:
								*result = x1.I16 == rightExact
							case inspector.OpNq:
								*result = x1.I16 != rightExact
							case inspector.OpGt:
								*result = x1.I16 > rightExact
							case inspector.OpGtq:
								*result = x1.I16 >= rightExact
							case inspector.OpLt:
								*result = x1.I16 < rightExact
							case inspector.OpLtq:
								*result = x1.I16 <= rightExact
							}
							return
						}
						if path[2] == "I32" {
							var rightExact int32
							t101, err101 := strconv.ParseInt(right, 0, 0)
							if err101 != nil {
								return err101
							}
							rightExact = int32(t101)
							switch cond {
							case inspector.OpEq:
								*result = x1.I32 == rightExact
							case inspector.OpNq:
								*result = x1.I32 != rightExact
							case inspector.OpGt:
								*result = x1.I32 > rightExact
							case inspector.OpGtq:
								*result = x1.I32 >= rightExact
							case inspector.OpLt:
								*result = x1.I32 < rightExact
							case inspector.OpLtq:
								*result = x1.I32 <= rightExact
							}
							return
						}
						if path[2] == "I64" {
							var rightExact int64
							t102, err102 := strconv.ParseInt(right, 0, 0)
							if err102 != nil {
								return err102
							}
							rightExact = int64(t102)
							switch cond {
							case inspector.OpEq:
								*result = x1.I64 == rightExact
							case inspector.OpNq:
								*result = x1.I64 != rightExact
							case inspector.OpGt:
								*result = x1.I64 > rightExact
							case inspector.OpGtq:
								*result = x1.I64 >= rightExact
							case inspector.OpLt:
								*result = x1.I64 < rightExact
							case inspector.OpLtq:
								*result = x1.I64 <= rightExact
							}
							return
						}
						if path[2] == "U" {
							var rightExact uint
							t103, err103 := strconv.ParseUint(right, 0, 0)
							if err103 != nil {
								return err103
							}
							rightExact = uint(t103)
							switch cond {
							case inspector.OpEq:
								*result = x1.U == rightExact
							case inspector.OpNq:
								*result = x1.U != rightExact
							case inspector.OpGt:
								*result = x1.U > rightExact
							case inspector.OpGtq:
								*result = x1.U >= rightExact
							case inspector.OpLt:
								*result = x1.U < rightExact
							case inspector.OpLtq:
								*result = x1.U <= rightExact
							}
							return
						}
						if path[2] == "U8" {
							var rightExact uint8
							t104, err104 := strconv.ParseUint(right, 0, 0)
							if err104 != nil {
								return err104
							}
							rightExact = uint8(t104)
							switch cond {
							case inspector.OpEq:
								*result = x1.U8 == rightExact
							case inspector.OpNq:
								*result = x1.U8 != rightExact
							case inspector.OpGt:
								*result = x1.U8 > rightExact
							case inspector.OpGtq:
								*result = x1.U8 >= rightExact
							case inspector.OpLt:
								*result = x1.U8 < rightExact
							case inspector.OpLtq:
								*result = x1.U8 <= rightExact
							}
							return
						}
						if path[2] == "U16" {
							var rightExact uint16
							t105, err105 := strconv.ParseUint(right, 0, 0)
							if err105 != nil {
								return err105
							}
							rightExact = uint16(t105)
							switch cond {
							case inspector.OpEq:
								*result = x1.U16 == rightExact
							case inspector.OpNq:
								*result = x1.U16 != rightExact
							case inspector.OpGt:
								*result = x1.U16 > rightExact
							case inspector.OpGtq:
								*result = x1.U16 >= rightExact
							case inspector.OpLt:
								*result = x1.U16 < rightExact
							case inspector.OpLtq:
								*result = x1.U16 <= rightExact
							}
							return
						}
						if path[2] == "U32" {
							var rightExact uint32
							t106, err106 := strconv.ParseUint(right, 0, 0)
							if err106 != nil {
								return err106
							}
							rightExact = uint32(t106)
							switch cond {
							case inspector.OpEq:
								*result = x1.U32 == rightExact
							case inspector.OpNq:
								*result = x1.U32 != rightExact
							case inspector.OpGt:
								*result = x1.U32 > rightExact
							case inspector.OpGtq:
								*result = x1.U32 >= rightExact
							case inspector.OpLt:
								*result = x1.U32 < rightExact
							case inspector.OpLtq:
								*result = x1.U32 <= rightExact
							}
							return
						}
						if path[2] == "U64" {
							var rightExact uint64
							t107, err107 := strconv.ParseUint(right, 0, 0)
							if err107 != nil {
								return err107
							}
							rightExact = uint64(t107)
							switch cond {
							case inspector.OpEq:
								*result = x1.U64 == rightExact
							case inspector.OpNq:
								*result = x1.U64 != rightExact
							case inspector.OpGt:
								*result = x1.U64 > rightExact
							case inspector.OpGtq:
								*result = x1.U64 >= rightExact
							case inspector.OpLt:
								*result = x1.U64 < rightExact
							case inspector.OpLtq:
								*result = x1.U64 <= rightExact
							}
							return
						}
						if path[2] == "F" {
							var rightExact float32
							t108, err108 := strconv.ParseFloat(right, 0)
							if err108 != nil {
								return err108
							}
							rightExact = float32(t108)
							switch cond {
							case inspector.OpEq:
								*result = x1.F == rightExact
							case inspector.OpNq:
								*result = x1.F != rightExact
							case inspector.OpGt:
								*result = x1.F > rightExact
							case inspector.OpGtq:
								*result = x1.F >= rightExact
							case inspector.OpLt:
								*result = x1.F < rightExact
							case inspector.OpLtq:
								*result = x1.F <= rightExact
							}
							return
						}
						if path[2] == "D" {
							var rightExact float64
							t109, err109 := strconv.ParseFloat(right, 0)
							if err109 != nil {
								return err109
							}
							rightExact = float64(t109)
							switch cond {
							case inspector.OpEq:
								*result = x1.D == rightExact
							case inspector.OpNq:
								*result = x1.D != rightExact
							case inspector.OpGt:
								*result = x1.D > rightExact
							case inspector.OpGtq:
								*result = x1.D >= rightExact
							case inspector.OpLt:
								*result = x1.D < rightExact
							case inspector.OpLtq:
								*result = x1.D <= rightExact
							}
							return
						}
					}
				}
			}
		}
		if path[0] == "StructSlicePtr" {
			x0 := x.StructSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t110, err110 := strconv.ParseInt(path[1], 0, 0)
				if err110 != nil {
					return err110
				}
				i = int(t110)
				if len(*x0) > i {
					x1 := &(*x0)[i]
					_ = x1
					if len(path) > 2 {
						if path[2] == "A" {
							var rightExact byte
							t111 := fastconv.S2B(right)
							if len(t111) > 0 {
								rightExact = t111[0]
							}

							switch cond {
							case inspector.OpEq:
								*result = x1.A == rightExact
							case inspector.OpNq:
								*result = x1.A != rightExact
							case inspector.OpGt:
								*result = x1.A > rightExact
							case inspector.OpGtq:
								*result = x1.A >= rightExact
							case inspector.OpLt:
								*result = x1.A < rightExact
							case inspector.OpLtq:
								*result = x1.A <= rightExact
							}
							return
						}
						if path[2] == "S" {
							var rightExact string
							rightExact = right

							switch cond {
							case inspector.OpEq:
								*result = x1.S == rightExact
							case inspector.OpNq:
								*result = x1.S != rightExact
							case inspector.OpGt:
								*result = x1.S > rightExact
							case inspector.OpGtq:
								*result = x1.S >= rightExact
							case inspector.OpLt:
								*result = x1.S < rightExact
							case inspector.OpLtq:
								*result = x1.S <= rightExact
							}
							return
						}
						if path[2] == "B" {
							var rightExact []byte
							rightExact = fastconv.S2B(right)

							if cond == inspector.OpEq {
								*result = bytes.Equal(x1.B, rightExact)
							} else {
								*result = !bytes.Equal(x1.B, rightExact)
							}
							return
						}
						if path[2] == "I" {
							var rightExact int
							t114, err114 := strconv.ParseInt(right, 0, 0)
							if err114 != nil {
								return err114
							}
							rightExact = int(t114)
							switch cond {
							case inspector.OpEq:
								*result = x1.I == rightExact
							case inspector.OpNq:
								*result = x1.I != rightExact
							case inspector.OpGt:
								*result = x1.I > rightExact
							case inspector.OpGtq:
								*result = x1.I >= rightExact
							case inspector.OpLt:
								*result = x1.I < rightExact
							case inspector.OpLtq:
								*result = x1.I <= rightExact
							}
							return
						}
						if path[2] == "I8" {
							var rightExact int8
							t115, err115 := strconv.ParseInt(right, 0, 0)
							if err115 != nil {
								return err115
							}
							rightExact = int8(t115)
							switch cond {
							case inspector.OpEq:
								*result = x1.I8 == rightExact
							case inspector.OpNq:
								*result = x1.I8 != rightExact
							case inspector.OpGt:
								*result = x1.I8 > rightExact
							case inspector.OpGtq:
								*result = x1.I8 >= rightExact
							case inspector.OpLt:
								*result = x1.I8 < rightExact
							case inspector.OpLtq:
								*result = x1.I8 <= rightExact
							}
							return
						}
						if path[2] == "I16" {
							var rightExact int16
							t116, err116 := strconv.ParseInt(right, 0, 0)
							if err116 != nil {
								return err116
							}
							rightExact = int16(t116)
							switch cond {
							case inspector.OpEq:
								*result = x1.I16 == rightExact
							case inspector.OpNq:
								*result = x1.I16 != rightExact
							case inspector.OpGt:
								*result = x1.I16 > rightExact
							case inspector.OpGtq:
								*result = x1.I16 >= rightExact
							case inspector.OpLt:
								*result = x1.I16 < rightExact
							case inspector.OpLtq:
								*result = x1.I16 <= rightExact
							}
							return
						}
						if path[2] == "I32" {
							var rightExact int32
							t117, err117 := strconv.ParseInt(right, 0, 0)
							if err117 != nil {
								return err117
							}
							rightExact = int32(t117)
							switch cond {
							case inspector.OpEq:
								*result = x1.I32 == rightExact
							case inspector.OpNq:
								*result = x1.I32 != rightExact
							case inspector.OpGt:
								*result = x1.I32 > rightExact
							case inspector.OpGtq:
								*result = x1.I32 >= rightExact
							case inspector.OpLt:
								*result = x1.I32 < rightExact
							case inspector.OpLtq:
								*result = x1.I32 <= rightExact
							}
							return
						}
						if path[2] == "I64" {
							var rightExact int64
							t118, err118 := strconv.ParseInt(right, 0, 0)
							if err118 != nil {
								return err118
							}
							rightExact = int64(t118)
							switch cond {
							case inspector.OpEq:
								*result = x1.I64 == rightExact
							case inspector.OpNq:
								*result = x1.I64 != rightExact
							case inspector.OpGt:
								*result = x1.I64 > rightExact
							case inspector.OpGtq:
								*result = x1.I64 >= rightExact
							case inspector.OpLt:
								*result = x1.I64 < rightExact
							case inspector.OpLtq:
								*result = x1.I64 <= rightExact
							}
							return
						}
						if path[2] == "U" {
							var rightExact uint
							t119, err119 := strconv.ParseUint(right, 0, 0)
							if err119 != nil {
								return err119
							}
							rightExact = uint(t119)
							switch cond {
							case inspector.OpEq:
								*result = x1.U == rightExact
							case inspector.OpNq:
								*result = x1.U != rightExact
							case inspector.OpGt:
								*result = x1.U > rightExact
							case inspector.OpGtq:
								*result = x1.U >= rightExact
							case inspector.OpLt:
								*result = x1.U < rightExact
							case inspector.OpLtq:
								*result = x1.U <= rightExact
							}
							return
						}
						if path[2] == "U8" {
							var rightExact uint8
							t120, err120 := strconv.ParseUint(right, 0, 0)
							if err120 != nil {
								return err120
							}
							rightExact = uint8(t120)
							switch cond {
							case inspector.OpEq:
								*result = x1.U8 == rightExact
							case inspector.OpNq:
								*result = x1.U8 != rightExact
							case inspector.OpGt:
								*result = x1.U8 > rightExact
							case inspector.OpGtq:
								*result = x1.U8 >= rightExact
							case inspector.OpLt:
								*result = x1.U8 < rightExact
							case inspector.OpLtq:
								*result = x1.U8 <= rightExact
							}
							return
						}
						if path[2] == "U16" {
							var rightExact uint16
							t121, err121 := strconv.ParseUint(right, 0, 0)
							if err121 != nil {
								return err121
							}
							rightExact = uint16(t121)
							switch cond {
							case inspector.OpEq:
								*result = x1.U16 == rightExact
							case inspector.OpNq:
								*result = x1.U16 != rightExact
							case inspector.OpGt:
								*result = x1.U16 > rightExact
							case inspector.OpGtq:
								*result = x1.U16 >= rightExact
							case inspector.OpLt:
								*result = x1.U16 < rightExact
							case inspector.OpLtq:
								*result = x1.U16 <= rightExact
							}
							return
						}
						if path[2] == "U32" {
							var rightExact uint32
							t122, err122 := strconv.ParseUint(right, 0, 0)
							if err122 != nil {
								return err122
							}
							rightExact = uint32(t122)
							switch cond {
							case inspector.OpEq:
								*result = x1.U32 == rightExact
							case inspector.OpNq:
								*result = x1.U32 != rightExact
							case inspector.OpGt:
								*result = x1.U32 > rightExact
							case inspector.OpGtq:
								*result = x1.U32 >= rightExact
							case inspector.OpLt:
								*result = x1.U32 < rightExact
							case inspector.OpLtq:
								*result = x1.U32 <= rightExact
							}
							return
						}
						if path[2] == "U64" {
							var rightExact uint64
							t123, err123 := strconv.ParseUint(right, 0, 0)
							if err123 != nil {
								return err123
							}
							rightExact = uint64(t123)
							switch cond {
							case inspector.OpEq:
								*result = x1.U64 == rightExact
							case inspector.OpNq:
								*result = x1.U64 != rightExact
							case inspector.OpGt:
								*result = x1.U64 > rightExact
							case inspector.OpGtq:
								*result = x1.U64 >= rightExact
							case inspector.OpLt:
								*result = x1.U64 < rightExact
							case inspector.OpLtq:
								*result = x1.U64 <= rightExact
							}
							return
						}
						if path[2] == "F" {
							var rightExact float32
							t124, err124 := strconv.ParseFloat(right, 0)
							if err124 != nil {
								return err124
							}
							rightExact = float32(t124)
							switch cond {
							case inspector.OpEq:
								*result = x1.F == rightExact
							case inspector.OpNq:
								*result = x1.F != rightExact
							case inspector.OpGt:
								*result = x1.F > rightExact
							case inspector.OpGtq:
								*result = x1.F >= rightExact
							case inspector.OpLt:
								*result = x1.F < rightExact
							case inspector.OpLtq:
								*result = x1.F <= rightExact
							}
							return
						}
						if path[2] == "D" {
							var rightExact float64
							t125, err125 := strconv.ParseFloat(right, 0)
							if err125 != nil {
								return err125
							}
							rightExact = float64(t125)
							switch cond {
							case inspector.OpEq:
								*result = x1.D == rightExact
							case inspector.OpNq:
								*result = x1.D != rightExact
							case inspector.OpGt:
								*result = x1.D > rightExact
							case inspector.OpGtq:
								*result = x1.D >= rightExact
							case inspector.OpLt:
								*result = x1.D < rightExact
							case inspector.OpLtq:
								*result = x1.D <= rightExact
							}
							return
						}
					}
				}
			}
		}
		if path[0] == "StructPtrSlicePtr" {
			x0 := x.StructPtrSlicePtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var i int
				t126, err126 := strconv.ParseInt(path[1], 0, 0)
				if err126 != nil {
					return err126
				}
				i = int(t126)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return
						}
						if path[2] == "A" {
							var rightExact byte
							t127 := fastconv.S2B(right)
							if len(t127) > 0 {
								rightExact = t127[0]
							}

							switch cond {
							case inspector.OpEq:
								*result = x1.A == rightExact
							case inspector.OpNq:
								*result = x1.A != rightExact
							case inspector.OpGt:
								*result = x1.A > rightExact
							case inspector.OpGtq:
								*result = x1.A >= rightExact
							case inspector.OpLt:
								*result = x1.A < rightExact
							case inspector.OpLtq:
								*result = x1.A <= rightExact
							}
							return
						}
						if path[2] == "S" {
							var rightExact string
							rightExact = right

							switch cond {
							case inspector.OpEq:
								*result = x1.S == rightExact
							case inspector.OpNq:
								*result = x1.S != rightExact
							case inspector.OpGt:
								*result = x1.S > rightExact
							case inspector.OpGtq:
								*result = x1.S >= rightExact
							case inspector.OpLt:
								*result = x1.S < rightExact
							case inspector.OpLtq:
								*result = x1.S <= rightExact
							}
							return
						}
						if path[2] == "B" {
							var rightExact []byte
							rightExact = fastconv.S2B(right)

							if cond == inspector.OpEq {
								*result = bytes.Equal(x1.B, rightExact)
							} else {
								*result = !bytes.Equal(x1.B, rightExact)
							}
							return
						}
						if path[2] == "I" {
							var rightExact int
							t130, err130 := strconv.ParseInt(right, 0, 0)
							if err130 != nil {
								return err130
							}
							rightExact = int(t130)
							switch cond {
							case inspector.OpEq:
								*result = x1.I == rightExact
							case inspector.OpNq:
								*result = x1.I != rightExact
							case inspector.OpGt:
								*result = x1.I > rightExact
							case inspector.OpGtq:
								*result = x1.I >= rightExact
							case inspector.OpLt:
								*result = x1.I < rightExact
							case inspector.OpLtq:
								*result = x1.I <= rightExact
							}
							return
						}
						if path[2] == "I8" {
							var rightExact int8
							t131, err131 := strconv.ParseInt(right, 0, 0)
							if err131 != nil {
								return err131
							}
							rightExact = int8(t131)
							switch cond {
							case inspector.OpEq:
								*result = x1.I8 == rightExact
							case inspector.OpNq:
								*result = x1.I8 != rightExact
							case inspector.OpGt:
								*result = x1.I8 > rightExact
							case inspector.OpGtq:
								*result = x1.I8 >= rightExact
							case inspector.OpLt:
								*result = x1.I8 < rightExact
							case inspector.OpLtq:
								*result = x1.I8 <= rightExact
							}
							return
						}
						if path[2] == "I16" {
							var rightExact int16
							t132, err132 := strconv.ParseInt(right, 0, 0)
							if err132 != nil {
								return err132
							}
							rightExact = int16(t132)
							switch cond {
							case inspector.OpEq:
								*result = x1.I16 == rightExact
							case inspector.OpNq:
								*result = x1.I16 != rightExact
							case inspector.OpGt:
								*result = x1.I16 > rightExact
							case inspector.OpGtq:
								*result = x1.I16 >= rightExact
							case inspector.OpLt:
								*result = x1.I16 < rightExact
							case inspector.OpLtq:
								*result = x1.I16 <= rightExact
							}
							return
						}
						if path[2] == "I32" {
							var rightExact int32
							t133, err133 := strconv.ParseInt(right, 0, 0)
							if err133 != nil {
								return err133
							}
							rightExact = int32(t133)
							switch cond {
							case inspector.OpEq:
								*result = x1.I32 == rightExact
							case inspector.OpNq:
								*result = x1.I32 != rightExact
							case inspector.OpGt:
								*result = x1.I32 > rightExact
							case inspector.OpGtq:
								*result = x1.I32 >= rightExact
							case inspector.OpLt:
								*result = x1.I32 < rightExact
							case inspector.OpLtq:
								*result = x1.I32 <= rightExact
							}
							return
						}
						if path[2] == "I64" {
							var rightExact int64
							t134, err134 := strconv.ParseInt(right, 0, 0)
							if err134 != nil {
								return err134
							}
							rightExact = int64(t134)
							switch cond {
							case inspector.OpEq:
								*result = x1.I64 == rightExact
							case inspector.OpNq:
								*result = x1.I64 != rightExact
							case inspector.OpGt:
								*result = x1.I64 > rightExact
							case inspector.OpGtq:
								*result = x1.I64 >= rightExact
							case inspector.OpLt:
								*result = x1.I64 < rightExact
							case inspector.OpLtq:
								*result = x1.I64 <= rightExact
							}
							return
						}
						if path[2] == "U" {
							var rightExact uint
							t135, err135 := strconv.ParseUint(right, 0, 0)
							if err135 != nil {
								return err135
							}
							rightExact = uint(t135)
							switch cond {
							case inspector.OpEq:
								*result = x1.U == rightExact
							case inspector.OpNq:
								*result = x1.U != rightExact
							case inspector.OpGt:
								*result = x1.U > rightExact
							case inspector.OpGtq:
								*result = x1.U >= rightExact
							case inspector.OpLt:
								*result = x1.U < rightExact
							case inspector.OpLtq:
								*result = x1.U <= rightExact
							}
							return
						}
						if path[2] == "U8" {
							var rightExact uint8
							t136, err136 := strconv.ParseUint(right, 0, 0)
							if err136 != nil {
								return err136
							}
							rightExact = uint8(t136)
							switch cond {
							case inspector.OpEq:
								*result = x1.U8 == rightExact
							case inspector.OpNq:
								*result = x1.U8 != rightExact
							case inspector.OpGt:
								*result = x1.U8 > rightExact
							case inspector.OpGtq:
								*result = x1.U8 >= rightExact
							case inspector.OpLt:
								*result = x1.U8 < rightExact
							case inspector.OpLtq:
								*result = x1.U8 <= rightExact
							}
							return
						}
						if path[2] == "U16" {
							var rightExact uint16
							t137, err137 := strconv.ParseUint(right, 0, 0)
							if err137 != nil {
								return err137
							}
							rightExact = uint16(t137)
							switch cond {
							case inspector.OpEq:
								*result = x1.U16 == rightExact
							case inspector.OpNq:
								*result = x1.U16 != rightExact
							case inspector.OpGt:
								*result = x1.U16 > rightExact
							case inspector.OpGtq:
								*result = x1.U16 >= rightExact
							case inspector.OpLt:
								*result = x1.U16 < rightExact
							case inspector.OpLtq:
								*result = x1.U16 <= rightExact
							}
							return
						}
						if path[2] == "U32" {
							var rightExact uint32
							t138, err138 := strconv.ParseUint(right, 0, 0)
							if err138 != nil {
								return err138
							}
							rightExact = uint32(t138)
							switch cond {
							case inspector.OpEq:
								*result = x1.U32 == rightExact
							case inspector.OpNq:
								*result = x1.U32 != rightExact
							case inspector.OpGt:
								*result = x1.U32 > rightExact
							case inspector.OpGtq:
								*result = x1.U32 >= rightExact
							case inspector.OpLt:
								*result = x1.U32 < rightExact
							case inspector.OpLtq:
								*result = x1.U32 <= rightExact
							}
							return
						}
						if path[2] == "U64" {
							var rightExact uint64
							t139, err139 := strconv.ParseUint(right, 0, 0)
							if err139 != nil {
								return err139
							}
							rightExact = uint64(t139)
							switch cond {
							case inspector.OpEq:
								*result = x1.U64 == rightExact
							case inspector.OpNq:
								*result = x1.U64 != rightExact
							case inspector.OpGt:
								*result = x1.U64 > rightExact
							case inspector.OpGtq:
								*result = x1.U64 >= rightExact
							case inspector.OpLt:
								*result = x1.U64 < rightExact
							case inspector.OpLtq:
								*result = x1.U64 <= rightExact
							}
							return
						}
						if path[2] == "F" {
							var rightExact float32
							t140, err140 := strconv.ParseFloat(right, 0)
							if err140 != nil {
								return err140
							}
							rightExact = float32(t140)
							switch cond {
							case inspector.OpEq:
								*result = x1.F == rightExact
							case inspector.OpNq:
								*result = x1.F != rightExact
							case inspector.OpGt:
								*result = x1.F > rightExact
							case inspector.OpGtq:
								*result = x1.F >= rightExact
							case inspector.OpLt:
								*result = x1.F < rightExact
							case inspector.OpLtq:
								*result = x1.F <= rightExact
							}
							return
						}
						if path[2] == "D" {
							var rightExact float64
							t141, err141 := strconv.ParseFloat(right, 0)
							if err141 != nil {
								return err141
							}
							rightExact = float64(t141)
							switch cond {
							case inspector.OpEq:
								*result = x1.D == rightExact
							case inspector.OpNq:
								*result = x1.D != rightExact
							case inspector.OpGt:
								*result = x1.D > rightExact
							case inspector.OpGtq:
								*result = x1.D >= rightExact
							case inspector.OpLt:
								*result = x1.D < rightExact
							case inspector.OpLtq:
								*result = x1.D <= rightExact
							}
							return
						}
					}
				}
			}
		}
		if path[0] == "IntStringMap" {
			x0 := x.IntStringMap
			_ = x0
			if len(path) > 1 {
				var k int
				t142, err142 := strconv.ParseInt(path[1], 0, 0)
				if err142 != nil {
					return err142
				}
				k = int(t142)
				x1 := (x0)[k]
				_ = x1
				var rightExact string
				rightExact = right

				switch cond {
				case inspector.OpEq:
					*result = x1 == rightExact
				case inspector.OpNq:
					*result = x1 != rightExact
				case inspector.OpGt:
					*result = x1 > rightExact
				case inspector.OpGtq:
					*result = x1 >= rightExact
				case inspector.OpLt:
					*result = x1 < rightExact
				case inspector.OpLtq:
					*result = x1 <= rightExact
				}
				return
			}
		}
		if path[0] == "IntStringPtrMap" {
			x0 := x.IntStringPtrMap
			_ = x0
			if len(path) > 1 {
				var k int
				t144, err144 := strconv.ParseInt(path[1], 0, 0)
				if err144 != nil {
					return err144
				}
				k = int(t144)
				x1 := (x0)[k]
				_ = x1
				if x1 == nil {
					return
				}
				if right == inspector.Nil {
					if cond == inspector.OpEq {
						*result = x1 == nil
					} else {
						*result = x1 != nil
					}
					return
				}
				return
			}
		}
		if path[0] == "IntStringMapPtr" {
			x0 := x.IntStringMapPtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var k int
				t145, err145 := strconv.ParseInt(path[1], 0, 0)
				if err145 != nil {
					return err145
				}
				k = int(t145)
				x1 := (*x0)[k]
				_ = x1
				var rightExact string
				rightExact = right

				switch cond {
				case inspector.OpEq:
					*result = x1 == rightExact
				case inspector.OpNq:
					*result = x1 != rightExact
				case inspector.OpGt:
					*result = x1 > rightExact
				case inspector.OpGtq:
					*result = x1 >= rightExact
				case inspector.OpLt:
					*result = x1 < rightExact
				case inspector.OpLtq:
					*result = x1 <= rightExact
				}
				return
			}
		}
		if path[0] == "IntStringPtrMapPtr" {
			x0 := x.IntStringPtrMapPtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var k int
				t147, err147 := strconv.ParseInt(path[1], 0, 0)
				if err147 != nil {
					return err147
				}
				k = int(t147)
				x1 := (*x0)[k]
				_ = x1
				if x1 == nil {
					return
				}
				if right == inspector.Nil {
					if cond == inspector.OpEq {
						*result = x1 == nil
					} else {
						*result = x1 != nil
					}
					return
				}
				return
			}
		}
		if path[0] == "IntPtrStringPtrMapPtr" {
			x0 := x.IntPtrStringPtrMapPtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				var k int
				t148, err148 := strconv.ParseInt(path[1], 0, 0)
				if err148 != nil {
					return err148
				}
				k = int(t148)
				x1 := (*x0)[&k]
				_ = x1
				if x1 == nil {
					return
				}
				if right == inspector.Nil {
					if cond == inspector.OpEq {
						*result = x1 == nil
					} else {
						*result = x1 != nil
					}
					return
				}
				return
			}
		}
		if path[0] == "StringFloatMap" {
			x0 := x.StringFloatMap
			_ = x0
			if len(path) > 1 {
				if x1, ok := (x0)[path[1]]; ok {
					_ = x1
					var rightExact float64
					t149, err149 := strconv.ParseFloat(right, 0)
					if err149 != nil {
						return err149
					}
					rightExact = float64(t149)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "StringFloatPtrMap" {
			x0 := x.StringFloatPtrMap
			_ = x0
			if len(path) > 1 {
				if x1, ok := (x0)[path[1]]; ok {
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "StringFloatMapPtr" {
			x0 := x.StringFloatMapPtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if x1, ok := (*x0)[path[1]]; ok {
					_ = x1
					var rightExact float64
					t150, err150 := strconv.ParseFloat(right, 0)
					if err150 != nil {
						return err150
					}
					rightExact = float64(t150)
					switch cond {
					case inspector.OpEq:
						*result = x1 == rightExact
					case inspector.OpNq:
						*result = x1 != rightExact
					case inspector.OpGt:
						*result = x1 > rightExact
					case inspector.OpGtq:
						*result = x1 >= rightExact
					case inspector.OpLt:
						*result = x1 < rightExact
					case inspector.OpLtq:
						*result = x1 <= rightExact
					}
					return
				}
			}
		}
		if path[0] == "StringFloatPtrMapPtr" {
			x0 := x.StringFloatPtrMapPtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if x1, ok := (*x0)[path[1]]; ok {
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
		if path[0] == "StringPtrFloatPtrMapPtr" {
			x0 := x.StringPtrFloatPtrMapPtr
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if x1, ok := (*x0)[&path[1]]; ok {
					_ = x1
					if x1 == nil {
						return
					}
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					return
				}
			}
		}
	}
	return
}

func (i6 TestObject1Inspector) Loop(src interface{}, l inspector.Looper, buf *[]byte, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *testobj.TestObject1
	_ = x
	if p, ok := src.(**testobj.TestObject1); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestObject1); ok {
		x = p
	} else if v, ok := src.(testobj.TestObject1); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
		if path[0] == "IntSlice" {
			x0 := x.IntSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntPtrSlice" {
			x0 := x.IntPtrSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntSlicePtr" {
			x0 := x.IntSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntPtrSlicePtr" {
			x0 := x.IntPtrSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "BytePtrSlice" {
			x0 := x.BytePtrSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "BytePtrSlicePtr" {
			x0 := x.BytePtrSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatSlice" {
			x0 := x.FloatSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatPtrSlice" {
			x0 := x.FloatPtrSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatSlicePtr" {
			x0 := x.FloatSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "FloatPtrSlicePtr" {
			x0 := x.FloatPtrSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StructSlice" {
			x0 := x.StructSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &TestStructInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StructPtrSlice" {
			x0 := x.StructPtrSlice
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(x0)[k], &TestStructInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StructSlicePtr" {
			x0 := x.StructSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &TestStructInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StructPtrSlicePtr" {
			x0 := x.StructPtrSlicePtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal(&(*x0)[k], &TestStructInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntStringMap" {
			x0 := x.IntStringMap
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntStringPtrMap" {
			x0 := x.IntStringPtrMap
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntStringMapPtr" {
			x0 := x.IntStringMapPtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntStringPtrMapPtr" {
			x0 := x.IntStringPtrMapPtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "IntPtrStringPtrMapPtr" {
			x0 := x.IntPtrStringPtrMapPtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = strconv.AppendInt((*buf)[:0], int64(*k), 10)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StringFloatMap" {
			x0 := x.StringFloatMap
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = append((*buf)[:0], k...)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StringFloatPtrMap" {
			x0 := x.StringFloatPtrMap
			_ = x0
			for k := range x0 {
				if l.RequireKey() {
					*buf = append((*buf)[:0], k...)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StringFloatMapPtr" {
			x0 := x.StringFloatMapPtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = append((*buf)[:0], k...)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StringFloatPtrMapPtr" {
			x0 := x.StringFloatPtrMapPtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = append((*buf)[:0], k...)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
		if path[0] == "StringPtrFloatPtrMapPtr" {
			x0 := x.StringPtrFloatPtrMapPtr
			_ = x0
			if x0 == nil {
				return
			}
			for k := range *x0 {
				if l.RequireKey() {
					*buf = append((*buf)[:0], *k...)
					l.SetKey(buf, &inspector.StaticInspector{})
				}
				l.SetVal((*x0)[k], &inspector.StaticInspector{})
				ctl := l.Iterate()
				if ctl == inspector.LoopCtlBrk {
					break
				}
				if ctl == inspector.LoopCtlCnt {
					continue
				}
			}
			return
		}
	}
	return
}

func (i6 TestObject1Inspector) SetWB(dst, value interface{}, buf inspector.AccumulativeBuffer, path ...string) error {
	if len(path) == 0 {
		return nil
	}
	if dst == nil {
		return nil
	}
	var x *testobj.TestObject1
	_ = x
	if p, ok := dst.(**testobj.TestObject1); ok {
		x = *p
	} else if p, ok := dst.(*testobj.TestObject1); ok {
		x = p
	} else if v, ok := dst.(testobj.TestObject1); ok {
		x = &v
	} else {
		return nil
	}

	if len(path) > 0 {
		if path[0] == "IntSlice" {
			x0 := x.IntSlice
			if uvalue, ok := value.(*[]int32); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make([]int32, 0)
				x0 = z
				x.IntSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t151, err151 := strconv.ParseInt(path[1], 0, 0)
				if err151 != nil {
					return err151
				}
				i = int(t151)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					inspector.AssignBuf(&x1, value, buf)
					return nil
					(x0)[i] = x1
					return nil
				}
			}
			x.IntSlice = x0
		}
		if path[0] == "IntPtrSlice" {
			x0 := x.IntPtrSlice
			if uvalue, ok := value.(*[]*int32); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make([]*int32, 0)
				x0 = z
				x.IntPtrSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t152, err152 := strconv.ParseInt(path[1], 0, 0)
				if err152 != nil {
					return err152
				}
				i = int(t152)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return nil
					}
					inspector.AssignBuf(x1, value, buf)
					return nil
					(x0)[i] = x1
					return nil
				}
			}
			x.IntPtrSlice = x0
		}
		if path[0] == "IntSlicePtr" {
			x0 := x.IntSlicePtr
			if uvalue, ok := value.(*[]int32); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make([]int32, 0)
				x0 = &z
				x.IntSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t153, err153 := strconv.ParseInt(path[1], 0, 0)
				if err153 != nil {
					return err153
				}
				i = int(t153)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					inspector.AssignBuf(&x1, value, buf)
					return nil
					(*x0)[i] = x1
					return nil
				}
			}
			x.IntSlicePtr = x0
		}
		if path[0] == "IntPtrSlicePtr" {
			x0 := x.IntPtrSlicePtr
			if uvalue, ok := value.(*[]*int32); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make([]*int32, 0)
				x0 = &z
				x.IntPtrSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t154, err154 := strconv.ParseInt(path[1], 0, 0)
				if err154 != nil {
					return err154
				}
				i = int(t154)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return nil
					}
					inspector.AssignBuf(x1, value, buf)
					return nil
					(*x0)[i] = x1
					return nil
				}
			}
			x.IntPtrSlicePtr = x0
		}
		if path[0] == "ByteSlice" {
			inspector.AssignBuf(&x.ByteSlice, value, buf)
			return nil
		}
		if path[0] == "BytePtrSlice" {
			x0 := x.BytePtrSlice
			if uvalue, ok := value.(*[]*byte); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make([]*byte, 0)
				x0 = z
				x.BytePtrSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t155, err155 := strconv.ParseInt(path[1], 0, 0)
				if err155 != nil {
					return err155
				}
				i = int(t155)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return nil
					}
					inspector.AssignBuf(x1, value, buf)
					return nil
					(x0)[i] = x1
					return nil
				}
			}
			x.BytePtrSlice = x0
		}
		if path[0] == "ByteSlicePtr" {
			inspector.AssignBuf(x.ByteSlicePtr, value, buf)
			return nil
		}
		if path[0] == "BytePtrSlicePtr" {
			x0 := x.BytePtrSlicePtr
			if uvalue, ok := value.(*[]*byte); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make([]*byte, 0)
				x0 = &z
				x.BytePtrSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t156, err156 := strconv.ParseInt(path[1], 0, 0)
				if err156 != nil {
					return err156
				}
				i = int(t156)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return nil
					}
					inspector.AssignBuf(x1, value, buf)
					return nil
					(*x0)[i] = x1
					return nil
				}
			}
			x.BytePtrSlicePtr = x0
		}
		if path[0] == "FloatSlice" {
			x0 := x.FloatSlice
			if uvalue, ok := value.(*testobj.TestFloatSlice); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(testobj.TestFloatSlice, 0)
				x0 = z
				x.FloatSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t157, err157 := strconv.ParseInt(path[1], 0, 0)
				if err157 != nil {
					return err157
				}
				i = int(t157)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					inspector.AssignBuf(&x1, value, buf)
					return nil
					(x0)[i] = x1
					return nil
				}
			}
			x.FloatSlice = x0
		}
		if path[0] == "FloatPtrSlice" {
			x0 := x.FloatPtrSlice
			if uvalue, ok := value.(*testobj.TestFloatPtrSlice); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(testobj.TestFloatPtrSlice, 0)
				x0 = z
				x.FloatPtrSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t158, err158 := strconv.ParseInt(path[1], 0, 0)
				if err158 != nil {
					return err158
				}
				i = int(t158)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if x1 == nil {
						return nil
					}
					inspector.AssignBuf(x1, value, buf)
					return nil
					(x0)[i] = x1
					return nil
				}
			}
			x.FloatPtrSlice = x0
		}
		if path[0] == "FloatSlicePtr" {
			x0 := x.FloatSlicePtr
			if uvalue, ok := value.(*testobj.TestFloatSlice); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(testobj.TestFloatSlice, 0)
				x0 = &z
				x.FloatSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t159, err159 := strconv.ParseInt(path[1], 0, 0)
				if err159 != nil {
					return err159
				}
				i = int(t159)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					inspector.AssignBuf(&x1, value, buf)
					return nil
					(*x0)[i] = x1
					return nil
				}
			}
			x.FloatSlicePtr = x0
		}
		if path[0] == "FloatPtrSlicePtr" {
			x0 := x.FloatPtrSlicePtr
			if uvalue, ok := value.(*testobj.TestFloatPtrSlice); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(testobj.TestFloatPtrSlice, 0)
				x0 = &z
				x.FloatPtrSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t160, err160 := strconv.ParseInt(path[1], 0, 0)
				if err160 != nil {
					return err160
				}
				i = int(t160)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if x1 == nil {
						return nil
					}
					inspector.AssignBuf(x1, value, buf)
					return nil
					(*x0)[i] = x1
					return nil
				}
			}
			x.FloatPtrSlicePtr = x0
		}
		if path[0] == "StructSlice" {
			x0 := x.StructSlice
			if uvalue, ok := value.(*[]testobj.TestStruct); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make([]testobj.TestStruct, 0)
				x0 = z
				x.StructSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t161, err161 := strconv.ParseInt(path[1], 0, 0)
				if err161 != nil {
					return err161
				}
				i = int(t161)
				if len(x0) > i {
					x1 := &(x0)[i]
					_ = x1
					if len(path) > 2 {
						if path[2] == "A" {
							inspector.AssignBuf(&x1.A, value, buf)
							return nil
						}
						if path[2] == "S" {
							inspector.AssignBuf(&x1.S, value, buf)
							return nil
						}
						if path[2] == "B" {
							inspector.AssignBuf(&x1.B, value, buf)
							return nil
						}
						if path[2] == "I" {
							inspector.AssignBuf(&x1.I, value, buf)
							return nil
						}
						if path[2] == "I8" {
							inspector.AssignBuf(&x1.I8, value, buf)
							return nil
						}
						if path[2] == "I16" {
							inspector.AssignBuf(&x1.I16, value, buf)
							return nil
						}
						if path[2] == "I32" {
							inspector.AssignBuf(&x1.I32, value, buf)
							return nil
						}
						if path[2] == "I64" {
							inspector.AssignBuf(&x1.I64, value, buf)
							return nil
						}
						if path[2] == "U" {
							inspector.AssignBuf(&x1.U, value, buf)
							return nil
						}
						if path[2] == "U8" {
							inspector.AssignBuf(&x1.U8, value, buf)
							return nil
						}
						if path[2] == "U16" {
							inspector.AssignBuf(&x1.U16, value, buf)
							return nil
						}
						if path[2] == "U32" {
							inspector.AssignBuf(&x1.U32, value, buf)
							return nil
						}
						if path[2] == "U64" {
							inspector.AssignBuf(&x1.U64, value, buf)
							return nil
						}
						if path[2] == "F" {
							inspector.AssignBuf(&x1.F, value, buf)
							return nil
						}
						if path[2] == "D" {
							inspector.AssignBuf(&x1.D, value, buf)
							return nil
						}
					}
					(x0)[i] = *x1
					return nil
				}
			}
			x.StructSlice = x0
		}
		if path[0] == "StructPtrSlice" {
			x0 := x.StructPtrSlice
			if uvalue, ok := value.(*[]*testobj.TestStruct); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make([]*testobj.TestStruct, 0)
				x0 = z
				x.StructPtrSlice = x0
			}
			_ = x0
			if len(path) > 1 {
				var i int
				t162, err162 := strconv.ParseInt(path[1], 0, 0)
				if err162 != nil {
					return err162
				}
				i = int(t162)
				if len(x0) > i {
					x1 := (x0)[i]
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return nil
						}
						if path[2] == "A" {
							inspector.AssignBuf(&x1.A, value, buf)
							return nil
						}
						if path[2] == "S" {
							inspector.AssignBuf(&x1.S, value, buf)
							return nil
						}
						if path[2] == "B" {
							inspector.AssignBuf(&x1.B, value, buf)
							return nil
						}
						if path[2] == "I" {
							inspector.AssignBuf(&x1.I, value, buf)
							return nil
						}
						if path[2] == "I8" {
							inspector.AssignBuf(&x1.I8, value, buf)
							return nil
						}
						if path[2] == "I16" {
							inspector.AssignBuf(&x1.I16, value, buf)
							return nil
						}
						if path[2] == "I32" {
							inspector.AssignBuf(&x1.I32, value, buf)
							return nil
						}
						if path[2] == "I64" {
							inspector.AssignBuf(&x1.I64, value, buf)
							return nil
						}
						if path[2] == "U" {
							inspector.AssignBuf(&x1.U, value, buf)
							return nil
						}
						if path[2] == "U8" {
							inspector.AssignBuf(&x1.U8, value, buf)
							return nil
						}
						if path[2] == "U16" {
							inspector.AssignBuf(&x1.U16, value, buf)
							return nil
						}
						if path[2] == "U32" {
							inspector.AssignBuf(&x1.U32, value, buf)
							return nil
						}
						if path[2] == "U64" {
							inspector.AssignBuf(&x1.U64, value, buf)
							return nil
						}
						if path[2] == "F" {
							inspector.AssignBuf(&x1.F, value, buf)
							return nil
						}
						if path[2] == "D" {
							inspector.AssignBuf(&x1.D, value, buf)
							return nil
						}
					}
					(x0)[i] = x1
					return nil
				}
			}
			x.StructPtrSlice = x0
		}
		if path[0] == "StructSlicePtr" {
			x0 := x.StructSlicePtr
			if uvalue, ok := value.(*[]testobj.TestStruct); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make([]testobj.TestStruct, 0)
				x0 = &z
				x.StructSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t163, err163 := strconv.ParseInt(path[1], 0, 0)
				if err163 != nil {
					return err163
				}
				i = int(t163)
				if len(*x0) > i {
					x1 := &(*x0)[i]
					_ = x1
					if len(path) > 2 {
						if path[2] == "A" {
							inspector.AssignBuf(&x1.A, value, buf)
							return nil
						}
						if path[2] == "S" {
							inspector.AssignBuf(&x1.S, value, buf)
							return nil
						}
						if path[2] == "B" {
							inspector.AssignBuf(&x1.B, value, buf)
							return nil
						}
						if path[2] == "I" {
							inspector.AssignBuf(&x1.I, value, buf)
							return nil
						}
						if path[2] == "I8" {
							inspector.AssignBuf(&x1.I8, value, buf)
							return nil
						}
						if path[2] == "I16" {
							inspector.AssignBuf(&x1.I16, value, buf)
							return nil
						}
						if path[2] == "I32" {
							inspector.AssignBuf(&x1.I32, value, buf)
							return nil
						}
						if path[2] == "I64" {
							inspector.AssignBuf(&x1.I64, value, buf)
							return nil
						}
						if path[2] == "U" {
							inspector.AssignBuf(&x1.U, value, buf)
							return nil
						}
						if path[2] == "U8" {
							inspector.AssignBuf(&x1.U8, value, buf)
							return nil
						}
						if path[2] == "U16" {
							inspector.AssignBuf(&x1.U16, value, buf)
							return nil
						}
						if path[2] == "U32" {
							inspector.AssignBuf(&x1.U32, value, buf)
							return nil
						}
						if path[2] == "U64" {
							inspector.AssignBuf(&x1.U64, value, buf)
							return nil
						}
						if path[2] == "F" {
							inspector.AssignBuf(&x1.F, value, buf)
							return nil
						}
						if path[2] == "D" {
							inspector.AssignBuf(&x1.D, value, buf)
							return nil
						}
					}
					(*x0)[i] = *x1
					return nil
				}
			}
			x.StructSlicePtr = x0
		}
		if path[0] == "StructPtrSlicePtr" {
			x0 := x.StructPtrSlicePtr
			if uvalue, ok := value.(*[]*testobj.TestStruct); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make([]*testobj.TestStruct, 0)
				x0 = &z
				x.StructPtrSlicePtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var i int
				t164, err164 := strconv.ParseInt(path[1], 0, 0)
				if err164 != nil {
					return err164
				}
				i = int(t164)
				if len(*x0) > i {
					x1 := (*x0)[i]
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return nil
						}
						if path[2] == "A" {
							inspector.AssignBuf(&x1.A, value, buf)
							return nil
						}
						if path[2] == "S" {
							inspector.AssignBuf(&x1.S, value, buf)
							return nil
						}
						if path[2] == "B" {
							inspector.AssignBuf(&x1.B, value, buf)
							return nil
						}
						if path[2] == "I" {
							inspector.AssignBuf(&x1.I, value, buf)
							return nil
						}
						if path[2] == "I8" {
							inspector.AssignBuf(&x1.I8, value, buf)
							return nil
						}
						if path[2] == "I16" {
							inspector.AssignBuf(&x1.I16, value, buf)
							return nil
						}
						if path[2] == "I32" {
							inspector.AssignBuf(&x1.I32, value, buf)
							return nil
						}
						if path[2] == "I64" {
							inspector.AssignBuf(&x1.I64, value, buf)
							return nil
						}
						if path[2] == "U" {
							inspector.AssignBuf(&x1.U, value, buf)
							return nil
						}
						if path[2] == "U8" {
							inspector.AssignBuf(&x1.U8, value, buf)
							return nil
						}
						if path[2] == "U16" {
							inspector.AssignBuf(&x1.U16, value, buf)
							return nil
						}
						if path[2] == "U32" {
							inspector.AssignBuf(&x1.U32, value, buf)
							return nil
						}
						if path[2] == "U64" {
							inspector.AssignBuf(&x1.U64, value, buf)
							return nil
						}
						if path[2] == "F" {
							inspector.AssignBuf(&x1.F, value, buf)
							return nil
						}
						if path[2] == "D" {
							inspector.AssignBuf(&x1.D, value, buf)
							return nil
						}
					}
					(*x0)[i] = x1
					return nil
				}
			}
			x.StructPtrSlicePtr = x0
		}
		if path[0] == "IntStringMap" {
			x0 := x.IntStringMap
			if uvalue, ok := value.(*map[int]string); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(map[int]string)
				x0 = z
				x.IntStringMap = x0
			}
			_ = x0
			if len(path) > 1 {
				var k int
				t165, err165 := strconv.ParseInt(path[1], 0, 0)
				if err165 != nil {
					return err165
				}
				k = int(t165)
				x1 := (x0)[k]
				_ = x1
				inspector.AssignBuf(&x1, value, buf)
				(x0)[k] = x1
				return nil
			}
			x.IntStringMap = x0
		}
		if path[0] == "IntStringPtrMap" {
			x0 := x.IntStringPtrMap
			if uvalue, ok := value.(*map[int]*string); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(map[int]*string)
				x0 = z
				x.IntStringPtrMap = x0
			}
			_ = x0
			if len(path) > 1 {
				var k int
				t166, err166 := strconv.ParseInt(path[1], 0, 0)
				if err166 != nil {
					return err166
				}
				k = int(t166)
				x1 := (x0)[k]
				_ = x1
				if x1 == nil {
					return nil
				}
				inspector.AssignBuf(x1, value, buf)
				(x0)[k] = x1
				return nil
			}
			x.IntStringPtrMap = x0
		}
		if path[0] == "IntStringMapPtr" {
			x0 := x.IntStringMapPtr
			if uvalue, ok := value.(*map[int]string); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(map[int]string)
				x0 = &z
				x.IntStringMapPtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var k int
				t167, err167 := strconv.ParseInt(path[1], 0, 0)
				if err167 != nil {
					return err167
				}
				k = int(t167)
				x1 := (*x0)[k]
				_ = x1
				inspector.AssignBuf(&x1, value, buf)
				(*x0)[k] = x1
				return nil
			}
			x.IntStringMapPtr = x0
		}
		if path[0] == "IntStringPtrMapPtr" {
			x0 := x.IntStringPtrMapPtr
			if uvalue, ok := value.(*map[int]*string); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(map[int]*string)
				x0 = &z
				x.IntStringPtrMapPtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var k int
				t168, err168 := strconv.ParseInt(path[1], 0, 0)
				if err168 != nil {
					return err168
				}
				k = int(t168)
				x1 := (*x0)[k]
				_ = x1
				if x1 == nil {
					return nil
				}
				inspector.AssignBuf(x1, value, buf)
				(*x0)[k] = x1
				return nil
			}
			x.IntStringPtrMapPtr = x0
		}
		if path[0] == "IntPtrStringPtrMapPtr" {
			x0 := x.IntPtrStringPtrMapPtr
			if uvalue, ok := value.(*map[*int]*string); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(map[*int]*string)
				x0 = &z
				x.IntPtrStringPtrMapPtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				var k int
				t169, err169 := strconv.ParseInt(path[1], 0, 0)
				if err169 != nil {
					return err169
				}
				k = int(t169)
				x1 := (*x0)[&k]
				_ = x1
				if x1 == nil {
					return nil
				}
				inspector.AssignBuf(x1, value, buf)
				(*x0)[&k] = x1
				return nil
			}
			x.IntPtrStringPtrMapPtr = x0
		}
		if path[0] == "StringFloatMap" {
			x0 := x.StringFloatMap
			if uvalue, ok := value.(*testobj.TestStringFloatMap); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(testobj.TestStringFloatMap)
				x0 = z
				x.StringFloatMap = x0
			}
			_ = x0
			if len(path) > 1 {
				x1 := (x0)[path[1]]
				_ = x1
				inspector.AssignBuf(&x1, value, buf)
				(x0)[path[1]] = x1
				return nil
			}
			x.StringFloatMap = x0
		}
		if path[0] == "StringFloatPtrMap" {
			x0 := x.StringFloatPtrMap
			if uvalue, ok := value.(*testobj.TestStringFloatPtrMap); ok {
				x0 = *uvalue
			}
			if x0 == nil {
				z := make(testobj.TestStringFloatPtrMap)
				x0 = z
				x.StringFloatPtrMap = x0
			}
			_ = x0
			if len(path) > 1 {
				x1 := (x0)[path[1]]
				_ = x1
				if x1 == nil {
					return nil
				}
				inspector.AssignBuf(x1, value, buf)
				(x0)[path[1]] = x1
				return nil
			}
			x.StringFloatPtrMap = x0
		}
		if path[0] == "StringFloatMapPtr" {
			x0 := x.StringFloatMapPtr
			if uvalue, ok := value.(*testobj.TestStringFloatMap); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(testobj.TestStringFloatMap)
				x0 = &z
				x.StringFloatMapPtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				x1 := (*x0)[path[1]]
				_ = x1
				inspector.AssignBuf(&x1, value, buf)
				(*x0)[path[1]] = x1
				return nil
			}
			x.StringFloatMapPtr = x0
		}
		if path[0] == "StringFloatPtrMapPtr" {
			x0 := x.StringFloatPtrMapPtr
			if uvalue, ok := value.(*testobj.TestStringFloatPtrMap); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(testobj.TestStringFloatPtrMap)
				x0 = &z
				x.StringFloatPtrMapPtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				x1 := (*x0)[path[1]]
				_ = x1
				if x1 == nil {
					return nil
				}
				inspector.AssignBuf(x1, value, buf)
				(*x0)[path[1]] = x1
				return nil
			}
			x.StringFloatPtrMapPtr = x0
		}
		if path[0] == "StringPtrFloatPtrMapPtr" {
			x0 := x.StringPtrFloatPtrMapPtr
			if uvalue, ok := value.(*testobj.TestStringPtrFloatPtrMap); ok {
				x0 = uvalue
			}
			if x0 == nil {
				z := make(testobj.TestStringPtrFloatPtrMap)
				x0 = &z
				x.StringPtrFloatPtrMapPtr = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				x1 := (*x0)[&path[1]]
				_ = x1
				if x1 == nil {
					return nil
				}
				inspector.AssignBuf(x1, value, buf)
				(*x0)[&path[1]] = x1
				return nil
			}
			x.StringPtrFloatPtrMapPtr = x0
		}
	}
	return nil
}

func (i6 TestObject1Inspector) Set(dst, value interface{}, path ...string) error {
	return i6.SetWB(dst, value, nil, path...)
}

func (i6 TestObject1Inspector) DeepEqual(l, r interface{}) bool {
	return i6.DeepEqualWithOptions(l, r, nil)
}

func (i6 TestObject1Inspector) DeepEqualWithOptions(l, r interface{}, opts *inspector.DEQOptions) bool {
	var (
		lx, rx   *testobj.TestObject1
		leq, req bool
	)
	_, _, _, _ = lx, rx, leq, req
	if lp, ok := l.(**testobj.TestObject1); ok {
		lx, leq = *lp, true
	} else if lp, ok := l.(*testobj.TestObject1); ok {
		lx, leq = lp, true
	} else if lp, ok := l.(testobj.TestObject1); ok {
		lx, leq = &lp, true
	}
	if rp, ok := r.(**testobj.TestObject1); ok {
		rx, req = *rp, true
	} else if rp, ok := r.(*testobj.TestObject1); ok {
		rx, req = rp, true
	} else if rp, ok := r.(testobj.TestObject1); ok {
		rx, req = &rp, true
	}
	if !leq || !req {
		return false
	}
	if lx == nil && rx == nil {
		return true
	}
	if (lx == nil && rx != nil) || (lx != nil && rx == nil) {
		return false
	}

	lx1 := lx.IntSlice
	rx1 := rx.IntSlice
	_, _ = lx1, rx1
	if inspector.DEQMustCheck("IntSlice", opts) {
		if len(lx1) != len(rx1) {
			return false
		}
		for i := 0; i < len(lx1); i++ {
			lx2 := (lx1)[i]
			rx2 := (rx1)[i]
			_, _ = lx2, rx2
			if lx2 != rx2 {
				return false
			}
		}
	}
	lx3 := lx.IntPtrSlice
	rx3 := rx.IntPtrSlice
	_, _ = lx3, rx3
	if inspector.DEQMustCheck("IntPtrSlice", opts) {
		if len(lx3) != len(rx3) {
			return false
		}
		for i := 0; i < len(lx3); i++ {
			lx4 := (lx3)[i]
			rx4 := (rx3)[i]
			_, _ = lx4, rx4
			if (lx4 == nil && rx4 != nil) || (lx4 != nil && rx4 == nil) {
				return false
			}
			if lx4 != nil && rx4 != nil {
				if *lx4 != *rx4 {
					return false
				}
			}
		}
	}
	lx5 := lx.IntSlicePtr
	rx5 := rx.IntSlicePtr
	_, _ = lx5, rx5
	if (lx5 == nil && rx5 != nil) || (lx5 != nil && rx5 == nil) {
		return false
	}
	if lx5 != nil && rx5 != nil {
		if inspector.DEQMustCheck("IntSlicePtr", opts) {
			if len(*lx5) != len(*rx5) {
				return false
			}
			for i := 0; i < len(*lx5); i++ {
				lx6 := (*lx5)[i]
				rx6 := (*rx5)[i]
				_, _ = lx6, rx6
				if lx6 != rx6 {
					return false
				}
			}
		}
	}
	lx7 := lx.IntPtrSlicePtr
	rx7 := rx.IntPtrSlicePtr
	_, _ = lx7, rx7
	if (lx7 == nil && rx7 != nil) || (lx7 != nil && rx7 == nil) {
		return false
	}
	if lx7 != nil && rx7 != nil {
		if inspector.DEQMustCheck("IntPtrSlicePtr", opts) {
			if len(*lx7) != len(*rx7) {
				return false
			}
			for i := 0; i < len(*lx7); i++ {
				lx8 := (*lx7)[i]
				rx8 := (*rx7)[i]
				_, _ = lx8, rx8
				if (lx8 == nil && rx8 != nil) || (lx8 != nil && rx8 == nil) {
					return false
				}
				if lx8 != nil && rx8 != nil {
					if *lx8 != *rx8 {
						return false
					}
				}
			}
		}
	}
	if !bytes.Equal(lx.ByteSlice, rx.ByteSlice) && inspector.DEQMustCheck("ByteSlice", opts) {
		return false
	}
	lx9 := lx.BytePtrSlice
	rx9 := rx.BytePtrSlice
	_, _ = lx9, rx9
	if inspector.DEQMustCheck("BytePtrSlice", opts) {
		if len(lx9) != len(rx9) {
			return false
		}
		for i := 0; i < len(lx9); i++ {
			lx10 := (lx9)[i]
			rx10 := (rx9)[i]
			_, _ = lx10, rx10
			if (lx10 == nil && rx10 != nil) || (lx10 != nil && rx10 == nil) {
				return false
			}
			if lx10 != nil && rx10 != nil {
				if *lx10 != *rx10 {
					return false
				}
			}
		}
	}
	if (lx == nil && rx != nil) || (lx != nil && rx == nil) {
		return false
	}
	if lx != nil && rx != nil {
		if !bytes.Equal(*lx.ByteSlicePtr, *rx.ByteSlicePtr) && inspector.DEQMustCheck("ByteSlicePtr", opts) {
			return false
		}
	}
	lx11 := lx.BytePtrSlicePtr
	rx11 := rx.BytePtrSlicePtr
	_, _ = lx11, rx11
	if (lx11 == nil && rx11 != nil) || (lx11 != nil && rx11 == nil) {
		return false
	}
	if lx11 != nil && rx11 != nil {
		if inspector.DEQMustCheck("BytePtrSlicePtr", opts) {
			if len(*lx11) != len(*rx11) {
				return false
			}
			for i := 0; i < len(*lx11); i++ {
				lx12 := (*lx11)[i]
				rx12 := (*rx11)[i]
				_, _ = lx12, rx12
				if (lx12 == nil && rx12 != nil) || (lx12 != nil && rx12 == nil) {
					return false
				}
				if lx12 != nil && rx12 != nil {
					if *lx12 != *rx12 {
						return false
					}
				}
			}
		}
	}
	lx13 := lx.FloatSlice
	rx13 := rx.FloatSlice
	_, _ = lx13, rx13
	if inspector.DEQMustCheck("FloatSlice", opts) {
		if len(lx13) != len(rx13) {
			return false
		}
		for i := 0; i < len(lx13); i++ {
			lx14 := (lx13)[i]
			rx14 := (rx13)[i]
			_, _ = lx14, rx14
			if lx14 != rx14 {
				return false
			}
		}
	}
	lx15 := lx.FloatPtrSlice
	rx15 := rx.FloatPtrSlice
	_, _ = lx15, rx15
	if inspector.DEQMustCheck("FloatPtrSlice", opts) {
		if len(lx15) != len(rx15) {
			return false
		}
		for i := 0; i < len(lx15); i++ {
			lx16 := (lx15)[i]
			rx16 := (rx15)[i]
			_, _ = lx16, rx16
			if (lx16 == nil && rx16 != nil) || (lx16 != nil && rx16 == nil) {
				return false
			}
			if lx16 != nil && rx16 != nil {
				if *lx16 != *rx16 {
					return false
				}
			}
		}
	}
	lx17 := lx.FloatSlicePtr
	rx17 := rx.FloatSlicePtr
	_, _ = lx17, rx17
	if (lx17 == nil && rx17 != nil) || (lx17 != nil && rx17 == nil) {
		return false
	}
	if lx17 != nil && rx17 != nil {
		if inspector.DEQMustCheck("FloatSlicePtr", opts) {
			if len(*lx17) != len(*rx17) {
				return false
			}
			for i := 0; i < len(*lx17); i++ {
				lx18 := (*lx17)[i]
				rx18 := (*rx17)[i]
				_, _ = lx18, rx18
				if lx18 != rx18 {
					return false
				}
			}
		}
	}
	lx19 := lx.FloatPtrSlicePtr
	rx19 := rx.FloatPtrSlicePtr
	_, _ = lx19, rx19
	if (lx19 == nil && rx19 != nil) || (lx19 != nil && rx19 == nil) {
		return false
	}
	if lx19 != nil && rx19 != nil {
		if inspector.DEQMustCheck("FloatPtrSlicePtr", opts) {
			if len(*lx19) != len(*rx19) {
				return false
			}
			for i := 0; i < len(*lx19); i++ {
				lx20 := (*lx19)[i]
				rx20 := (*rx19)[i]
				_, _ = lx20, rx20
				if (lx20 == nil && rx20 != nil) || (lx20 != nil && rx20 == nil) {
					return false
				}
				if lx20 != nil && rx20 != nil {
					if *lx20 != *rx20 {
						return false
					}
				}
			}
		}
	}
	lx21 := lx.StructSlice
	rx21 := rx.StructSlice
	_, _ = lx21, rx21
	if inspector.DEQMustCheck("StructSlice", opts) {
		if len(lx21) != len(rx21) {
			return false
		}
		for i := 0; i < len(lx21); i++ {
			lx22 := (lx21)[i]
			rx22 := (rx21)[i]
			_, _ = lx22, rx22
			if lx22.A != rx22.A && inspector.DEQMustCheck("StructSlice.A", opts) {
				return false
			}
			if lx22.S != rx22.S && inspector.DEQMustCheck("StructSlice.S", opts) {
				return false
			}
			if !bytes.Equal(lx22.B, rx22.B) && inspector.DEQMustCheck("StructSlice.B", opts) {
				return false
			}
			if lx22.I != rx22.I && inspector.DEQMustCheck("StructSlice.I", opts) {
				return false
			}
			if lx22.I8 != rx22.I8 && inspector.DEQMustCheck("StructSlice.I8", opts) {
				return false
			}
			if lx22.I16 != rx22.I16 && inspector.DEQMustCheck("StructSlice.I16", opts) {
				return false
			}
			if lx22.I32 != rx22.I32 && inspector.DEQMustCheck("StructSlice.I32", opts) {
				return false
			}
			if lx22.I64 != rx22.I64 && inspector.DEQMustCheck("StructSlice.I64", opts) {
				return false
			}
			if lx22.U != rx22.U && inspector.DEQMustCheck("StructSlice.U", opts) {
				return false
			}
			if lx22.U8 != rx22.U8 && inspector.DEQMustCheck("StructSlice.U8", opts) {
				return false
			}
			if lx22.U16 != rx22.U16 && inspector.DEQMustCheck("StructSlice.U16", opts) {
				return false
			}
			if lx22.U32 != rx22.U32 && inspector.DEQMustCheck("StructSlice.U32", opts) {
				return false
			}
			if lx22.U64 != rx22.U64 && inspector.DEQMustCheck("StructSlice.U64", opts) {
				return false
			}
			if !inspector.EqualFloat32(lx22.F, rx22.F, opts) && inspector.DEQMustCheck("StructSlice.F", opts) {
				return false
			}
			if !inspector.EqualFloat64(lx22.D, rx22.D, opts) && inspector.DEQMustCheck("StructSlice.D", opts) {
				return false
			}
		}
	}
	lx23 := lx.StructPtrSlice
	rx23 := rx.StructPtrSlice
	_, _ = lx23, rx23
	if inspector.DEQMustCheck("StructPtrSlice", opts) {
		if len(lx23) != len(rx23) {
			return false
		}
		for i := 0; i < len(lx23); i++ {
			lx24 := (lx23)[i]
			rx24 := (rx23)[i]
			_, _ = lx24, rx24
			if (lx24 == nil && rx24 != nil) || (lx24 != nil && rx24 == nil) {
				return false
			}
			if lx24 != nil && rx24 != nil {
				if lx24.A != rx24.A && inspector.DEQMustCheck("StructPtrSlice.A", opts) {
					return false
				}
				if lx24.S != rx24.S && inspector.DEQMustCheck("StructPtrSlice.S", opts) {
					return false
				}
				if !bytes.Equal(lx24.B, rx24.B) && inspector.DEQMustCheck("StructPtrSlice.B", opts) {
					return false
				}
				if lx24.I != rx24.I && inspector.DEQMustCheck("StructPtrSlice.I", opts) {
					return false
				}
				if lx24.I8 != rx24.I8 && inspector.DEQMustCheck("StructPtrSlice.I8", opts) {
					return false
				}
				if lx24.I16 != rx24.I16 && inspector.DEQMustCheck("StructPtrSlice.I16", opts) {
					return false
				}
				if lx24.I32 != rx24.I32 && inspector.DEQMustCheck("StructPtrSlice.I32", opts) {
					return false
				}
				if lx24.I64 != rx24.I64 && inspector.DEQMustCheck("StructPtrSlice.I64", opts) {
					return false
				}
				if lx24.U != rx24.U && inspector.DEQMustCheck("StructPtrSlice.U", opts) {
					return false
				}
				if lx24.U8 != rx24.U8 && inspector.DEQMustCheck("StructPtrSlice.U8", opts) {
					return false
				}
				if lx24.U16 != rx24.U16 && inspector.DEQMustCheck("StructPtrSlice.U16", opts) {
					return false
				}
				if lx24.U32 != rx24.U32 && inspector.DEQMustCheck("StructPtrSlice.U32", opts) {
					return false
				}
				if lx24.U64 != rx24.U64 && inspector.DEQMustCheck("StructPtrSlice.U64", opts) {
					return false
				}
				if !inspector.EqualFloat32(lx24.F, rx24.F, opts) && inspector.DEQMustCheck("StructPtrSlice.F", opts) {
					return false
				}
				if !inspector.EqualFloat64(lx24.D, rx24.D, opts) && inspector.DEQMustCheck("StructPtrSlice.D", opts) {
					return false
				}
			}
		}
	}
	lx25 := lx.StructSlicePtr
	rx25 := rx.StructSlicePtr
	_, _ = lx25, rx25
	if (lx25 == nil && rx25 != nil) || (lx25 != nil && rx25 == nil) {
		return false
	}
	if lx25 != nil && rx25 != nil {
		if inspector.DEQMustCheck("StructSlicePtr", opts) {
			if len(*lx25) != len(*rx25) {
				return false
			}
			for i := 0; i < len(*lx25); i++ {
				lx26 := (*lx25)[i]
				rx26 := (*rx25)[i]
				_, _ = lx26, rx26
				if lx26.A != rx26.A && inspector.DEQMustCheck("StructSlicePtr.A", opts) {
					return false
				}
				if lx26.S != rx26.S && inspector.DEQMustCheck("StructSlicePtr.S", opts) {
					return false
				}
				if !bytes.Equal(lx26.B, rx26.B) && inspector.DEQMustCheck("StructSlicePtr.B", opts) {
					return false
				}
				if lx26.I != rx26.I && inspector.DEQMustCheck("StructSlicePtr.I", opts) {
					return false
				}
				if lx26.I8 != rx26.I8 && inspector.DEQMustCheck("StructSlicePtr.I8", opts) {
					return false
				}
				if lx26.I16 != rx26.I16 && inspector.DEQMustCheck("StructSlicePtr.I16", opts) {
					return false
				}
				if lx26.I32 != rx26.I32 && inspector.DEQMustCheck("StructSlicePtr.I32", opts) {
					return false
				}
				if lx26.I64 != rx26.I64 && inspector.DEQMustCheck("StructSlicePtr.I64", opts) {
					return false
				}
				if lx26.U != rx26.U && inspector.DEQMustCheck("StructSlicePtr.U", opts) {
					return false
				}
				if lx26.U8 != rx26.U8 && inspector.DEQMustCheck("StructSlicePtr.U8", opts) {
					return false
				}
				if lx26.U16 != rx26.U16 && inspector.DEQMustCheck("StructSlicePtr.U16", opts) {
					return false
				}
				if lx26.U32 != rx26.U32 && inspector.DEQMustCheck("StructSlicePtr.U32", opts) {
					return false
				}
				if lx26.U64 != rx26.U64 && inspector.DEQMustCheck("StructSlicePtr.U64", opts) {
					return false
				}
				if !inspector.EqualFloat32(lx26.F, rx26.F, opts) && inspector.DEQMustCheck("StructSlicePtr.F", opts) {
					return false
				}
				if !inspector.EqualFloat64(lx26.D, rx26.D, opts) && inspector.DEQMustCheck("StructSlicePtr.D", opts) {
					return false
				}
			}
		}
	}
	lx27 := lx.StructPtrSlicePtr
	rx27 := rx.StructPtrSlicePtr
	_, _ = lx27, rx27
	if (lx27 == nil && rx27 != nil) || (lx27 != nil && rx27 == nil) {
		return false
	}
	if lx27 != nil && rx27 != nil {
		if inspector.DEQMustCheck("StructPtrSlicePtr", opts) {
			if len(*lx27) != len(*rx27) {
				return false
			}
			for i := 0; i < len(*lx27); i++ {
				lx28 := (*lx27)[i]
				rx28 := (*rx27)[i]
				_, _ = lx28, rx28
				if (lx28 == nil && rx28 != nil) || (lx28 != nil && rx28 == nil) {
					return false
				}
				if lx28 != nil && rx28 != nil {
					if lx28.A != rx28.A && inspector.DEQMustCheck("StructPtrSlicePtr.A", opts) {
						return false
					}
					if lx28.S != rx28.S && inspector.DEQMustCheck("StructPtrSlicePtr.S", opts) {
						return false
					}
					if !bytes.Equal(lx28.B, rx28.B) && inspector.DEQMustCheck("StructPtrSlicePtr.B", opts) {
						return false
					}
					if lx28.I != rx28.I && inspector.DEQMustCheck("StructPtrSlicePtr.I", opts) {
						return false
					}
					if lx28.I8 != rx28.I8 && inspector.DEQMustCheck("StructPtrSlicePtr.I8", opts) {
						return false
					}
					if lx28.I16 != rx28.I16 && inspector.DEQMustCheck("StructPtrSlicePtr.I16", opts) {
						return false
					}
					if lx28.I32 != rx28.I32 && inspector.DEQMustCheck("StructPtrSlicePtr.I32", opts) {
						return false
					}
					if lx28.I64 != rx28.I64 && inspector.DEQMustCheck("StructPtrSlicePtr.I64", opts) {
						return false
					}
					if lx28.U != rx28.U && inspector.DEQMustCheck("StructPtrSlicePtr.U", opts) {
						return false
					}
					if lx28.U8 != rx28.U8 && inspector.DEQMustCheck("StructPtrSlicePtr.U8", opts) {
						return false
					}
					if lx28.U16 != rx28.U16 && inspector.DEQMustCheck("StructPtrSlicePtr.U16", opts) {
						return false
					}
					if lx28.U32 != rx28.U32 && inspector.DEQMustCheck("StructPtrSlicePtr.U32", opts) {
						return false
					}
					if lx28.U64 != rx28.U64 && inspector.DEQMustCheck("StructPtrSlicePtr.U64", opts) {
						return false
					}
					if !inspector.EqualFloat32(lx28.F, rx28.F, opts) && inspector.DEQMustCheck("StructPtrSlicePtr.F", opts) {
						return false
					}
					if !inspector.EqualFloat64(lx28.D, rx28.D, opts) && inspector.DEQMustCheck("StructPtrSlicePtr.D", opts) {
						return false
					}
				}
			}
		}
	}
	lx29 := lx.IntStringMap
	rx29 := rx.IntStringMap
	_, _ = lx29, rx29
	if inspector.DEQMustCheck("IntStringMap", opts) {
		if len(lx29) != len(rx29) {
			return false
		}
		for k := range lx29 {
			lx30 := (lx29)[k]
			rx30, ok30 := (rx29)[k]
			_, _, _ = lx30, rx30, ok30
			if !ok30 {
				return false
			}
			if lx30 != rx30 {
				return false
			}
		}
	}
	lx31 := lx.IntStringPtrMap
	rx31 := rx.IntStringPtrMap
	_, _ = lx31, rx31
	if inspector.DEQMustCheck("IntStringPtrMap", opts) {
		if len(lx31) != len(rx31) {
			return false
		}
		for k := range lx31 {
			lx32 := (lx31)[k]
			rx32, ok32 := (rx31)[k]
			_, _, _ = lx32, rx32, ok32
			if !ok32 {
				return false
			}
			if (lx32 == nil && rx32 != nil) || (lx32 != nil && rx32 == nil) {
				return false
			}
			if lx32 != nil && rx32 != nil {
				if *lx32 != *rx32 {
					return false
				}
			}
		}
	}
	lx33 := lx.IntStringMapPtr
	rx33 := rx.IntStringMapPtr
	_, _ = lx33, rx33
	if (lx33 == nil && rx33 != nil) || (lx33 != nil && rx33 == nil) {
		return false
	}
	if lx33 != nil && rx33 != nil {
		if inspector.DEQMustCheck("IntStringMapPtr", opts) {
			if len(*lx33) != len(*rx33) {
				return false
			}
			for k := range *lx33 {
				lx34 := (*lx33)[k]
				rx34, ok34 := (*rx33)[k]
				_, _, _ = lx34, rx34, ok34
				if !ok34 {
					return false
				}
				if lx34 != rx34 {
					return false
				}
			}
		}
	}
	lx35 := lx.IntStringPtrMapPtr
	rx35 := rx.IntStringPtrMapPtr
	_, _ = lx35, rx35
	if (lx35 == nil && rx35 != nil) || (lx35 != nil && rx35 == nil) {
		return false
	}
	if lx35 != nil && rx35 != nil {
		if inspector.DEQMustCheck("IntStringPtrMapPtr", opts) {
			if len(*lx35) != len(*rx35) {
				return false
			}
			for k := range *lx35 {
				lx36 := (*lx35)[k]
				rx36, ok36 := (*rx35)[k]
				_, _, _ = lx36, rx36, ok36
				if !ok36 {
					return false
				}
				if (lx36 == nil && rx36 != nil) || (lx36 != nil && rx36 == nil) {
					return false
				}
				if lx36 != nil && rx36 != nil {
					if *lx36 != *rx36 {
						return false
					}
				}
			}
		}
	}
	lx37 := lx.IntPtrStringPtrMapPtr
	rx37 := rx.IntPtrStringPtrMapPtr
	_, _ = lx37, rx37
	if (lx37 == nil && rx37 != nil) || (lx37 != nil && rx37 == nil) {
		return false
	}
	if lx37 != nil && rx37 != nil {
		if inspector.DEQMustCheck("IntPtrStringPtrMapPtr", opts) {
			if len(*lx37) != len(*rx37) {
				return false
			}
			for k := range *lx37 {
				lx38 := (*lx37)[k]
				rx38, ok38 := (*rx37)[k]
				_, _, _ = lx38, rx38, ok38
				if !ok38 {
					return false
				}
				if (lx38 == nil && rx38 != nil) || (lx38 != nil && rx38 == nil) {
					return false
				}
				if lx38 != nil && rx38 != nil {
					if *lx38 != *rx38 {
						return false
					}
				}
			}
		}
	}
	lx39 := lx.StringFloatMap
	rx39 := rx.StringFloatMap
	_, _ = lx39, rx39
	if inspector.DEQMustCheck("StringFloatMap", opts) {
		if len(lx39) != len(rx39) {
			return false
		}
		for k := range lx39 {
			lx40 := (lx39)[k]
			rx40, ok40 := (rx39)[k]
			_, _, _ = lx40, rx40, ok40
			if !ok40 {
				return false
			}
			if lx40 != rx40 {
				return false
			}
		}
	}
	lx41 := lx.StringFloatPtrMap
	rx41 := rx.StringFloatPtrMap
	_, _ = lx41, rx41
	if inspector.DEQMustCheck("StringFloatPtrMap", opts) {
		if len(lx41) != len(rx41) {
			return false
		}
		for k := range lx41 {
			lx42 := (lx41)[k]
			rx42, ok42 := (rx41)[k]
			_, _, _ = lx42, rx42, ok42
			if !ok42 {
				return false
			}
			if (lx42 == nil && rx42 != nil) || (lx42 != nil && rx42 == nil) {
				return false
			}
			if lx42 != nil && rx42 != nil {
				if *lx42 != *rx42 {
					return false
				}
			}
		}
	}
	lx43 := lx.StringFloatMapPtr
	rx43 := rx.StringFloatMapPtr
	_, _ = lx43, rx43
	if (lx43 == nil && rx43 != nil) || (lx43 != nil && rx43 == nil) {
		return false
	}
	if lx43 != nil && rx43 != nil {
		if inspector.DEQMustCheck("StringFloatMapPtr", opts) {
			if len(*lx43) != len(*rx43) {
				return false
			}
			for k := range *lx43 {
				lx44 := (*lx43)[k]
				rx44, ok44 := (*rx43)[k]
				_, _, _ = lx44, rx44, ok44
				if !ok44 {
					return false
				}
				if lx44 != rx44 {
					return false
				}
			}
		}
	}
	lx45 := lx.StringFloatPtrMapPtr
	rx45 := rx.StringFloatPtrMapPtr
	_, _ = lx45, rx45
	if (lx45 == nil && rx45 != nil) || (lx45 != nil && rx45 == nil) {
		return false
	}
	if lx45 != nil && rx45 != nil {
		if inspector.DEQMustCheck("StringFloatPtrMapPtr", opts) {
			if len(*lx45) != len(*rx45) {
				return false
			}
			for k := range *lx45 {
				lx46 := (*lx45)[k]
				rx46, ok46 := (*rx45)[k]
				_, _, _ = lx46, rx46, ok46
				if !ok46 {
					return false
				}
				if (lx46 == nil && rx46 != nil) || (lx46 != nil && rx46 == nil) {
					return false
				}
				if lx46 != nil && rx46 != nil {
					if *lx46 != *rx46 {
						return false
					}
				}
			}
		}
	}
	lx47 := lx.StringPtrFloatPtrMapPtr
	rx47 := rx.StringPtrFloatPtrMapPtr
	_, _ = lx47, rx47
	if (lx47 == nil && rx47 != nil) || (lx47 != nil && rx47 == nil) {
		return false
	}
	if lx47 != nil && rx47 != nil {
		if inspector.DEQMustCheck("StringPtrFloatPtrMapPtr", opts) {
			if len(*lx47) != len(*rx47) {
				return false
			}
			for k := range *lx47 {
				lx48 := (*lx47)[k]
				rx48, ok48 := (*rx47)[k]
				_, _, _ = lx48, rx48, ok48
				if !ok48 {
					return false
				}
				if (lx48 == nil && rx48 != nil) || (lx48 != nil && rx48 == nil) {
					return false
				}
				if lx48 != nil && rx48 != nil {
					if *lx48 != *rx48 {
						return false
					}
				}
			}
		}
	}
	return true
}

func (i6 TestObject1Inspector) Unmarshal(p []byte, typ inspector.Encoding) (interface{}, error) {
	var x testobj.TestObject1
	switch typ {
	case inspector.EncodingJSON:
		err := json.Unmarshal(p, &x)
		return &x, err
	default:
		return nil, inspector.ErrUnknownEncodingType
	}
}

func (i6 TestObject1Inspector) Copy(x interface{}) (interface{}, error) {
	var origin, cpy testobj.TestObject1
	switch x.(type) {
	case testobj.TestObject1:
		origin = x.(testobj.TestObject1)
	case *testobj.TestObject1:
		origin = *x.(*testobj.TestObject1)
	case **testobj.TestObject1:
		origin = **x.(**testobj.TestObject1)
	default:
		return nil, inspector.ErrUnsupportedType
	}
	bc := i6.calcBytes(&origin)
	buf := make([]byte, 0, bc)
	if err := i6.cpy(buf, &cpy, &origin); err != nil {
		return nil, err
	}
	return cpy, nil
}

func (i6 TestObject1Inspector) calcBytes(x *testobj.TestObject1) (c int) {
	c += len(x.ByteSlice)
	if x.ByteSlicePtr != nil {
		c += len(*x.ByteSlicePtr)
	}
	for i1 := 0; i1 < len(x.StructSlice); i1++ {
		x1 := &(x.StructSlice)[i1]
		c += len(x1.S)
		c += len(x1.B)
	}
	for i1 := 0; i1 < len(x.StructPtrSlice); i1++ {
		x1 := (x.StructPtrSlice)[i1]
		c += len(x1.S)
		c += len(x1.B)
	}
	if x.StructSlicePtr != nil {
		for i1 := 0; i1 < len(*x.StructSlicePtr); i1++ {
			x1 := &(*x.StructSlicePtr)[i1]
			c += len(x1.S)
			c += len(x1.B)
		}
	}
	if x.StructPtrSlicePtr != nil {
		for i1 := 0; i1 < len(*x.StructPtrSlicePtr); i1++ {
			x1 := (*x.StructPtrSlicePtr)[i1]
			c += len(x1.S)
			c += len(x1.B)
		}
	}
	for k1, v1 := range x.IntStringMap {
		_, _ = k1, v1
		c += len(v1)
	}
	for k1, v1 := range x.IntStringPtrMap {
		_, _ = k1, v1
		c += len(*v1)
	}
	if x.IntStringMapPtr != nil {
		for k1, v1 := range *x.IntStringMapPtr {
			_, _ = k1, v1
			c += len(v1)
		}
	}
	if x.IntStringPtrMapPtr != nil {
		for k1, v1 := range *x.IntStringPtrMapPtr {
			_, _ = k1, v1
			c += len(*v1)
		}
	}
	if x.IntPtrStringPtrMapPtr != nil {
		for k1, v1 := range *x.IntPtrStringPtrMapPtr {
			_, _ = k1, v1
			c += len(*v1)
		}
	}
	for k1, v1 := range x.StringFloatMap {
		_, _ = k1, v1
		c += len(k1)
	}
	for k1, v1 := range x.StringFloatPtrMap {
		_, _ = k1, v1
		c += len(k1)
	}
	if x.StringFloatMapPtr != nil {
		for k1, v1 := range *x.StringFloatMapPtr {
			_, _ = k1, v1
			c += len(k1)
		}
	}
	if x.StringFloatPtrMapPtr != nil {
		for k1, v1 := range *x.StringFloatPtrMapPtr {
			_, _ = k1, v1
			c += len(k1)
		}
	}
	if x.StringPtrFloatPtrMapPtr != nil {
		for k1, v1 := range *x.StringPtrFloatPtrMapPtr {
			_, _ = k1, v1
			c += len(*k1)
		}
	}
	return c
}

func (i6 TestObject1Inspector) cpy(buf []byte, l, r *testobj.TestObject1) error {
	if len(r.IntSlice) > 0 {
		buf1 := make([]int32, 0, len(r.IntSlice))
		for i1 := 0; i1 < len(r.IntSlice); i1++ {
			var b1 int32
			x1 := (l.IntSlice)[i1]
			b1 = x1
			buf1 = append(buf1, b1)
		}
		l.IntSlice = buf1
	}
	if len(r.IntPtrSlice) > 0 {
		buf1 := make([]*int32, 0, len(r.IntPtrSlice))
		for i1 := 0; i1 < len(r.IntPtrSlice); i1++ {
			var b1 *int32
			x1 := (l.IntPtrSlice)[i1]
			b1 = x1
			buf1 = append(buf1, b1)
		}
		l.IntPtrSlice = buf1
	}
	if l.IntSlicePtr != nil {
		if len(*r.IntSlicePtr) > 0 {
			buf1 := make([]int32, 0, len(*r.IntSlicePtr))
			for i1 := 0; i1 < len(*r.IntSlicePtr); i1++ {
				var b1 int32
				x1 := (*l.IntSlicePtr)[i1]
				b1 = x1
				buf1 = append(buf1, b1)
			}
			l.IntSlicePtr = &buf1
		}
	}
	if l.IntPtrSlicePtr != nil {
		if len(*r.IntPtrSlicePtr) > 0 {
			buf1 := make([]*int32, 0, len(*r.IntPtrSlicePtr))
			for i1 := 0; i1 < len(*r.IntPtrSlicePtr); i1++ {
				var b1 *int32
				x1 := (*l.IntPtrSlicePtr)[i1]
				b1 = x1
				buf1 = append(buf1, b1)
			}
			l.IntPtrSlicePtr = &buf1
		}
	}
	buf, l.ByteSlice = inspector.Bufferize(buf, r.ByteSlice)
	if len(r.BytePtrSlice) > 0 {
		buf1 := make([]*byte, 0, len(r.BytePtrSlice))
		for i1 := 0; i1 < len(r.BytePtrSlice); i1++ {
			var b1 *byte
			x1 := (l.BytePtrSlice)[i1]
			b1 = x1
			buf1 = append(buf1, b1)
		}
		l.BytePtrSlice = buf1
	}
	if l.ByteSlicePtr != nil {
		buf, *l.ByteSlicePtr = inspector.Bufferize(buf, *r.ByteSlicePtr)
	}
	if l.BytePtrSlicePtr != nil {
		if len(*r.BytePtrSlicePtr) > 0 {
			buf1 := make([]*byte, 0, len(*r.BytePtrSlicePtr))
			for i1 := 0; i1 < len(*r.BytePtrSlicePtr); i1++ {
				var b1 *byte
				x1 := (*l.BytePtrSlicePtr)[i1]
				b1 = x1
				buf1 = append(buf1, b1)
			}
			l.BytePtrSlicePtr = &buf1
		}
	}
	if len(r.FloatSlice) > 0 {
		buf1 := make(testobj.TestFloatSlice, 0, len(r.FloatSlice))
		for i1 := 0; i1 < len(r.FloatSlice); i1++ {
			var b1 float32
			x1 := (l.FloatSlice)[i1]
			b1 = x1
			buf1 = append(buf1, b1)
		}
		l.FloatSlice = buf1
	}
	if len(r.FloatPtrSlice) > 0 {
		buf1 := make(testobj.TestFloatPtrSlice, 0, len(r.FloatPtrSlice))
		for i1 := 0; i1 < len(r.FloatPtrSlice); i1++ {
			var b1 *float32
			x1 := (l.FloatPtrSlice)[i1]
			b1 = x1
			buf1 = append(buf1, b1)
		}
		l.FloatPtrSlice = buf1
	}
	if l.FloatSlicePtr != nil {
		if len(*r.FloatSlicePtr) > 0 {
			buf1 := make(testobj.TestFloatSlice, 0, len(*r.FloatSlicePtr))
			for i1 := 0; i1 < len(*r.FloatSlicePtr); i1++ {
				var b1 float32
				x1 := (*l.FloatSlicePtr)[i1]
				b1 = x1
				buf1 = append(buf1, b1)
			}
			l.FloatSlicePtr = &buf1
		}
	}
	if l.FloatPtrSlicePtr != nil {
		if len(*r.FloatPtrSlicePtr) > 0 {
			buf1 := make(testobj.TestFloatPtrSlice, 0, len(*r.FloatPtrSlicePtr))
			for i1 := 0; i1 < len(*r.FloatPtrSlicePtr); i1++ {
				var b1 *float32
				x1 := (*l.FloatPtrSlicePtr)[i1]
				b1 = x1
				buf1 = append(buf1, b1)
			}
			l.FloatPtrSlicePtr = &buf1
		}
	}
	if len(r.StructSlice) > 0 {
		buf1 := make([]testobj.TestStruct, 0, len(r.StructSlice))
		for i1 := 0; i1 < len(r.StructSlice); i1++ {
			var b1 testobj.TestStruct
			x1 := &(l.StructSlice)[i1]
			b1.A = x1.A
			buf, b1.S = inspector.BufferizeString(buf, x1.S)
			buf, b1.B = inspector.Bufferize(buf, x1.B)
			b1.I = x1.I
			b1.I8 = x1.I8
			b1.I16 = x1.I16
			b1.I32 = x1.I32
			b1.I64 = x1.I64
			b1.U = x1.U
			b1.U8 = x1.U8
			b1.U16 = x1.U16
			b1.U32 = x1.U32
			b1.U64 = x1.U64
			b1.F = x1.F
			b1.D = x1.D
			buf1 = append(buf1, b1)
		}
		l.StructSlice = buf1
	}
	if len(r.StructPtrSlice) > 0 {
		buf1 := make([]*testobj.TestStruct, 0, len(r.StructPtrSlice))
		for i1 := 0; i1 < len(r.StructPtrSlice); i1++ {
			var b1 testobj.TestStruct
			x1 := (l.StructPtrSlice)[i1]
			b1.A = x1.A
			buf, b1.S = inspector.BufferizeString(buf, x1.S)
			buf, b1.B = inspector.Bufferize(buf, x1.B)
			b1.I = x1.I
			b1.I8 = x1.I8
			b1.I16 = x1.I16
			b1.I32 = x1.I32
			b1.I64 = x1.I64
			b1.U = x1.U
			b1.U8 = x1.U8
			b1.U16 = x1.U16
			b1.U32 = x1.U32
			b1.U64 = x1.U64
			b1.F = x1.F
			b1.D = x1.D
			buf1 = append(buf1, &b1)
		}
		l.StructPtrSlice = buf1
	}
	if l.StructSlicePtr != nil {
		if len(*r.StructSlicePtr) > 0 {
			buf1 := make([]testobj.TestStruct, 0, len(*r.StructSlicePtr))
			for i1 := 0; i1 < len(*r.StructSlicePtr); i1++ {
				var b1 testobj.TestStruct
				x1 := &(*l.StructSlicePtr)[i1]
				b1.A = x1.A
				buf, b1.S = inspector.BufferizeString(buf, x1.S)
				buf, b1.B = inspector.Bufferize(buf, x1.B)
				b1.I = x1.I
				b1.I8 = x1.I8
				b1.I16 = x1.I16
				b1.I32 = x1.I32
				b1.I64 = x1.I64
				b1.U = x1.U
				b1.U8 = x1.U8
				b1.U16 = x1.U16
				b1.U32 = x1.U32
				b1.U64 = x1.U64
				b1.F = x1.F
				b1.D = x1.D
				buf1 = append(buf1, b1)
			}
			l.StructSlicePtr = &buf1
		}
	}
	if l.StructPtrSlicePtr != nil {
		if len(*r.StructPtrSlicePtr) > 0 {
			buf1 := make([]*testobj.TestStruct, 0, len(*r.StructPtrSlicePtr))
			for i1 := 0; i1 < len(*r.StructPtrSlicePtr); i1++ {
				var b1 testobj.TestStruct
				x1 := (*l.StructPtrSlicePtr)[i1]
				b1.A = x1.A
				buf, b1.S = inspector.BufferizeString(buf, x1.S)
				buf, b1.B = inspector.Bufferize(buf, x1.B)
				b1.I = x1.I
				b1.I8 = x1.I8
				b1.I16 = x1.I16
				b1.I32 = x1.I32
				b1.I64 = x1.I64
				b1.U = x1.U
				b1.U8 = x1.U8
				b1.U16 = x1.U16
				b1.U32 = x1.U32
				b1.U64 = x1.U64
				b1.F = x1.F
				b1.D = x1.D
				buf1 = append(buf1, &b1)
			}
			l.StructPtrSlicePtr = &buf1
		}
	}
	if len(r.IntStringMap) > 0 {
		buf1 := make(map[int]string, len(r.IntStringMap))
		_ = buf1
		for rk, rv := range r.IntStringMap {
			_, _ = rk, rv
			var lk int
			lk = rk
			var lv string
			buf, lv = inspector.BufferizeString(buf, rv)
			(l.IntStringMap)[lk] = lv
		}
	}
	if len(r.IntStringPtrMap) > 0 {
		buf1 := make(map[int]*string, len(r.IntStringPtrMap))
		_ = buf1
		for rk, rv := range r.IntStringPtrMap {
			_, _ = rk, rv
			var lk int
			lk = rk
			var lv *string
			buf, *lv = inspector.BufferizeString(buf, *rv)
			(l.IntStringPtrMap)[lk] = lv
		}
	}
	if l.IntStringMapPtr != nil {
		if len(*r.IntStringMapPtr) > 0 {
			buf1 := make(map[int]string, len(*r.IntStringMapPtr))
			_ = buf1
			for rk, rv := range *r.IntStringMapPtr {
				_, _ = rk, rv
				var lk int
				lk = rk
				var lv string
				buf, lv = inspector.BufferizeString(buf, rv)
				(*l.IntStringMapPtr)[lk] = lv
			}
		}
	}
	if l.IntStringPtrMapPtr != nil {
		if len(*r.IntStringPtrMapPtr) > 0 {
			buf1 := make(map[int]*string, len(*r.IntStringPtrMapPtr))
			_ = buf1
			for rk, rv := range *r.IntStringPtrMapPtr {
				_, _ = rk, rv
				var lk int
				lk = rk
				var lv *string
				buf, *lv = inspector.BufferizeString(buf, *rv)
				(*l.IntStringPtrMapPtr)[lk] = lv
			}
		}
	}
	if l.IntPtrStringPtrMapPtr != nil {
		if len(*r.IntPtrStringPtrMapPtr) > 0 {
			buf1 := make(map[*int]*string, len(*r.IntPtrStringPtrMapPtr))
			_ = buf1
			for rk, rv := range *r.IntPtrStringPtrMapPtr {
				_, _ = rk, rv
				var lk *int
				lk = rk
				var lv *string
				buf, *lv = inspector.BufferizeString(buf, *rv)
				(*l.IntPtrStringPtrMapPtr)[lk] = lv
			}
		}
	}
	if len(r.StringFloatMap) > 0 {
		buf1 := make(testobj.TestStringFloatMap, len(r.StringFloatMap))
		_ = buf1
		for rk, rv := range r.StringFloatMap {
			_, _ = rk, rv
			var lk string
			buf, lk = inspector.BufferizeString(buf, rk)
			var lv float64
			lv = rv
			(l.StringFloatMap)[lk] = lv
		}
	}
	if len(r.StringFloatPtrMap) > 0 {
		buf1 := make(testobj.TestStringFloatPtrMap, len(r.StringFloatPtrMap))
		_ = buf1
		for rk, rv := range r.StringFloatPtrMap {
			_, _ = rk, rv
			var lk string
			buf, lk = inspector.BufferizeString(buf, rk)
			var lv *float64
			lv = rv
			(l.StringFloatPtrMap)[lk] = lv
		}
	}
	if l.StringFloatMapPtr != nil {
		if len(*r.StringFloatMapPtr) > 0 {
			buf1 := make(testobj.TestStringFloatMap, len(*r.StringFloatMapPtr))
			_ = buf1
			for rk, rv := range *r.StringFloatMapPtr {
				_, _ = rk, rv
				var lk string
				buf, lk = inspector.BufferizeString(buf, rk)
				var lv float64
				lv = rv
				(*l.StringFloatMapPtr)[lk] = lv
			}
		}
	}
	if l.StringFloatPtrMapPtr != nil {
		if len(*r.StringFloatPtrMapPtr) > 0 {
			buf1 := make(testobj.TestStringFloatPtrMap, len(*r.StringFloatPtrMapPtr))
			_ = buf1
			for rk, rv := range *r.StringFloatPtrMapPtr {
				_, _ = rk, rv
				var lk string
				buf, lk = inspector.BufferizeString(buf, rk)
				var lv *float64
				lv = rv
				(*l.StringFloatPtrMapPtr)[lk] = lv
			}
		}
	}
	if l.StringPtrFloatPtrMapPtr != nil {
		if len(*r.StringPtrFloatPtrMapPtr) > 0 {
			buf1 := make(testobj.TestStringPtrFloatPtrMap, len(*r.StringPtrFloatPtrMapPtr))
			_ = buf1
			for rk, rv := range *r.StringPtrFloatPtrMapPtr {
				_, _ = rk, rv
				var lk *string
				buf, *lk = inspector.BufferizeString(buf, *rk)
				var lv *float64
				lv = rv
				(*l.StringPtrFloatPtrMapPtr)[lk] = lv
			}
		}
	}
	return nil
}
