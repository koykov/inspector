// Code generated by inspc. DO NOT EDIT.
// source: github.com/koykov/inspector/testobj

package testobj_ins

import (
	"bytes"
	"encoding/json"
	"github.com/koykov/fastconv"
	"github.com/koykov/inspector"
	"github.com/koykov/inspector/testobj"
	"strconv"
)

type TestStructSliceLiteralInspector struct {
	inspector.BaseInspector
}

func (i12 TestStructSliceLiteralInspector) TypeName() string {
	return "TestStructSliceLiteral"
}

func (i12 TestStructSliceLiteralInspector) Get(src any, path ...string) (any, error) {
	var buf any
	err := i12.GetTo(src, &buf, path...)
	return buf, err
}

func (i12 TestStructSliceLiteralInspector) GetTo(src any, buf *any, path ...string) (err error) {
	if src == nil {
		return
	}
	var x *testobj.TestStructSliceLiteral
	_ = x
	if p, ok := src.(**testobj.TestStructSliceLiteral); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestStructSliceLiteral); ok {
		x = p
	} else if v, ok := src.(testobj.TestStructSliceLiteral); ok {
		x = &v
	} else {
		return
	}
	if len(path) == 0 {
		*buf = &(*x)
		return
	}

	if len(path) > 0 {
		var i int
		t335, err335 := strconv.ParseInt(path[0], 0, 0)
		if err335 != nil {
			return err335
		}
		i = int(t335)
		if len(*x) > i {
			x0 := (*x)[i]
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if path[1] == "A" {
					*buf = &x0.A
					return
				}
				if path[1] == "S" {
					*buf = &x0.S
					return
				}
				if path[1] == "B" {
					*buf = &x0.B
					return
				}
				if path[1] == "I" {
					*buf = &x0.I
					return
				}
				if path[1] == "I8" {
					*buf = &x0.I8
					return
				}
				if path[1] == "I16" {
					*buf = &x0.I16
					return
				}
				if path[1] == "I32" {
					*buf = &x0.I32
					return
				}
				if path[1] == "I64" {
					*buf = &x0.I64
					return
				}
				if path[1] == "U" {
					*buf = &x0.U
					return
				}
				if path[1] == "U8" {
					*buf = &x0.U8
					return
				}
				if path[1] == "U16" {
					*buf = &x0.U16
					return
				}
				if path[1] == "U32" {
					*buf = &x0.U32
					return
				}
				if path[1] == "U64" {
					*buf = &x0.U64
					return
				}
				if path[1] == "F" {
					*buf = &x0.F
					return
				}
				if path[1] == "D" {
					*buf = &x0.D
					return
				}
			}
			*buf = x0
		}
	}
	return
}

func (i12 TestStructSliceLiteralInspector) Cmp(src any, cond inspector.Op, right string, result *bool, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *testobj.TestStructSliceLiteral
	_ = x
	if p, ok := src.(**testobj.TestStructSliceLiteral); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestStructSliceLiteral); ok {
		x = p
	} else if v, ok := src.(testobj.TestStructSliceLiteral); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
		var i int
		t336, err336 := strconv.ParseInt(path[0], 0, 0)
		if err336 != nil {
			return err336
		}
		i = int(t336)
		if len(*x) > i {
			x0 := (*x)[i]
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if path[1] == "A" {
					var rightExact byte
					t337 := fastconv.S2B(right)
					if len(t337) > 0 {
						rightExact = t337[0]
					}

					switch cond {
					case inspector.OpEq:
						*result = x0.A == rightExact
					case inspector.OpNq:
						*result = x0.A != rightExact
					case inspector.OpGt:
						*result = x0.A > rightExact
					case inspector.OpGtq:
						*result = x0.A >= rightExact
					case inspector.OpLt:
						*result = x0.A < rightExact
					case inspector.OpLtq:
						*result = x0.A <= rightExact
					}
					return
				}
				if path[1] == "S" {
					var rightExact string
					rightExact = right

					switch cond {
					case inspector.OpEq:
						*result = x0.S == rightExact
					case inspector.OpNq:
						*result = x0.S != rightExact
					case inspector.OpGt:
						*result = x0.S > rightExact
					case inspector.OpGtq:
						*result = x0.S >= rightExact
					case inspector.OpLt:
						*result = x0.S < rightExact
					case inspector.OpLtq:
						*result = x0.S <= rightExact
					}
					return
				}
				if path[1] == "B" {
					var rightExact []byte
					rightExact = fastconv.S2B(right)

					if cond == inspector.OpEq {
						*result = bytes.Equal(x0.B, rightExact)
					} else {
						*result = !bytes.Equal(x0.B, rightExact)
					}
					return
				}
				if path[1] == "I" {
					var rightExact int
					t340, err340 := strconv.ParseInt(right, 0, 0)
					if err340 != nil {
						return err340
					}
					rightExact = int(t340)
					switch cond {
					case inspector.OpEq:
						*result = x0.I == rightExact
					case inspector.OpNq:
						*result = x0.I != rightExact
					case inspector.OpGt:
						*result = x0.I > rightExact
					case inspector.OpGtq:
						*result = x0.I >= rightExact
					case inspector.OpLt:
						*result = x0.I < rightExact
					case inspector.OpLtq:
						*result = x0.I <= rightExact
					}
					return
				}
				if path[1] == "I8" {
					var rightExact int8
					t341, err341 := strconv.ParseInt(right, 0, 0)
					if err341 != nil {
						return err341
					}
					rightExact = int8(t341)
					switch cond {
					case inspector.OpEq:
						*result = x0.I8 == rightExact
					case inspector.OpNq:
						*result = x0.I8 != rightExact
					case inspector.OpGt:
						*result = x0.I8 > rightExact
					case inspector.OpGtq:
						*result = x0.I8 >= rightExact
					case inspector.OpLt:
						*result = x0.I8 < rightExact
					case inspector.OpLtq:
						*result = x0.I8 <= rightExact
					}
					return
				}
				if path[1] == "I16" {
					var rightExact int16
					t342, err342 := strconv.ParseInt(right, 0, 0)
					if err342 != nil {
						return err342
					}
					rightExact = int16(t342)
					switch cond {
					case inspector.OpEq:
						*result = x0.I16 == rightExact
					case inspector.OpNq:
						*result = x0.I16 != rightExact
					case inspector.OpGt:
						*result = x0.I16 > rightExact
					case inspector.OpGtq:
						*result = x0.I16 >= rightExact
					case inspector.OpLt:
						*result = x0.I16 < rightExact
					case inspector.OpLtq:
						*result = x0.I16 <= rightExact
					}
					return
				}
				if path[1] == "I32" {
					var rightExact int32
					t343, err343 := strconv.ParseInt(right, 0, 0)
					if err343 != nil {
						return err343
					}
					rightExact = int32(t343)
					switch cond {
					case inspector.OpEq:
						*result = x0.I32 == rightExact
					case inspector.OpNq:
						*result = x0.I32 != rightExact
					case inspector.OpGt:
						*result = x0.I32 > rightExact
					case inspector.OpGtq:
						*result = x0.I32 >= rightExact
					case inspector.OpLt:
						*result = x0.I32 < rightExact
					case inspector.OpLtq:
						*result = x0.I32 <= rightExact
					}
					return
				}
				if path[1] == "I64" {
					var rightExact int64
					t344, err344 := strconv.ParseInt(right, 0, 0)
					if err344 != nil {
						return err344
					}
					rightExact = int64(t344)
					switch cond {
					case inspector.OpEq:
						*result = x0.I64 == rightExact
					case inspector.OpNq:
						*result = x0.I64 != rightExact
					case inspector.OpGt:
						*result = x0.I64 > rightExact
					case inspector.OpGtq:
						*result = x0.I64 >= rightExact
					case inspector.OpLt:
						*result = x0.I64 < rightExact
					case inspector.OpLtq:
						*result = x0.I64 <= rightExact
					}
					return
				}
				if path[1] == "U" {
					var rightExact uint
					t345, err345 := strconv.ParseUint(right, 0, 0)
					if err345 != nil {
						return err345
					}
					rightExact = uint(t345)
					switch cond {
					case inspector.OpEq:
						*result = x0.U == rightExact
					case inspector.OpNq:
						*result = x0.U != rightExact
					case inspector.OpGt:
						*result = x0.U > rightExact
					case inspector.OpGtq:
						*result = x0.U >= rightExact
					case inspector.OpLt:
						*result = x0.U < rightExact
					case inspector.OpLtq:
						*result = x0.U <= rightExact
					}
					return
				}
				if path[1] == "U8" {
					var rightExact uint8
					t346, err346 := strconv.ParseUint(right, 0, 0)
					if err346 != nil {
						return err346
					}
					rightExact = uint8(t346)
					switch cond {
					case inspector.OpEq:
						*result = x0.U8 == rightExact
					case inspector.OpNq:
						*result = x0.U8 != rightExact
					case inspector.OpGt:
						*result = x0.U8 > rightExact
					case inspector.OpGtq:
						*result = x0.U8 >= rightExact
					case inspector.OpLt:
						*result = x0.U8 < rightExact
					case inspector.OpLtq:
						*result = x0.U8 <= rightExact
					}
					return
				}
				if path[1] == "U16" {
					var rightExact uint16
					t347, err347 := strconv.ParseUint(right, 0, 0)
					if err347 != nil {
						return err347
					}
					rightExact = uint16(t347)
					switch cond {
					case inspector.OpEq:
						*result = x0.U16 == rightExact
					case inspector.OpNq:
						*result = x0.U16 != rightExact
					case inspector.OpGt:
						*result = x0.U16 > rightExact
					case inspector.OpGtq:
						*result = x0.U16 >= rightExact
					case inspector.OpLt:
						*result = x0.U16 < rightExact
					case inspector.OpLtq:
						*result = x0.U16 <= rightExact
					}
					return
				}
				if path[1] == "U32" {
					var rightExact uint32
					t348, err348 := strconv.ParseUint(right, 0, 0)
					if err348 != nil {
						return err348
					}
					rightExact = uint32(t348)
					switch cond {
					case inspector.OpEq:
						*result = x0.U32 == rightExact
					case inspector.OpNq:
						*result = x0.U32 != rightExact
					case inspector.OpGt:
						*result = x0.U32 > rightExact
					case inspector.OpGtq:
						*result = x0.U32 >= rightExact
					case inspector.OpLt:
						*result = x0.U32 < rightExact
					case inspector.OpLtq:
						*result = x0.U32 <= rightExact
					}
					return
				}
				if path[1] == "U64" {
					var rightExact uint64
					t349, err349 := strconv.ParseUint(right, 0, 0)
					if err349 != nil {
						return err349
					}
					rightExact = uint64(t349)
					switch cond {
					case inspector.OpEq:
						*result = x0.U64 == rightExact
					case inspector.OpNq:
						*result = x0.U64 != rightExact
					case inspector.OpGt:
						*result = x0.U64 > rightExact
					case inspector.OpGtq:
						*result = x0.U64 >= rightExact
					case inspector.OpLt:
						*result = x0.U64 < rightExact
					case inspector.OpLtq:
						*result = x0.U64 <= rightExact
					}
					return
				}
				if path[1] == "F" {
					var rightExact float32
					t350, err350 := strconv.ParseFloat(right, 0)
					if err350 != nil {
						return err350
					}
					rightExact = float32(t350)
					switch cond {
					case inspector.OpEq:
						*result = x0.F == rightExact
					case inspector.OpNq:
						*result = x0.F != rightExact
					case inspector.OpGt:
						*result = x0.F > rightExact
					case inspector.OpGtq:
						*result = x0.F >= rightExact
					case inspector.OpLt:
						*result = x0.F < rightExact
					case inspector.OpLtq:
						*result = x0.F <= rightExact
					}
					return
				}
				if path[1] == "D" {
					var rightExact float64
					t351, err351 := strconv.ParseFloat(right, 0)
					if err351 != nil {
						return err351
					}
					rightExact = float64(t351)
					switch cond {
					case inspector.OpEq:
						*result = x0.D == rightExact
					case inspector.OpNq:
						*result = x0.D != rightExact
					case inspector.OpGt:
						*result = x0.D > rightExact
					case inspector.OpGtq:
						*result = x0.D >= rightExact
					case inspector.OpLt:
						*result = x0.D < rightExact
					case inspector.OpLtq:
						*result = x0.D <= rightExact
					}
					return
				}
			}
		}
	}
	return
}

func (i12 TestStructSliceLiteralInspector) Loop(src any, l inspector.Looper, buf *[]byte, path ...string) (err error) {
	if src == nil {
		return
	}
	var x *testobj.TestStructSliceLiteral
	_ = x
	if p, ok := src.(**testobj.TestStructSliceLiteral); ok {
		x = *p
	} else if p, ok := src.(*testobj.TestStructSliceLiteral); ok {
		x = p
	} else if v, ok := src.(testobj.TestStructSliceLiteral); ok {
		x = &v
	} else {
		return
	}

	for k := range *x {
		if l.RequireKey() {
			*buf = strconv.AppendInt((*buf)[:0], int64(k), 10)
			l.SetKey(buf, &inspector.StaticInspector{})
		}
		l.SetVal(&(*x)[k], &TestStructInspector{})
		ctl := l.Iterate()
		if ctl == inspector.LoopCtlBrk {
			break
		}
		if ctl == inspector.LoopCtlCnt {
			continue
		}
	}
	return
	return
}

func (i12 TestStructSliceLiteralInspector) SetWB(dst, value any, buf inspector.AccumulativeBuffer, path ...string) error {
	if len(path) == 0 {
		return nil
	}
	if dst == nil {
		return nil
	}
	var x *testobj.TestStructSliceLiteral
	_ = x
	if p, ok := dst.(**testobj.TestStructSliceLiteral); ok {
		x = *p
	} else if p, ok := dst.(*testobj.TestStructSliceLiteral); ok {
		x = p
	} else if v, ok := dst.(testobj.TestStructSliceLiteral); ok {
		x = &v
	} else {
		return nil
	}

	if len(path) > 0 {
		var i int
		t352, err352 := strconv.ParseInt(path[0], 0, 0)
		if err352 != nil {
			return err352
		}
		i = int(t352)
		if len(*x) > i {
			x0 := (*x)[i]
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				if path[1] == "A" {
					inspector.AssignBuf(&x0.A, value, buf)
					return nil
				}
				if path[1] == "S" {
					inspector.AssignBuf(&x0.S, value, buf)
					return nil
				}
				if path[1] == "B" {
					inspector.AssignBuf(&x0.B, value, buf)
					return nil
				}
				if path[1] == "I" {
					inspector.AssignBuf(&x0.I, value, buf)
					return nil
				}
				if path[1] == "I8" {
					inspector.AssignBuf(&x0.I8, value, buf)
					return nil
				}
				if path[1] == "I16" {
					inspector.AssignBuf(&x0.I16, value, buf)
					return nil
				}
				if path[1] == "I32" {
					inspector.AssignBuf(&x0.I32, value, buf)
					return nil
				}
				if path[1] == "I64" {
					inspector.AssignBuf(&x0.I64, value, buf)
					return nil
				}
				if path[1] == "U" {
					inspector.AssignBuf(&x0.U, value, buf)
					return nil
				}
				if path[1] == "U8" {
					inspector.AssignBuf(&x0.U8, value, buf)
					return nil
				}
				if path[1] == "U16" {
					inspector.AssignBuf(&x0.U16, value, buf)
					return nil
				}
				if path[1] == "U32" {
					inspector.AssignBuf(&x0.U32, value, buf)
					return nil
				}
				if path[1] == "U64" {
					inspector.AssignBuf(&x0.U64, value, buf)
					return nil
				}
				if path[1] == "F" {
					inspector.AssignBuf(&x0.F, value, buf)
					return nil
				}
				if path[1] == "D" {
					inspector.AssignBuf(&x0.D, value, buf)
					return nil
				}
			}
			(*x)[i] = x0
			return nil
		}
	}
	return nil
}

func (i12 TestStructSliceLiteralInspector) Set(dst, value any, path ...string) error {
	return i12.SetWB(dst, value, nil, path...)
}

func (i12 TestStructSliceLiteralInspector) DeepEqual(l, r any) bool {
	return i12.DeepEqualWithOptions(l, r, nil)
}

func (i12 TestStructSliceLiteralInspector) DeepEqualWithOptions(l, r any, opts *inspector.DEQOptions) bool {
	var (
		lx, rx   *testobj.TestStructSliceLiteral
		leq, req bool
	)
	_, _, _, _ = lx, rx, leq, req
	if lp, ok := l.(**testobj.TestStructSliceLiteral); ok {
		lx, leq = *lp, true
	} else if lp, ok := l.(*testobj.TestStructSliceLiteral); ok {
		lx, leq = lp, true
	} else if lp, ok := l.(testobj.TestStructSliceLiteral); ok {
		lx, leq = &lp, true
	}
	if rp, ok := r.(**testobj.TestStructSliceLiteral); ok {
		rx, req = *rp, true
	} else if rp, ok := r.(*testobj.TestStructSliceLiteral); ok {
		rx, req = rp, true
	} else if rp, ok := r.(testobj.TestStructSliceLiteral); ok {
		rx, req = &rp, true
	}
	if !leq || !req {
		return false
	}
	if lx == nil && rx == nil {
		return true
	}
	if (lx == nil && rx != nil) || (lx != nil && rx == nil) {
		return false
	}

	if len(*lx) != len(*rx) {
		return false
	}
	for i := 0; i < len(*lx); i++ {
		lx1 := (*lx)[i]
		rx1 := (*rx)[i]
		_, _ = lx1, rx1
		if (lx1 == nil && rx1 != nil) || (lx1 != nil && rx1 == nil) {
			return false
		}
		if lx1 != nil && rx1 != nil {
			if lx1.A != rx1.A && inspector.DEQMustCheck("A", opts) {
				return false
			}
			if lx1.S != rx1.S && inspector.DEQMustCheck("S", opts) {
				return false
			}
			if !bytes.Equal(lx1.B, rx1.B) && inspector.DEQMustCheck("B", opts) {
				return false
			}
			if lx1.I != rx1.I && inspector.DEQMustCheck("I", opts) {
				return false
			}
			if lx1.I8 != rx1.I8 && inspector.DEQMustCheck("I8", opts) {
				return false
			}
			if lx1.I16 != rx1.I16 && inspector.DEQMustCheck("I16", opts) {
				return false
			}
			if lx1.I32 != rx1.I32 && inspector.DEQMustCheck("I32", opts) {
				return false
			}
			if lx1.I64 != rx1.I64 && inspector.DEQMustCheck("I64", opts) {
				return false
			}
			if lx1.U != rx1.U && inspector.DEQMustCheck("U", opts) {
				return false
			}
			if lx1.U8 != rx1.U8 && inspector.DEQMustCheck("U8", opts) {
				return false
			}
			if lx1.U16 != rx1.U16 && inspector.DEQMustCheck("U16", opts) {
				return false
			}
			if lx1.U32 != rx1.U32 && inspector.DEQMustCheck("U32", opts) {
				return false
			}
			if lx1.U64 != rx1.U64 && inspector.DEQMustCheck("U64", opts) {
				return false
			}
			if !inspector.EqualFloat32(lx1.F, rx1.F, opts) && inspector.DEQMustCheck("F", opts) {
				return false
			}
			if !inspector.EqualFloat64(lx1.D, rx1.D, opts) && inspector.DEQMustCheck("D", opts) {
				return false
			}
		}
	}
	return true
}

func (i12 TestStructSliceLiteralInspector) Unmarshal(p []byte, typ inspector.Encoding) (any, error) {
	var x testobj.TestStructSliceLiteral
	switch typ {
	case inspector.EncodingJSON:
		err := json.Unmarshal(p, &x)
		return &x, err
	default:
		return nil, inspector.ErrUnknownEncodingType
	}
}

func (i12 TestStructSliceLiteralInspector) Copy(x any) (any, error) {
	var r testobj.TestStructSliceLiteral
	switch x.(type) {
	case testobj.TestStructSliceLiteral:
		r = x.(testobj.TestStructSliceLiteral)
	case *testobj.TestStructSliceLiteral:
		r = *x.(*testobj.TestStructSliceLiteral)
	case **testobj.TestStructSliceLiteral:
		r = **x.(**testobj.TestStructSliceLiteral)
	default:
		return nil, inspector.ErrUnsupportedType
	}
	bc := i12.countBytes(&r)
	var l testobj.TestStructSliceLiteral
	err := i12.CopyTo(&r, &l, inspector.NewByteBuffer(bc))
	return &l, err
}

func (i12 TestStructSliceLiteralInspector) CopyTo(src, dst any, buf inspector.AccumulativeBuffer) error {
	var r testobj.TestStructSliceLiteral
	switch src.(type) {
	case testobj.TestStructSliceLiteral:
		r = src.(testobj.TestStructSliceLiteral)
	case *testobj.TestStructSliceLiteral:
		r = *src.(*testobj.TestStructSliceLiteral)
	case **testobj.TestStructSliceLiteral:
		r = **src.(**testobj.TestStructSliceLiteral)
	default:
		return inspector.ErrUnsupportedType
	}
	var l *testobj.TestStructSliceLiteral
	switch dst.(type) {
	case testobj.TestStructSliceLiteral:
		return inspector.ErrMustPointerType
	case *testobj.TestStructSliceLiteral:
		l = dst.(*testobj.TestStructSliceLiteral)
	case **testobj.TestStructSliceLiteral:
		l = *dst.(**testobj.TestStructSliceLiteral)
	default:
		return inspector.ErrUnsupportedType
	}
	bb := buf.AcquireBytes()
	var err error
	if bb, err = i12.cpy(bb, l, &r); err != nil {
		return err
	}
	buf.ReleaseBytes(bb)
	return nil
}

func (i12 TestStructSliceLiteralInspector) countBytes(x *testobj.TestStructSliceLiteral) (c int) {
	for i0 := 0; i0 < len(*x); i0++ {
		x0 := (*x)[i0]
		c += len(x0.S)
		c += len(x0.B)
	}
	return c
}

func (i12 TestStructSliceLiteralInspector) cpy(buf []byte, l, r *testobj.TestStructSliceLiteral) ([]byte, error) {
	if len(*r) > 0 {
		buf0 := (*l)
		if buf0 == nil {
			buf0 = make(testobj.TestStructSliceLiteral, 0, len(*r))
		}
		for i0 := 0; i0 < len(*r); i0++ {
			var b0 testobj.TestStruct
			x0 := (*r)[i0]
			b0.A = x0.A
			buf, b0.S = inspector.BufferizeString(buf, x0.S)
			buf, b0.B = inspector.Bufferize(buf, x0.B)
			b0.I = x0.I
			b0.I8 = x0.I8
			b0.I16 = x0.I16
			b0.I32 = x0.I32
			b0.I64 = x0.I64
			b0.U = x0.U
			b0.U8 = x0.U8
			b0.U16 = x0.U16
			b0.U32 = x0.U32
			b0.U64 = x0.U64
			b0.F = x0.F
			b0.D = x0.D
			buf0 = append(buf0, &b0)
		}
		l = &buf0
	}
	return buf, nil
}

func (i12 TestStructSliceLiteralInspector) Reset(x any) error {
	var origin *testobj.TestStructSliceLiteral
	_ = origin
	switch x.(type) {
	case testobj.TestStructSliceLiteral:
		return inspector.ErrMustPointerType
	case *testobj.TestStructSliceLiteral:
		origin = x.(*testobj.TestStructSliceLiteral)
	case **testobj.TestStructSliceLiteral:
		origin = *x.(**testobj.TestStructSliceLiteral)
	default:
		return inspector.ErrUnsupportedType
	}
	if l := len((*origin)); l > 0 {
		_ = (*origin)[l-1]
		for i := 0; i < l; i++ {
			x0 := (*origin)[i]
			x0.A = 0
			x0.S = ""
			if l := len((x0.B)); l > 0 {
				(x0.B) = (x0.B)[:0]
			}
			x0.I = 0
			x0.I8 = 0
			x0.I16 = 0
			x0.I32 = 0
			x0.I64 = 0
			x0.U = 0
			x0.U8 = 0
			x0.U16 = 0
			x0.U32 = 0
			x0.U64 = 0
			x0.F = 0
			x0.D = 0
		}
		(*origin) = (*origin)[:0]
	}
	return nil
}
